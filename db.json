{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-icarus/source/css/cyberpunk.styl","path":"css/cyberpunk.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/css/default.styl","path":"css/default.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/favicon.svg","path":"img/favicon.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/logo.svg","path":"img/logo.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/og_image.png","path":"img/og_image.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-bottom-black.svg","path":"img/razor-bottom-black.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-top-black.svg","path":"img/razor-top-black.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/animation.js","path":"js/animation.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/back_to_top.js","path":"js/back_to_top.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/column.js","path":"js/column.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"f212d288b5790d4b0c65c6c0efb845933d71bdca","modified":1600627678427},{"_id":"node_modules/hexo-theme-icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/CONTRIBUTING.md","hash":"70254c6778c1e41bb2ff222bbf3a70b2239b9bc1","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/LICENSE","hash":"86037e5335a49321fa73b7815cab542057fac944","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/README.md","hash":"059d1e0714668ed0818f87ac6cf81f479ead7c3e","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/package.json","hash":"9b878dfdc41cf617fc12f60c7c84dc41a66bfe69","modified":1600357672592},{"_id":"node_modules/hexo-theme-icarus/include/config.js","hash":"1ff0f174e9670074ad2bee890d5b6da486800c9a","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/dependency.js","hash":"d30dbcefd58619f6705d6369b644bc7ba44d2421","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/register.js","hash":"3b8fa0d77193941aa0aebcafd02789f043921df8","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/de.yml","hash":"4cfa8e76398a12af36c45cbcc68b1414368c702d","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/en.yml","hash":"c81e0ea89874d956ecead2eaa1fdaddc6ecf6f4c","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/es.yml","hash":"cf56d75a6d71b6905cada175838aaa26fc5acc21","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/fr.yml","hash":"d2855408652ddc23d143f02c79dd820633827297","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/id.yml","hash":"c00c231fbfaae8e40ffe8e54d9d85ab85ca1995b","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/ja.yml","hash":"4efacf1a471e90be6b1c89582901524419811fac","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/ko.yml","hash":"37c4c7e3f21544d84d88ec757643df047a26a232","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/pl.yml","hash":"3a238587e0092e000f85373bb27ad0c0398d355b","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/pt-BR.yml","hash":"1e3fb3ffd5658085b7a5298fb549bdd0cb15ff56","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/ru.yml","hash":"96c69e3383de0a39dd679d604683daf54f874b11","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/tr.yml","hash":"849effc2ac69a0ea3a189b135640bc3e6bf3b799","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/vn.yml","hash":"998c3a8faf82a98fda563bbce1f5c7241ba3239c","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/zh-CN.yml","hash":"7bbb6d1ead5d64b830d498c03ac9bb98cd7d1bea","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/zh-TW.yml","hash":"52e8a9a85038d5220d7b80ccc408de80cf10e370","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/archive.jsx","hash":"05677e93d4a43f417dbbf0d63ca37a99e6349e3b","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/categories.jsx","hash":"b8ad43e28a4990d222bfbb95b032f88555492347","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/category.jsx","hash":"fd15e4eac32de9ac8687aeb3dbe179ab61375700","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/index.jsx","hash":"0a84a2348394fa9fc5080dd396bd28d357594f47","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/layout.jsx","hash":"a5829907b219e95266f7ed5ee6203e60e2273f93","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/page.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/post.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/tag.jsx","hash":"d2f18cac32ca2725d34ccff3f2051c623be6c892","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/tags.jsx","hash":"2c42cb64778235dd220c563a27a92108ddc50cc4","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/scripts/index.js","hash":"0c666db6fcb4ffc4d300f4e108c00ee42b1cbbe6","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/migration/head.js","hash":"269ba172013cbd2f10b9bc51af0496628081329b","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/migration/v2_v3.js","hash":"3ccb2d2ce11018bebd7172da66faecc3983bff00","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/migration/v3_v4.js","hash":"9faf2184d7fe87debfbe007f3fc9079dcbcafcfe","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/config.json","hash":"ac633f9d349bca4f089d59d2c3738b57376f1b31","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/article.styl","hash":"dc11759285c67d9932ba98769501cce44ce02926","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/base.styl","hash":"1ad643460d47176639450090393c8d78c192ff06","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/button.styl","hash":"0fb35b4786be1b387c751fa2849bc71523fcedd4","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/card.styl","hash":"f78674422eb408cd17c17bbdc3ee1ebe4a453e05","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/codeblock.styl","hash":"30bee4cf6792e9665eb648cc20b352d9eaff1207","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/donate.styl","hash":"acf06ddda9ae3f671f6237fbd059360f631a3ef7","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/footer.styl","hash":"a4ad715dee38b249538ac6cce94efc9b355a904b","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/helper.styl","hash":"09d3fa715d059e3e75e75e685cedb9e97c3b0285","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/navbar.styl","hash":"ecc73c8ad504c0fa4bb910eb51500c14e0a8d662","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/pagination.styl","hash":"748c4fa46a6e2ec73bda213bb966bb2ee840c095","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/plugin.styl","hash":"8c665dad9ad7ecd64a5f969eba244a73c66a03a9","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/responsive.styl","hash":"207083fe287612cddee6608b541861b14ac8de81","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/search.styl","hash":"416737e1da4e7e907bd03609b0fee9e2aacfe56c","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/timeline.styl","hash":"ea61798a09bffdda07efb93c2ff800b63bddc4c4","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/article.jsx","hash":"28e1288bf0611d7e2735b1e70cdcd9e168feecd4","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/comment.jsx","hash":"427089c33002707b76e2f38709459a6824fd0f9b","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/donates.jsx","hash":"889fb0a7ccc502f0a43b4a18eb330e351e50493c","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/footer.jsx","hash":"aeeb66e4faec9099cb5effdbee7ce1902a4bb2da","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/head.jsx","hash":"0fe9ec8ba1fb87b998edb78a9d466f3bfd203187","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/navbar.jsx","hash":"fcd9fd4624dee49207ef09ea2a1c63f524f3710c","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/plugins.jsx","hash":"f6826c1a5f5f59f4a0aa00c63bdb0ad4ff4eab69","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/scripts.jsx","hash":"a6b7a2891bbc7c71dcc2a0e756e9c9847bbb6729","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/search.jsx","hash":"6f244a37293031670a2964fe424ecd062e591d7b","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/share.jsx","hash":"c9fb0319ad5e5a10ad3636b26a6c2afed14c590f","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/widgets.jsx","hash":"689cf4a6b79337b11d1d56afa9dda09223a809a1","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/plugin/animejs.jsx","hash":"e2aa27c3501a58ef1e91e511557b77395c2c02aa","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/plugin/back_to_top.jsx","hash":"7fc0c5aaabd7d0eaff04cb68ec139442dc3414e8","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/widget/profile.jsx","hash":"d25b68e03754c61bc4966bea29dc25d04e3a7aa9","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/css/cyberpunk.styl","hash":"46872ee9ca9483ee17ac20f227a2e4ce83a97e30","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/css/default.styl","hash":"b01da3028e5a1267a40aaae5c86a11187a2259e3","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/css/style.styl","hash":"be5d28ba5098e36483d21f94e4deb0bd2ec075e4","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/article.json","hash":"8d78149f44629d0848921c6fb9c008b03cef3116","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/comment.json","hash":"bd30bd9ffc84e88e704384acdfcaab09019a744f","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/donates.json","hash":"ae86e6f177bedf4afbe638502c12635027539305","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/footer.json","hash":"09d706cbb94d6da9a0d15c719ce7139325cae1c7","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/head.json","hash":"49a2a8c0508bad9446868c3c05e7fa3250855af8","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/navbar.json","hash":"df708bc8a25d4eeec268969f014ad99f9e74ef7a","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/plugins.json","hash":"0217f2af8a4d6731652a3a49b5801bbfe0e73fff","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/providers.json","hash":"97ec953d497fb53594227ae98acaef8a8baa91da","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/search.json","hash":"985fbcbf47054af714ead1a124869d54f2a8b607","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/share.json","hash":"cf4f9ff4fb27c3541b35f57db355c228fa6873e4","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/sidebar.json","hash":"eb241beaec4c73e3085dfb3139ce72e827e20549","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/widgets.json","hash":"d000b4d1d09bdd64756265aa4cd2ea980ab7ddc7","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/plugin/animejs.json","hash":"e62ab6e20bd8862efa1ed32e7c0db0f8acbcfdec","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/plugin/back_to_top.json","hash":"dc0febab7e7b67075d0ad3f80f5ec8b798b68dea","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/widget/profile.json","hash":"690ee1b0791cab47ea03cf42b5b4932ed2aa5675","modified":499162500000},{"_id":"source/_posts/我的第一篇博客.md","hash":"5ceb604d4de0d4472ec0a7f591fa8bfe2ec20f92","modified":1600362898172},{"_id":"public/js/algolia.js","hash":"a8df0c0abeeb4ee1d2d720161f3aea7339380704","modified":1602157178754},{"_id":"public/js/google_cse.js","hash":"1a9881669dfdeb2b3214074eee0d3e01e52db2c4","modified":1602157178754},{"_id":"public/js/insight.js","hash":"86bbdb7305d9bf19ad62d2ca2cf169fc8d9f9d31","modified":1602157178754},{"_id":"public/js/toc.js","hash":"d04f02478bd8db3d2817c45d453ce651d2d96c24","modified":1602157178754},{"_id":"public/content.json","hash":"33474dbd64aa3ed9b00624d93f0e2f752b4123bf","modified":1605109845009},{"_id":"public/2020/09/17/我的第一篇博客/index.html","hash":"dbbdb716c20227cebb116d6dda4e17e1077cd603","modified":1600627791996},{"_id":"public/2020/09/17/hello-world/index.html","hash":"00901920d9699d8a42b22057794ac319acd794dc","modified":1600625554273},{"_id":"public/archives/index.html","hash":"dea2626735a4ca216ebfaaea4669bac780c5f703","modified":1605097559668},{"_id":"public/archives/2020/index.html","hash":"c04fede984bac891f74cc539d1d9cb8b041e44f1","modified":1605097559668},{"_id":"public/archives/2020/09/index.html","hash":"673fcaba93525d4cbf9b4869a012b42e18cd3dac","modified":1605097559668},{"_id":"public/index.html","hash":"8af41d35a3ba373dc2a9adab39c416ea384bc7e1","modified":1605109845009},{"_id":"public/categories/index.html","hash":"1c56f580bb095a01f132b1482992cee474229080","modified":1605097559668},{"_id":"public/tags/index.html","hash":"82a9c8f076f2d63a552afcd264dc04d54e3dd7ee","modified":1605097559668},{"_id":"public/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1600360643874},{"_id":"public/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1600360643874},{"_id":"public/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1600360643874},{"_id":"public/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1600360643874},{"_id":"public/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1600360643874},{"_id":"public/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1600360643874},{"_id":"public/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":1600360643874},{"_id":"public/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1600360643874},{"_id":"public/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1600360643874},{"_id":"public/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":1600360643874},{"_id":"public/css/cyberpunk.css","hash":"0d8dc4bf137bd7ccd0125f1bb6af45c1e51d7489","modified":1602155760985},{"_id":"public/css/default.css","hash":"f36bff9e79cb531e5ac60c5242c449644d3c7750","modified":1602156003255},{"_id":"public/css/style.css","hash":"5f8dadd37d0052c557061018fe6f568f64fced9b","modified":1602156282543},{"_id":"source/_posts/命令行入门.md","hash":"6616fbf95435e4c6c3a6ddf9a105455cbf29a323","modified":1600742920927},{"_id":"public/2020/09/20/命令行入门/index.html","hash":"abb14e428b17d8fbdaa89102c3075c1df4cf853e","modified":1605097559668},{"_id":"public/tags/命令行/index.html","hash":"102a04a40987179928033a25b2e50b7b585c164b","modified":1605097559668},{"_id":"public/2020/09/20/hello-world/index.html","hash":"54aa985533ed0f35cb05f0ccc4450a28bc6f36f8","modified":1600627681311},{"_id":"source/_posts/git的基本操作和Github.md","hash":"798901b76b1a43bd495ff4e3577745113e152c54","modified":1600743051083},{"_id":"public/2020/09/21/git的基本操作和Github/index.html","hash":"b66124cec0d095fef9388f24c1e507ec92ec6612","modified":1605097559668},{"_id":"public/tags/git/index.html","hash":"17562348bb44d1a644d7688abc5a75721b5e8cfc","modified":1605097559668},{"_id":"source/_posts/HTML的历史和学习方法.md","hash":"7376243039b495b3da8c98305967dc04d71ae30c","modified":1600708781652},{"_id":"public/2020/09/21/HTML的历史和学习方法/index.html","hash":"a486a7a69cefe76b92fa9a967fb89b37967c7938","modified":1605097559668},{"_id":"public/tags/HTML/index.html","hash":"8a0f55f2e4906e3505b765aa6cc524abbc64932e","modified":1605097559668},{"_id":"source/_posts/Markdown的一些语法.md","hash":"4d28965dc9600d21f198f8ba5f59bb84b43891a8","modified":1600945410139},{"_id":"public/tags/markdown/index.html","hash":"775baf77b9279f725762f0d61e048f4f42763054","modified":1605097559668},{"_id":"public/2020/09/21/Markdown的一些语法/index.html","hash":"f5e3c67e9334141420c370c65888eebf94e00269","modified":1605097559668},{"_id":"source/_posts/.HTML的历史和学习方法.md.swp","hash":"7245b090357d1e3e1da0f579fa517bf359d0abae","modified":1600709840260},{"_id":"source/_posts/heox","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1600795011129},{"_id":"source/_posts/HTML标签.md","hash":"992ca6cc60d5d484b85da9d68c1629d9c0f2a1c9","modified":1600961449075},{"_id":"public/2020/09/22/HTML标签/index.html","hash":"792d0e9204fa219e69548158416d0b3ef7831b9e","modified":1605097559668},{"_id":"source/_posts/HTML重点标签.md","hash":"b8fcc39c1915065720e88e2cca2a59eba88f9180","modified":1600945199487},{"_id":"public/2020/09/24/HTML重点标签/index.html","hash":"422b8b9b48e67baa0772937c241b07f91bb779af","modified":1605097559668},{"_id":"source/_posts/Ubuntu网络基本常识.md","hash":"ccb64aa76d08cd272144a704c5ae243d4eeaca70","modified":1601137795235},{"_id":"public/2020/09/26/Ubuntu网络基本常识/index.html","hash":"206822d1bdd4c2eb7a4d9d9f458c914c6907e12e","modified":1605097559668},{"_id":"public/tags/ubuntu-网络/index.html","hash":"1bc90b8fc21b3ee89d1d1b906818113c96b4ae17","modified":1601135148661},{"_id":"public/tags/ubuntu网络/index.html","hash":"906d191a4585054de587d8a490761399689e70cd","modified":1605097559668},{"_id":"source/_posts/CSS基础.md","hash":"18a63967535457a6ebb91d84c870f8ceb037348d","modified":1601403983824},{"_id":"public/2020/09/29/CSS基础/index.html","hash":"43ce934f1f237d8e245dd6f50e08ff039124005e","modified":1605097559668},{"_id":"public/tags/CSS/index.html","hash":"3f22bcf1adfd762fe2e95baafdb7b32fad5bc71a","modified":1605097559668},{"_id":"source/_posts/CSS布局.md","hash":"d1d670ee9d081b1e82ea0e1eac1566dc2c8051d6","modified":1601490402070},{"_id":"public/2020/09/29/CSS布局/index.html","hash":"f6c58564360225063248de84b7986c0df42fd42e","modified":1605097559668},{"_id":"source/_posts/.CSS布局.md.swp","hash":"b87a309ab0cc224237ae5b11ec827ed32d311c89","modified":1601482522803},{"_id":"source/_posts/CSS定位.md","hash":"4acd143feb80a7986afaea2b10692124ae5629c0","modified":1601627392599},{"_id":"public/2020/10/02/CSS定位/index.html","hash":"8769c7c080a2b6c7a0c91687bf3d4ec28f01c8f3","modified":1605097559668},{"_id":"public/archives/2020/10/index.html","hash":"3a27d71500816c1f2776c1b9fc1cd3b83aa47d92","modified":1605097559668},{"_id":"source/_posts/z-index与层叠上下文.md","hash":"61a135f744e2f2c84c6d755ecb608f5a87476eac","modified":1601627031294},{"_id":"public/2020/10/02/z-index与层叠上下文/index.html","hash":"5c741830394fa6672889d174c94602864e51ce57","modified":1605097559668},{"_id":"public/archives/page/2/index.html","hash":"50cfcc16fbf28646243a8692bd0a97142ac4fd6e","modified":1605097559668},{"_id":"public/archives/2020/page/2/index.html","hash":"22a4e676769930b26cbc26df4ded9eb2fa8306ff","modified":1605097559668},{"_id":"public/page/2/index.html","hash":"eab85c548cce136ffbb1e271c82be78293f7aaec","modified":1605097559668},{"_id":"source/_posts/CSS动画.md","hash":"1c245dd921b30bddbae147db34dde9097b718ffe","modified":1601743087615},{"_id":"public/2020/10/03/CSS动画/index.html","hash":"248fb45f955110f84e9a626fe64682bfaad0301a","modified":1605097559668},{"_id":"source/_posts/.CSS动画.md.swp","hash":"16d45c6534437adabdddc0c27b77c378d119b0a8","modified":1601728323456},{"_id":"source/_posts/grid布局.md","hash":"3c525af23fd147b384e8ecec9c41bbec4287a75e","modified":1602513691631},{"_id":"public/2020/10/08/grid布局/index.html","hash":"0ef7c1f084f747b310c592344839ec88ceb1320b","modified":1605097559668},{"_id":"public/tags/css/index.html","hash":"db92815dc54959d84834d5a0722975272d7cecb6","modified":1602160918034},{"_id":"themes/icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1602155133474},{"_id":"themes/icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1602155133474},{"_id":"themes/icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1602155133474},{"_id":"themes/icarus/layout/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1602155133474},{"_id":"themes/icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1602155133474},{"_id":"themes/icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1602155133470},{"_id":"themes/icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1602155133470},{"_id":"themes/icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1602155133470},{"_id":"themes/icarus/include/schema/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1602155133470},{"_id":"themes/icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1602155133470},{"_id":"themes/icarus/.eslintignore","hash":"5410a1bef9807f666cd92a0d2020f700e67e4096","modified":1602155133470},{"_id":"themes/icarus/.eslintrc.json","hash":"43c7740158c8690242720b4ff7fa11426fc20c79","modified":1602155133470},{"_id":"themes/icarus/.gitignore","hash":"36084c0851a22bfd393933abb8e262562ffc6802","modified":1602155133470},{"_id":"themes/icarus/.npmignore","hash":"42242c8da7a020a3295e7dd3d18bf022cb08b661","modified":1602155133470},{"_id":"themes/icarus/CONTRIBUTING.md","hash":"70254c6778c1e41bb2ff222bbf3a70b2239b9bc1","modified":1602155133470},{"_id":"themes/icarus/LICENSE","hash":"86037e5335a49321fa73b7815cab542057fac944","modified":1602155133470},{"_id":"themes/icarus/README.md","hash":"247ec8047ee3105d31099dd8e6ca498b6bff1336","modified":1602155133470},{"_id":"themes/icarus/package.json","hash":"cba0e28c5fb498dd45948dd87b90edc3ca87ea6f","modified":1602155133474},{"_id":"themes/icarus/.github/dependabot.yml","hash":"d532d0db30e42211f35823b9885f3ed1b2d51777","modified":1602155133470},{"_id":"themes/icarus/.github/stale.yml","hash":"88c73f6216c5666d2f60b1e8fe690a3f6e561e42","modified":1602155133470},{"_id":"themes/icarus/include/config.js","hash":"1ff0f174e9670074ad2bee890d5b6da486800c9a","modified":1602155133470},{"_id":"themes/icarus/include/dependency.js","hash":"d30dbcefd58619f6705d6369b644bc7ba44d2421","modified":1602155133470},{"_id":"themes/icarus/include/register.js","hash":"a974b56a1fbb254f1ae048cc2221363faaccec25","modified":1602155133470},{"_id":"themes/icarus/languages/de.yml","hash":"01d9c27c3c9224d8c58b1cf7099ef008b9411a45","modified":1602155133474},{"_id":"themes/icarus/languages/en.yml","hash":"1bdb74288808c4d306b46630860e586a1fcd88a7","modified":1602155133474},{"_id":"themes/icarus/languages/es.yml","hash":"48fe3d7d304239b5e5e93f63600093700d6f0fed","modified":1602155133474},{"_id":"themes/icarus/languages/fr.yml","hash":"14765cc6216b4af5a05341315c9f6ee54d636a78","modified":1602155133474},{"_id":"themes/icarus/languages/id.yml","hash":"c04fca89e536d539a8bf95980bff7dff79125ba3","modified":1602155133474},{"_id":"themes/icarus/languages/ja.yml","hash":"7568f246a21813527ccea8a1da72a9526aa2d233","modified":1602155133474},{"_id":"themes/icarus/languages/ko.yml","hash":"f2211a8ca1d73f05a1c931aa11accb4e34c483c4","modified":1602155133474},{"_id":"themes/icarus/languages/pl.yml","hash":"612639b0e0a15185c12eecfe3e8913b629ecdfdf","modified":1602155133474},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"531b22c71fab8aae60ddc7599aaa5f46140cf2c1","modified":1602155133474},{"_id":"themes/icarus/languages/ru.yml","hash":"bf784c6f31e8fb7ed78509468bddecd447c3b73b","modified":1602155133474},{"_id":"themes/icarus/languages/tr.yml","hash":"96d94f7a5d56b2682ae2792f0808139d4b950704","modified":1602155133474},{"_id":"themes/icarus/languages/vn.yml","hash":"64307bfa16d851334e2f37a29a84d644624c2060","modified":1602155133474},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"82ff607b1671b88d259d10b6ce8ca1bb05b2cff4","modified":1602155133474},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"92f8cf599ad06bb14f79f4806ac4c695f60044d7","modified":1602155133474},{"_id":"themes/icarus/layout/archive.jsx","hash":"05677e93d4a43f417dbbf0d63ca37a99e6349e3b","modified":1602155133474},{"_id":"themes/icarus/layout/categories.jsx","hash":"b8ad43e28a4990d222bfbb95b032f88555492347","modified":1602155133474},{"_id":"themes/icarus/layout/category.jsx","hash":"fd15e4eac32de9ac8687aeb3dbe179ab61375700","modified":1602155133474},{"_id":"themes/icarus/layout/index.jsx","hash":"0a84a2348394fa9fc5080dd396bd28d357594f47","modified":1602155133474},{"_id":"themes/icarus/layout/layout.jsx","hash":"a5829907b219e95266f7ed5ee6203e60e2273f93","modified":1602155133474},{"_id":"themes/icarus/layout/page.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1602155133474},{"_id":"themes/icarus/layout/post.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1602155133474},{"_id":"themes/icarus/layout/tag.jsx","hash":"d2f18cac32ca2725d34ccff3f2051c623be6c892","modified":1602155133474},{"_id":"themes/icarus/layout/tags.jsx","hash":"2c42cb64778235dd220c563a27a92108ddc50cc4","modified":1602155133474},{"_id":"themes/icarus/scripts/index.js","hash":"0c666db6fcb4ffc4d300f4e108c00ee42b1cbbe6","modified":1602155133474},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/Bug反馈.md","hash":"d801be6937df21e63113be8840b2e23c465db87b","modified":1602155133470},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/bug_report.md","hash":"5d3abdc1a2a79ef9822865184eced6e31066d8f6","modified":1602155133470},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/config.yml","hash":"42afb69546eae522e340e3adb99f7bfc4cc4c397","modified":1602155133470},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/feature_request.md","hash":"05313e241a3d43fdadb0f74390b562c07c25d4d0","modified":1602155133470},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/功能建议.md","hash":"c6f60f37e6cd0bc21a81b3b07f84e04e9e80fb57","modified":1602155133470},{"_id":"themes/icarus/.github/PULL_REQUEST_TEMPLATE/pull_request_template.md","hash":"e106fa240c24c8bfbdd623549651600c6d786c9c","modified":1602155133470},{"_id":"themes/icarus/.github/workflows/github-release.yml","hash":"48b6bd2cc567687a7b1648c55c8f9de9d44fa9e1","modified":1602155133470},{"_id":"themes/icarus/.github/workflows/lint.yml","hash":"71f04b66e48f065285ba109939999876ef411598","modified":1602155133470},{"_id":"themes/icarus/.github/workflows/npm-publish.yml","hash":"4eabc0c60cb7102fdd5e4b0fbd8c0ac4c17cc8d0","modified":1602155133470},{"_id":"themes/icarus/.github/workflows/test.yml","hash":"f816a5970f4ad4fcf6c8350dbcd4c300c6986cb4","modified":1602155133470},{"_id":"themes/icarus/include/migration/head.js","hash":"269ba172013cbd2f10b9bc51af0496628081329b","modified":1602155133470},{"_id":"themes/icarus/include/migration/v2_v3.js","hash":"3ccb2d2ce11018bebd7172da66faecc3983bff00","modified":1602155133470},{"_id":"themes/icarus/include/migration/v3_v4.js","hash":"9faf2184d7fe87debfbe007f3fc9079dcbcafcfe","modified":1602155133470},{"_id":"themes/icarus/include/schema/config.json","hash":"ac633f9d349bca4f089d59d2c3738b57376f1b31","modified":1602155133470},{"_id":"themes/icarus/include/style/article.styl","hash":"be25e890113e926bbac3bf1461d7ce5427914774","modified":1602155133470},{"_id":"themes/icarus/include/style/base.styl","hash":"2bca6ad099949d52236c87db8db1002ffb99774c","modified":1602155133470},{"_id":"themes/icarus/include/style/button.styl","hash":"0fb35b4786be1b387c751fa2849bc71523fcedd4","modified":1602155133470},{"_id":"themes/icarus/include/style/card.styl","hash":"f78674422eb408cd17c17bbdc3ee1ebe4a453e05","modified":1602155133470},{"_id":"themes/icarus/include/style/codeblock.styl","hash":"30bee4cf6792e9665eb648cc20b352d9eaff1207","modified":1602155133470},{"_id":"themes/icarus/include/style/donate.styl","hash":"8d0af00628c13134b5f30a558608e7bebf18c2ec","modified":1602155133470},{"_id":"themes/icarus/include/style/footer.styl","hash":"a4ad715dee38b249538ac6cce94efc9b355a904b","modified":1602155133470},{"_id":"themes/icarus/include/style/helper.styl","hash":"9f3393e6122cc9f351091bfab960674e962da343","modified":1602155133470},{"_id":"themes/icarus/include/style/navbar.styl","hash":"ecc73c8ad504c0fa4bb910eb51500c14e0a8d662","modified":1602155133470},{"_id":"themes/icarus/include/style/pagination.styl","hash":"b81bcd7ff915b4e9299533addc01bc4575ec35e3","modified":1602155133470},{"_id":"themes/icarus/include/style/plugin.styl","hash":"dc98160142c95ef81ba4789351002a5fcf29c04c","modified":1602155133470},{"_id":"themes/icarus/include/style/responsive.styl","hash":"207083fe287612cddee6608b541861b14ac8de81","modified":1602155133470},{"_id":"themes/icarus/include/style/search.styl","hash":"416737e1da4e7e907bd03609b0fee9e2aacfe56c","modified":1602155133470},{"_id":"themes/icarus/include/style/timeline.styl","hash":"ea61798a09bffdda07efb93c2ff800b63bddc4c4","modified":1602155133470},{"_id":"themes/icarus/include/style/widget.styl","hash":"af07ee43e209b6361eed22171bb50efaef7cbfeb","modified":1602155133474},{"_id":"themes/icarus/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":1602155133474},{"_id":"themes/icarus/layout/common/article.jsx","hash":"f31c5a78fc4b2d72acf4583342be9e72ac9adf21","modified":1602155133474},{"_id":"themes/icarus/layout/common/comment.jsx","hash":"427089c33002707b76e2f38709459a6824fd0f9b","modified":1602155133474},{"_id":"themes/icarus/layout/common/donates.jsx","hash":"889fb0a7ccc502f0a43b4a18eb330e351e50493c","modified":1602155133474},{"_id":"themes/icarus/layout/common/footer.jsx","hash":"baa8e40e036a3ec0114d96893b708435104b4ba9","modified":1602155133474},{"_id":"themes/icarus/layout/common/head.jsx","hash":"bcee2e258d13af6ac439ee6adaeefc06ea384e7e","modified":1602155133474},{"_id":"themes/icarus/layout/common/navbar.jsx","hash":"fcd9fd4624dee49207ef09ea2a1c63f524f3710c","modified":1602155133474},{"_id":"themes/icarus/layout/common/plugins.jsx","hash":"f6826c1a5f5f59f4a0aa00c63bdb0ad4ff4eab69","modified":1602155133474},{"_id":"themes/icarus/layout/common/scripts.jsx","hash":"a6b7a2891bbc7c71dcc2a0e756e9c9847bbb6729","modified":1602155133474},{"_id":"themes/icarus/layout/common/search.jsx","hash":"6f244a37293031670a2964fe424ecd062e591d7b","modified":1602155133474},{"_id":"themes/icarus/layout/common/share.jsx","hash":"c9fb0319ad5e5a10ad3636b26a6c2afed14c590f","modified":1602155133474},{"_id":"themes/icarus/layout/common/widgets.jsx","hash":"689cf4a6b79337b11d1d56afa9dda09223a809a1","modified":1602155133474},{"_id":"themes/icarus/layout/plugin/animejs.jsx","hash":"e2aa27c3501a58ef1e91e511557b77395c2c02aa","modified":1602155133474},{"_id":"themes/icarus/layout/plugin/back_to_top.jsx","hash":"7fc0c5aaabd7d0eaff04cb68ec139442dc3414e8","modified":1602155133474},{"_id":"themes/icarus/layout/widget/profile.jsx","hash":"9163e30324930d241e044a25d2627f29d607d414","modified":1602155133474},{"_id":"themes/icarus/source/css/cyberpunk.styl","hash":"ae17d3528df0c3f089df14a06b7bd82f1bc5fed9","modified":1602155133474},{"_id":"themes/icarus/source/css/default.css","hash":"1324868815df3bd7f749f1118d5ac9141e680b79","modified":1602155618749},{"_id":"themes/icarus/source/css/default.styl","hash":"b01da3028e5a1267a40aaae5c86a11187a2259e3","modified":1602155985561},{"_id":"themes/icarus/source/css/style.styl","hash":"5b9815586e993a6ccbe8cdcfc0c65ea38fc315ac","modified":1602155438968},{"_id":"themes/icarus/source/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1602155133474},{"_id":"themes/icarus/source/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1602155133474},{"_id":"themes/icarus/source/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1602155133474},{"_id":"themes/icarus/source/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1602155133474},{"_id":"themes/icarus/source/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1602155133474},{"_id":"themes/icarus/source/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1602155133474},{"_id":"themes/icarus/source/js/.eslintrc.json","hash":"6bf0641cb69dffac97f69baea192d7fa3ab612cb","modified":1602155133474},{"_id":"themes/icarus/source/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":1602155133474},{"_id":"themes/icarus/source/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1602155133474},{"_id":"themes/icarus/source/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1602155133474},{"_id":"themes/icarus/source/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":1602155133474},{"_id":"themes/icarus/include/schema/common/article.json","hash":"8d78149f44629d0848921c6fb9c008b03cef3116","modified":1602155133470},{"_id":"themes/icarus/include/schema/common/comment.json","hash":"bd30bd9ffc84e88e704384acdfcaab09019a744f","modified":1602155133470},{"_id":"themes/icarus/include/schema/common/donates.json","hash":"ae86e6f177bedf4afbe638502c12635027539305","modified":1602155133470},{"_id":"themes/icarus/include/schema/common/footer.json","hash":"09d706cbb94d6da9a0d15c719ce7139325cae1c7","modified":1602155133470},{"_id":"themes/icarus/include/schema/common/head.json","hash":"98889f059c635e6bdbd51effd04cf1cf44968a66","modified":1602155133470},{"_id":"themes/icarus/include/schema/common/navbar.json","hash":"df708bc8a25d4eeec268969f014ad99f9e74ef7a","modified":1602155133470},{"_id":"themes/icarus/include/schema/common/plugins.json","hash":"6036a805749816416850d944f7d64aaae62e5e75","modified":1602155133470},{"_id":"themes/icarus/include/schema/common/providers.json","hash":"97ec953d497fb53594227ae98acaef8a8baa91da","modified":1602155133470},{"_id":"themes/icarus/include/schema/common/search.json","hash":"985fbcbf47054af714ead1a124869d54f2a8b607","modified":1602155133470},{"_id":"themes/icarus/include/schema/common/share.json","hash":"cf4f9ff4fb27c3541b35f57db355c228fa6873e4","modified":1602155133470},{"_id":"themes/icarus/include/schema/common/sidebar.json","hash":"eb241beaec4c73e3085dfb3139ce72e827e20549","modified":1602155133470},{"_id":"themes/icarus/include/schema/common/widgets.json","hash":"d000b4d1d09bdd64756265aa4cd2ea980ab7ddc7","modified":1602155133470},{"_id":"themes/icarus/include/schema/plugin/animejs.json","hash":"e62ab6e20bd8862efa1ed32e7c0db0f8acbcfdec","modified":1602155133470},{"_id":"themes/icarus/include/schema/plugin/back_to_top.json","hash":"dc0febab7e7b67075d0ad3f80f5ec8b798b68dea","modified":1602155133470},{"_id":"themes/icarus/include/schema/widget/profile.json","hash":"690ee1b0791cab47ea03cf42b5b4932ed2aa5675","modified":1602155133470},{"_id":"public/manifest.json","hash":"735256743c5394eb6481e422c27c00ef646747e1","modified":1602157178754},{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1600355966368},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1600355966368},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1600355966368},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1600355966368},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1600355966368},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1600355966368},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1600355966372},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1600355966368},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1600355966368},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1600355966368},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1600355966368},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1600355966368},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1600355966368},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1600355966368},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1600355966368},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1600355966368},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1600355966368},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1600355966368},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1600355966372},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1600355966372},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1600355966372},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1600355966372},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1600355966372},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1600355966372},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1600355966372},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1600355966372},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1600355966368},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1600355966372},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1600355966372},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1600355966372},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1600355966372},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1600355966372},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1600355966372},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1600355966372},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1600355966372},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1600355966372},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1600355966372},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1600355966372},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1600355966372},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1600355966372},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1600355966372},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1600355966372},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1600355966372},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1600355966372},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1600355966376},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1600355966376},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1600355966376},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1600355966376},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1600355966376},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1600355966376},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1600355966376},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1600355966376},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1600355966380},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1600355966380},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1600355966380},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1600355966372},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1600355966372},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1600355966372},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1600355966372},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1600355966372},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1600355966372},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1600355966372},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1600355966372},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1600355966372},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1600355966372},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1600355966372},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1600355966372},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1600355966372},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1600355966372},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1600355966372},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1600355966372},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1600355966372},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1600355966372},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1600355966372},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1600355966372},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1600355966376},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1600355966376},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1600355966376},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1600355966376},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1600355966376},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1600355966376},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1600355966376},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1600355966376},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1600355966376},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1600355966376},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1602156282543},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1602156282543},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1602156282543},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1602156282543},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1602156282543},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1602156282543},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1602156282543},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1602156282543},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1602156282543},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1602156282543},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1602156282543},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1602156282543},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1602156282543},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1602156282543},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1602156282543},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1602156282543},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1602156282543},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1602156282543},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1602156282543},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1602156282543},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1602156282543},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1602156282543},{"_id":"source/_posts/HTTP入门.md","hash":"bded2ac78ff251964f9b7ae479a1503096ad44d6","modified":1602693555691},{"_id":"public/2020/10/14/HTTP入门/index.html","hash":"26afee4ea5b42787ccf750dab301822d66da2392","modified":1605097559668},{"_id":"public/tags/HTTP/index.html","hash":"7d75b4a23989b3298249d5673beaa16fd92a5129","modified":1605097559668},{"_id":"source/_posts/.HTTP入门.md.swp","hash":"c88cb9fa186df810fe107d15cb4a0548d3dd7e34","modified":1602682079560},{"_id":"source/_posts/内存图和JS世界.md","hash":"881f9222987661268687d25fb29936fc708bd1a5","modified":1603301204964},{"_id":"public/2020/10/21/内存图和JS世界/index.html","hash":"dd16f2315eb5bd3288d34cb7474b2f0f9b8a2fb6","modified":1605097559668},{"_id":"public/tags/javascript/index.html","hash":"10f4404280c5ab90552b7cf929bfa03e1f75b935","modified":1605109845009},{"_id":"source/_posts/Javascript语句.md","hash":"80a9a6422850560c6853696a2421f2d6ec4f5e26","modified":1603729672076},{"_id":"public/2020/10/26/Javascript语句/index.html","hash":"b9cdfb646ff7d8840540c2d6fe24adb659565a2f","modified":1605097559668},{"_id":"source/_posts/JS数据类型（上）.md","hash":"175c298109edce61f8d36c8b676ba494fd11540d","modified":1604152941949},{"_id":"public/2020/10/30/JS数据类型（上）/index.html","hash":"f82c6f00537fc4ee3688bc84510132cfda005a38","modified":1605097559668},{"_id":"source/_posts/JS数据类型（下）.md","hash":"578efd9caa456ffc59ef44f10a0b0c8a770c0e33","modified":1604201392126},{"_id":"public/2020/10/31/JS数据类型（下）/index.html","hash":"2fb71cbe59b86f6ccb9d1656187e235082e9940b","modified":1605097559668},{"_id":"source/_posts/.JS数据类型（下）.md.swp","hash":"c5578ebd860ed8adc444272bf79420b129196c92","modified":1604165113013},{"_id":"source/_posts/JS对象分类.md","hash":"f88c57c95acf3b3e0b4a10ef01279da460ff8dfc","modified":1604822302421},{"_id":"public/2020/11/06/JS对象分类/index.html","hash":"a859095c8b9ef0057a515b17b9fef780f8644e49","modified":1605097559668},{"_id":"public/archives/2020/11/index.html","hash":"468bcb946fb925f4f0cdc2a7ecce3edac07e75e2","modified":1605097559668},{"_id":"source/_posts/JS数组.md","hash":"02b817b32678d4a879ab6cc7d0989e2049d66dd1","modified":1605076721692},{"_id":"public/2020/11/08/JS数组/index.html","hash":"85d3d32e392b396d7965864d6965b4991d0861a2","modified":1605097559668},{"_id":"source/_posts/.JS数组.md.swp","hash":"13c5527becc6e2ff470a320c0bf499a87f469f12","modified":1604824664635},{"_id":"source/_posts/JS函数.md","hash":"af9b41761f451605d2771c03137c1e0dc8aff60f","modified":1605109843446},{"_id":"public/2020/11/11/JS函数/index.html","hash":"f6a1baa4004c72a94ea47ed14c4b6e0a5619e610","modified":1605109845009},{"_id":"public/archives/page/3/index.html","hash":"9ef03026ea0e73647237198df572bdc6e56e7442","modified":1605097559668},{"_id":"public/archives/2020/page/3/index.html","hash":"e3a225cee30e8f5e04ebef2205f9ca15cd68ed78","modified":1605097559668},{"_id":"public/page/3/index.html","hash":"7f2db5db16d61870f3a5e9bc169295651dbbd4e3","modified":1605097559668}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"命令行入门","date":"2020-09-20T18:06:48.000Z","toc":true,"_content":"## 命令行常用命令\n#### 1.单词\n| 英文 | 翻译 | 缩写命令 | 英文 | 翻译 | 缩写命令 |\n| ---- | ---- | ---- | ---- | ---- | ---- |\n|file  | 文件 |/| link | 链接|/|\n|mark  | 制作 |mk| find | 找到|/|\n|move | 动 | mv|echo | 回声|echo|\n|remove | 删除 |rm| touch |触摸|touch|\n|copy | 复制 | cp|change |改变|cd中的c|\n|lies | 列表 | ls|directory |目录/文件夹|cd中的d||recursive | 递归 r|| force| 强制|f|\n<!--more-->\n#### 2.命令中的增删改查\n##### 增：创建文件\n*  创建文件\n__touch xxx.txt__\n__echo hi > xxx.txt__  会覆盖之前xxx.txt内的内容\n__echo hihi >> xxx.txt__  追加‘hihi’到xxx.txt\n* 创建目录\n__mkdir a__\n__markdir -p a/b/c__\n* 同时创建多个文件\n__touch 1.txt 2.txt__\n* 复制文件\n__cp 1.txt 2.txt__  2.txt处也可以跟路径，意思是把1.txt 复制到某个目录下，命命名为2.txt\n* 复制目录\n__cp -r a b__\n\n##### 删：删除文件\n* 删除文件\n__rm xxx.txt__\n* 删除目录/文件夹\n__rm -rf xxx__ -rf的意思是强制递归方式删除目录\n\n##### 查：查看文件或目录\n* 查看当前目录的绝对路径\n__pwd__\n* 查看当前目录的内容\n__ls__\n__ls -a__ 可以查看隐藏的文件和文件的属性\n* 查看指定目录的内容\n__ls 路径__\n* 查看文件内容\n__cat__ 路径 全部查看\n__head__ 路径 查看前10行 跟参数-n 可以指定查看前n行，默认是10行\n__tail__ 路径 查看后10行 跟参数-n 可以指定查看后n行 ，默认是10行\n__less__ 路径  可以让查看的窗口变成滚动的\n\n> 可以以下命令来安装gtldr，来查询命令的常用参数\n```\nnpm i -g tldr\nyarn global add tldr\n```\n\n资料来源：饥人谷!!\n","source":"_posts/命令行入门.md","raw":"---\ntitle: 命令行入门\ndate: 2020-09-20 18:06:48\ntags: '命令行'\ntoc: true\n---\n## 命令行常用命令\n#### 1.单词\n| 英文 | 翻译 | 缩写命令 | 英文 | 翻译 | 缩写命令 |\n| ---- | ---- | ---- | ---- | ---- | ---- |\n|file  | 文件 |/| link | 链接|/|\n|mark  | 制作 |mk| find | 找到|/|\n|move | 动 | mv|echo | 回声|echo|\n|remove | 删除 |rm| touch |触摸|touch|\n|copy | 复制 | cp|change |改变|cd中的c|\n|lies | 列表 | ls|directory |目录/文件夹|cd中的d||recursive | 递归 r|| force| 强制|f|\n<!--more-->\n#### 2.命令中的增删改查\n##### 增：创建文件\n*  创建文件\n__touch xxx.txt__\n__echo hi > xxx.txt__  会覆盖之前xxx.txt内的内容\n__echo hihi >> xxx.txt__  追加‘hihi’到xxx.txt\n* 创建目录\n__mkdir a__\n__markdir -p a/b/c__\n* 同时创建多个文件\n__touch 1.txt 2.txt__\n* 复制文件\n__cp 1.txt 2.txt__  2.txt处也可以跟路径，意思是把1.txt 复制到某个目录下，命命名为2.txt\n* 复制目录\n__cp -r a b__\n\n##### 删：删除文件\n* 删除文件\n__rm xxx.txt__\n* 删除目录/文件夹\n__rm -rf xxx__ -rf的意思是强制递归方式删除目录\n\n##### 查：查看文件或目录\n* 查看当前目录的绝对路径\n__pwd__\n* 查看当前目录的内容\n__ls__\n__ls -a__ 可以查看隐藏的文件和文件的属性\n* 查看指定目录的内容\n__ls 路径__\n* 查看文件内容\n__cat__ 路径 全部查看\n__head__ 路径 查看前10行 跟参数-n 可以指定查看前n行，默认是10行\n__tail__ 路径 查看后10行 跟参数-n 可以指定查看后n行 ，默认是10行\n__less__ 路径  可以让查看的窗口变成滚动的\n\n> 可以以下命令来安装gtldr，来查询命令的常用参数\n```\nnpm i -g tldr\nyarn global add tldr\n```\n\n资料来源：饥人谷!!\n","slug":"命令行入门","published":1,"updated":"2020-09-22T02:48:40.927Z","_id":"ckfbf0u0c0000kgfq1s28en8u","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"命令行常用命令\"><a href=\"#命令行常用命令\" class=\"headerlink\" title=\"命令行常用命令\"></a>命令行常用命令</h2><h4 id=\"1-单词\"><a href=\"#1-单词\" class=\"headerlink\" title=\"1.单词\"></a>1.单词</h4><table>\n<thead>\n<tr>\n<th>英文</th>\n<th>翻译</th>\n<th>缩写命令</th>\n<th>英文</th>\n<th>翻译</th>\n<th>缩写命令</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>file</td>\n<td>文件</td>\n<td>/</td>\n<td>link</td>\n<td>链接</td>\n<td>/</td>\n</tr>\n<tr>\n<td>mark</td>\n<td>制作</td>\n<td>mk</td>\n<td>find</td>\n<td>找到</td>\n<td>/</td>\n</tr>\n<tr>\n<td>move</td>\n<td>动</td>\n<td>mv</td>\n<td>echo</td>\n<td>回声</td>\n<td>echo</td>\n</tr>\n<tr>\n<td>remove</td>\n<td>删除</td>\n<td>rm</td>\n<td>touch</td>\n<td>触摸</td>\n<td>touch</td>\n</tr>\n<tr>\n<td>copy</td>\n<td>复制</td>\n<td>cp</td>\n<td>change</td>\n<td>改变</td>\n<td>cd中的c</td>\n</tr>\n<tr>\n<td>lies</td>\n<td>列表</td>\n<td>ls</td>\n<td>directory</td>\n<td>目录/文件夹</td>\n<td>cd中的d</td>\n</tr>\n</tbody></table>\n<a id=\"more\"></a>\n<h4 id=\"2-命令中的增删改查\"><a href=\"#2-命令中的增删改查\" class=\"headerlink\" title=\"2.命令中的增删改查\"></a>2.命令中的增删改查</h4><h5 id=\"增：创建文件\"><a href=\"#增：创建文件\" class=\"headerlink\" title=\"增：创建文件\"></a>增：创建文件</h5><ul>\n<li>创建文件<br><strong>touch xxx.txt</strong><br><strong>echo hi &gt; xxx.txt</strong>  会覆盖之前xxx.txt内的内容<br><strong>echo hihi &gt;&gt; xxx.txt</strong>  追加‘hihi’到xxx.txt</li>\n<li>创建目录<br><strong>mkdir a</strong><br><strong>markdir -p a/b/c</strong></li>\n<li>同时创建多个文件<br><strong>touch 1.txt 2.txt</strong></li>\n<li>复制文件<br><strong>cp 1.txt 2.txt</strong>  2.txt处也可以跟路径，意思是把1.txt 复制到某个目录下，命命名为2.txt</li>\n<li>复制目录<br><strong>cp -r a b</strong></li>\n</ul>\n<h5 id=\"删：删除文件\"><a href=\"#删：删除文件\" class=\"headerlink\" title=\"删：删除文件\"></a>删：删除文件</h5><ul>\n<li>删除文件<br><strong>rm xxx.txt</strong></li>\n<li>删除目录/文件夹<br><strong>rm -rf xxx</strong> -rf的意思是强制递归方式删除目录</li>\n</ul>\n<h5 id=\"查：查看文件或目录\"><a href=\"#查：查看文件或目录\" class=\"headerlink\" title=\"查：查看文件或目录\"></a>查：查看文件或目录</h5><ul>\n<li>查看当前目录的绝对路径<br><strong>pwd</strong></li>\n<li>查看当前目录的内容<br><strong>ls</strong><br><strong>ls -a</strong> 可以查看隐藏的文件和文件的属性</li>\n<li>查看指定目录的内容<br><strong>ls 路径</strong></li>\n<li>查看文件内容<br><strong>cat</strong> 路径 全部查看<br><strong>head</strong> 路径 查看前10行 跟参数-n 可以指定查看前n行，默认是10行<br><strong>tail</strong> 路径 查看后10行 跟参数-n 可以指定查看后n行 ，默认是10行<br><strong>less</strong> 路径  可以让查看的窗口变成滚动的</li>\n</ul>\n<blockquote>\n<p>可以以下命令来安装gtldr，来查询命令的常用参数</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -g tldr</span><br><span class=\"line\">yarn global add tldr</span><br></pre></td></tr></table></figure>\n\n<p>资料来源：饥人谷!!</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"命令行常用命令\"><a href=\"#命令行常用命令\" class=\"headerlink\" title=\"命令行常用命令\"></a>命令行常用命令</h2><h4 id=\"1-单词\"><a href=\"#1-单词\" class=\"headerlink\" title=\"1.单词\"></a>1.单词</h4><table>\n<thead>\n<tr>\n<th>英文</th>\n<th>翻译</th>\n<th>缩写命令</th>\n<th>英文</th>\n<th>翻译</th>\n<th>缩写命令</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>file</td>\n<td>文件</td>\n<td>/</td>\n<td>link</td>\n<td>链接</td>\n<td>/</td>\n</tr>\n<tr>\n<td>mark</td>\n<td>制作</td>\n<td>mk</td>\n<td>find</td>\n<td>找到</td>\n<td>/</td>\n</tr>\n<tr>\n<td>move</td>\n<td>动</td>\n<td>mv</td>\n<td>echo</td>\n<td>回声</td>\n<td>echo</td>\n</tr>\n<tr>\n<td>remove</td>\n<td>删除</td>\n<td>rm</td>\n<td>touch</td>\n<td>触摸</td>\n<td>touch</td>\n</tr>\n<tr>\n<td>copy</td>\n<td>复制</td>\n<td>cp</td>\n<td>change</td>\n<td>改变</td>\n<td>cd中的c</td>\n</tr>\n<tr>\n<td>lies</td>\n<td>列表</td>\n<td>ls</td>\n<td>directory</td>\n<td>目录/文件夹</td>\n<td>cd中的d</td>\n</tr>\n</tbody></table>","more":"<h4 id=\"2-命令中的增删改查\"><a href=\"#2-命令中的增删改查\" class=\"headerlink\" title=\"2.命令中的增删改查\"></a>2.命令中的增删改查</h4><h5 id=\"增：创建文件\"><a href=\"#增：创建文件\" class=\"headerlink\" title=\"增：创建文件\"></a>增：创建文件</h5><ul>\n<li>创建文件<br><strong>touch xxx.txt</strong><br><strong>echo hi &gt; xxx.txt</strong>  会覆盖之前xxx.txt内的内容<br><strong>echo hihi &gt;&gt; xxx.txt</strong>  追加‘hihi’到xxx.txt</li>\n<li>创建目录<br><strong>mkdir a</strong><br><strong>markdir -p a/b/c</strong></li>\n<li>同时创建多个文件<br><strong>touch 1.txt 2.txt</strong></li>\n<li>复制文件<br><strong>cp 1.txt 2.txt</strong>  2.txt处也可以跟路径，意思是把1.txt 复制到某个目录下，命命名为2.txt</li>\n<li>复制目录<br><strong>cp -r a b</strong></li>\n</ul>\n<h5 id=\"删：删除文件\"><a href=\"#删：删除文件\" class=\"headerlink\" title=\"删：删除文件\"></a>删：删除文件</h5><ul>\n<li>删除文件<br><strong>rm xxx.txt</strong></li>\n<li>删除目录/文件夹<br><strong>rm -rf xxx</strong> -rf的意思是强制递归方式删除目录</li>\n</ul>\n<h5 id=\"查：查看文件或目录\"><a href=\"#查：查看文件或目录\" class=\"headerlink\" title=\"查：查看文件或目录\"></a>查：查看文件或目录</h5><ul>\n<li>查看当前目录的绝对路径<br><strong>pwd</strong></li>\n<li>查看当前目录的内容<br><strong>ls</strong><br><strong>ls -a</strong> 可以查看隐藏的文件和文件的属性</li>\n<li>查看指定目录的内容<br><strong>ls 路径</strong></li>\n<li>查看文件内容<br><strong>cat</strong> 路径 全部查看<br><strong>head</strong> 路径 查看前10行 跟参数-n 可以指定查看前n行，默认是10行<br><strong>tail</strong> 路径 查看后10行 跟参数-n 可以指定查看后n行 ，默认是10行<br><strong>less</strong> 路径  可以让查看的窗口变成滚动的</li>\n</ul>\n<blockquote>\n<p>可以以下命令来安装gtldr，来查询命令的常用参数</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -g tldr</span><br><span class=\"line\">yarn global add tldr</span><br></pre></td></tr></table></figure>\n\n<p>资料来源：饥人谷!!</p>"},{"title":"git的基本操作和Github","date":"2020-09-21T07:20:43.000Z","toc":true,"_content":"# git的基本操作\n__配置本地的git__\n```git\ngit config --global user.name你的英文名\ngit config --global user.emai1你的邮箱\ngit config --globa1 push default simple\ngit config --global core. quotepath false\ngit config --global coreeditor code --wait\ngit config --globa1 core. autocrif input\n```\n<!--more-->\n__1.初始化本地仓库__\n```git\ngit init\n```\n操作完以后，本地会多出一个.git的目录，里面会记录各个版本的变化，如下图所示。\n![](./img/1.png)\n__2.把需要变动的内容提交到暂存区__\n```git\ngit add 路径  //提交某个路径下的文件\ngit add .     //把当前目录的所有文件提交到暂存区\n```\n__3.描述哪些文件不提交__\n```git\ntouch .gitignore\nvi .gitignore \n```\n.gitignore文件是描述哪些文件不会被提交到暂存区。把不需要提交的文件名写到.gitignore里面，就不会被提交。\n\n__4.把暂存区的文件提交到.git目录__\n```git\ngit commit -m 字符串 //提交并说明理由，字符串里面如果有空格，就要用引号包起来\ngit commit -v //会弹出对话框，告诉你这次提交变更了什么\n```\n__5.查看git的版本号__\n```git\ngit log 查看当前版本号之前历史版本\ngit reflog 查看所有git的历史版本\n```\n__6.回到之前的版本__\n```git\ngit reset --head xxxxxx\n```\n以上的xxxxxx代表版本号，可以通过git log 和 git reflog 来查看，需要回退的版本。\n\n__7.创建分支__\n```git\ngit branch xxx\n```\n创建一个分支，并命名为xxx\n\n__8.删除分支__\n```git\ngit branch -d xxx\n```\n删除分支xxx\n\n__9.切换分支__\n```git\ngit checkout xxx\n```\n切换分支到xxx ，默认的分支名是master\n\n__10.将一个分支合并到当前分支__\n```git\ngit merge xxx\n```\n将xxx分支合并到当前分支\n\n-------\n\n# git远程仓库GitHub\n> GItHub就是用来备份本地 `.git` 而已，没有什么高科技原理。\n\n__1.生成ssh key__\n```git\nssh-keygen -t rsa -b 4096 -C 'your Email'\n```\n连续点3个回车，就可以下载到本地目录了\n\n```git\ncat ~/.ssh/id_rsa.pub\n```\n得到公钥内容，复制到Github个人设置里面就可以了\n\n__2.Github上创建一个远程仓库__\n![](./img/2.png)\ngithub个人主页创建仓库\n![](./img/3.png)\n描述仓库的名称，并且生成仓库\n\n__3.把本地目录上传到远程仓库__\n```git\ngit remote add origin git@xxxxxxx\n```\n`origin` 是远程仓库的默认名字，可以换，但是建议不要换\n`git@xxxxxx` 是远程仓库的地址\n\n```git\ngit push -u origin master\n```\n第一次推送需要写全，以后写`git push`就可以了，这段代码的意思是推送本地master分支到远程仓库origin的master分支。\n如果提示`git pull` 就`git pull`。提示`git pull`是因为本地代码与远程仓库有不同，所以`git pull`就是让本地和远程仓库保持一致。\n\n__4.上传其他分支到github__\n```git\ngit push origin x:x\n```\n提交分支x到远程仓库origin的x分支\n\n```git\ngit checkout x\ngit push -u origin x\n```\n先切换到x分支，然后在x分支推送到远程仓库\n\n__5.下载远程仓库的代码__\n\n```git\ngit clone git@?/xxx.git  //会在当前目录创建一个xxx目录\ngit clone git@?/xxx.git yyy  ///会在本地新建yyy目录\ngit clone git@?/xxx.git . //不会新建目录，会在当前目录来装代码和.git\n```\n第三种方法最后当前目录是一个空目录，不然容易覆盖之前的.git，很危险。\n\n__6.git通灵术__\n```git\ngit stash 文件  //把某个文件临时藏起来\ngit stash pop 文件  //把某个文件释放出来\n```\n\n资料参考:饥人谷\n \n","source":"_posts/git的基本操作和Github.md","raw":"---\ntitle: git的基本操作和Github\ndate: 2020-09-21 07:20:43\ntags: 'git'\ntoc : true\n---\n# git的基本操作\n__配置本地的git__\n```git\ngit config --global user.name你的英文名\ngit config --global user.emai1你的邮箱\ngit config --globa1 push default simple\ngit config --global core. quotepath false\ngit config --global coreeditor code --wait\ngit config --globa1 core. autocrif input\n```\n<!--more-->\n__1.初始化本地仓库__\n```git\ngit init\n```\n操作完以后，本地会多出一个.git的目录，里面会记录各个版本的变化，如下图所示。\n![](./img/1.png)\n__2.把需要变动的内容提交到暂存区__\n```git\ngit add 路径  //提交某个路径下的文件\ngit add .     //把当前目录的所有文件提交到暂存区\n```\n__3.描述哪些文件不提交__\n```git\ntouch .gitignore\nvi .gitignore \n```\n.gitignore文件是描述哪些文件不会被提交到暂存区。把不需要提交的文件名写到.gitignore里面，就不会被提交。\n\n__4.把暂存区的文件提交到.git目录__\n```git\ngit commit -m 字符串 //提交并说明理由，字符串里面如果有空格，就要用引号包起来\ngit commit -v //会弹出对话框，告诉你这次提交变更了什么\n```\n__5.查看git的版本号__\n```git\ngit log 查看当前版本号之前历史版本\ngit reflog 查看所有git的历史版本\n```\n__6.回到之前的版本__\n```git\ngit reset --head xxxxxx\n```\n以上的xxxxxx代表版本号，可以通过git log 和 git reflog 来查看，需要回退的版本。\n\n__7.创建分支__\n```git\ngit branch xxx\n```\n创建一个分支，并命名为xxx\n\n__8.删除分支__\n```git\ngit branch -d xxx\n```\n删除分支xxx\n\n__9.切换分支__\n```git\ngit checkout xxx\n```\n切换分支到xxx ，默认的分支名是master\n\n__10.将一个分支合并到当前分支__\n```git\ngit merge xxx\n```\n将xxx分支合并到当前分支\n\n-------\n\n# git远程仓库GitHub\n> GItHub就是用来备份本地 `.git` 而已，没有什么高科技原理。\n\n__1.生成ssh key__\n```git\nssh-keygen -t rsa -b 4096 -C 'your Email'\n```\n连续点3个回车，就可以下载到本地目录了\n\n```git\ncat ~/.ssh/id_rsa.pub\n```\n得到公钥内容，复制到Github个人设置里面就可以了\n\n__2.Github上创建一个远程仓库__\n![](./img/2.png)\ngithub个人主页创建仓库\n![](./img/3.png)\n描述仓库的名称，并且生成仓库\n\n__3.把本地目录上传到远程仓库__\n```git\ngit remote add origin git@xxxxxxx\n```\n`origin` 是远程仓库的默认名字，可以换，但是建议不要换\n`git@xxxxxx` 是远程仓库的地址\n\n```git\ngit push -u origin master\n```\n第一次推送需要写全，以后写`git push`就可以了，这段代码的意思是推送本地master分支到远程仓库origin的master分支。\n如果提示`git pull` 就`git pull`。提示`git pull`是因为本地代码与远程仓库有不同，所以`git pull`就是让本地和远程仓库保持一致。\n\n__4.上传其他分支到github__\n```git\ngit push origin x:x\n```\n提交分支x到远程仓库origin的x分支\n\n```git\ngit checkout x\ngit push -u origin x\n```\n先切换到x分支，然后在x分支推送到远程仓库\n\n__5.下载远程仓库的代码__\n\n```git\ngit clone git@?/xxx.git  //会在当前目录创建一个xxx目录\ngit clone git@?/xxx.git yyy  ///会在本地新建yyy目录\ngit clone git@?/xxx.git . //不会新建目录，会在当前目录来装代码和.git\n```\n第三种方法最后当前目录是一个空目录，不然容易覆盖之前的.git，很危险。\n\n__6.git通灵术__\n```git\ngit stash 文件  //把某个文件临时藏起来\ngit stash pop 文件  //把某个文件释放出来\n```\n\n资料参考:饥人谷\n \n","slug":"git的基本操作和Github","published":1,"updated":"2020-09-22T02:50:51.083Z","_id":"ckfc7es4u0000b8fqhom1azv7","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"git的基本操作\"><a href=\"#git的基本操作\" class=\"headerlink\" title=\"git的基本操作\"></a>git的基本操作</h1><p><strong>配置本地的git</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name你的英文名</span><br><span class=\"line\">git config --global user.emai1你的邮箱</span><br><span class=\"line\">git config --globa1 push default simple</span><br><span class=\"line\">git config --global core. quotepath false</span><br><span class=\"line\">git config --global coreeditor code --wait</span><br><span class=\"line\">git config --globa1 core. autocrif input</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p><strong>1.初始化本地仓库</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n<p>操作完以后，本地会多出一个.git的目录，里面会记录各个版本的变化，如下图所示。<br><img src=\"./img/1.png\"><br><strong>2.把需要变动的内容提交到暂存区</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add 路径  &#x2F;&#x2F;提交某个路径下的文件</span><br><span class=\"line\">git add .     &#x2F;&#x2F;把当前目录的所有文件提交到暂存区</span><br></pre></td></tr></table></figure>\n<p><strong>3.描述哪些文件不提交</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch .gitignore</span><br><span class=\"line\">vi .gitignore </span><br></pre></td></tr></table></figure>\n<p>.gitignore文件是描述哪些文件不会被提交到暂存区。把不需要提交的文件名写到.gitignore里面，就不会被提交。</p>\n<p><strong>4.把暂存区的文件提交到.git目录</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m 字符串 &#x2F;&#x2F;提交并说明理由，字符串里面如果有空格，就要用引号包起来</span><br><span class=\"line\">git commit -v &#x2F;&#x2F;会弹出对话框，告诉你这次提交变更了什么</span><br></pre></td></tr></table></figure>\n<p><strong>5.查看git的版本号</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log 查看当前版本号之前历史版本</span><br><span class=\"line\">git reflog 查看所有git的历史版本</span><br></pre></td></tr></table></figure>\n<p><strong>6.回到之前的版本</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --head xxxxxx</span><br></pre></td></tr></table></figure>\n<p>以上的xxxxxx代表版本号，可以通过git log 和 git reflog 来查看，需要回退的版本。</p>\n<p><strong>7.创建分支</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch xxx</span><br></pre></td></tr></table></figure>\n<p>创建一个分支，并命名为xxx</p>\n<p><strong>8.删除分支</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d xxx</span><br></pre></td></tr></table></figure>\n<p>删除分支xxx</p>\n<p><strong>9.切换分支</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout xxx</span><br></pre></td></tr></table></figure>\n<p>切换分支到xxx ，默认的分支名是master</p>\n<p><strong>10.将一个分支合并到当前分支</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge xxx</span><br></pre></td></tr></table></figure>\n<p>将xxx分支合并到当前分支</p>\n<hr>\n<h1 id=\"git远程仓库GitHub\"><a href=\"#git远程仓库GitHub\" class=\"headerlink\" title=\"git远程仓库GitHub\"></a>git远程仓库GitHub</h1><blockquote>\n<p>GItHub就是用来备份本地 <code>.git</code> 而已，没有什么高科技原理。</p>\n</blockquote>\n<p><strong>1.生成ssh key</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -b 4096 -C &#39;your Email&#39;</span><br></pre></td></tr></table></figure>\n<p>连续点3个回车，就可以下载到本地目录了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure>\n<p>得到公钥内容，复制到Github个人设置里面就可以了</p>\n<p><strong>2.Github上创建一个远程仓库</strong><br><img src=\"./img/2.png\"><br>github个人主页创建仓库<br><img src=\"./img/3.png\"><br>描述仓库的名称，并且生成仓库</p>\n<p><strong>3.把本地目录上传到远程仓库</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin git@xxxxxxx</span><br></pre></td></tr></table></figure>\n<p><code>origin</code> 是远程仓库的默认名字，可以换，但是建议不要换<br><code>git@xxxxxx</code> 是远程仓库的地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n<p>第一次推送需要写全，以后写<code>git push</code>就可以了，这段代码的意思是推送本地master分支到远程仓库origin的master分支。<br>如果提示<code>git pull</code> 就<code>git pull</code>。提示<code>git pull</code>是因为本地代码与远程仓库有不同，所以<code>git pull</code>就是让本地和远程仓库保持一致。</p>\n<p><strong>4.上传其他分支到github</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin x:x</span><br></pre></td></tr></table></figure>\n<p>提交分支x到远程仓库origin的x分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout x</span><br><span class=\"line\">git push -u origin x</span><br></pre></td></tr></table></figure>\n<p>先切换到x分支，然后在x分支推送到远程仓库</p>\n<p><strong>5.下载远程仓库的代码</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@?&#x2F;xxx.git  &#x2F;&#x2F;会在当前目录创建一个xxx目录</span><br><span class=\"line\">git clone git@?&#x2F;xxx.git yyy  &#x2F;&#x2F;&#x2F;会在本地新建yyy目录</span><br><span class=\"line\">git clone git@?&#x2F;xxx.git . &#x2F;&#x2F;不会新建目录，会在当前目录来装代码和.git</span><br></pre></td></tr></table></figure>\n<p>第三种方法最后当前目录是一个空目录，不然容易覆盖之前的.git，很危险。</p>\n<p><strong>6.git通灵术</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git stash 文件  &#x2F;&#x2F;把某个文件临时藏起来</span><br><span class=\"line\">git stash pop 文件  &#x2F;&#x2F;把某个文件释放出来</span><br></pre></td></tr></table></figure>\n\n<p>资料参考:饥人谷</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"git的基本操作\"><a href=\"#git的基本操作\" class=\"headerlink\" title=\"git的基本操作\"></a>git的基本操作</h1><p><strong>配置本地的git</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name你的英文名</span><br><span class=\"line\">git config --global user.emai1你的邮箱</span><br><span class=\"line\">git config --globa1 push default simple</span><br><span class=\"line\">git config --global core. quotepath false</span><br><span class=\"line\">git config --global coreeditor code --wait</span><br><span class=\"line\">git config --globa1 core. autocrif input</span><br></pre></td></tr></table></figure>","more":"<p><strong>1.初始化本地仓库</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n<p>操作完以后，本地会多出一个.git的目录，里面会记录各个版本的变化，如下图所示。<br><img src=\"./img/1.png\"><br><strong>2.把需要变动的内容提交到暂存区</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add 路径  &#x2F;&#x2F;提交某个路径下的文件</span><br><span class=\"line\">git add .     &#x2F;&#x2F;把当前目录的所有文件提交到暂存区</span><br></pre></td></tr></table></figure>\n<p><strong>3.描述哪些文件不提交</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch .gitignore</span><br><span class=\"line\">vi .gitignore </span><br></pre></td></tr></table></figure>\n<p>.gitignore文件是描述哪些文件不会被提交到暂存区。把不需要提交的文件名写到.gitignore里面，就不会被提交。</p>\n<p><strong>4.把暂存区的文件提交到.git目录</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m 字符串 &#x2F;&#x2F;提交并说明理由，字符串里面如果有空格，就要用引号包起来</span><br><span class=\"line\">git commit -v &#x2F;&#x2F;会弹出对话框，告诉你这次提交变更了什么</span><br></pre></td></tr></table></figure>\n<p><strong>5.查看git的版本号</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log 查看当前版本号之前历史版本</span><br><span class=\"line\">git reflog 查看所有git的历史版本</span><br></pre></td></tr></table></figure>\n<p><strong>6.回到之前的版本</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --head xxxxxx</span><br></pre></td></tr></table></figure>\n<p>以上的xxxxxx代表版本号，可以通过git log 和 git reflog 来查看，需要回退的版本。</p>\n<p><strong>7.创建分支</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch xxx</span><br></pre></td></tr></table></figure>\n<p>创建一个分支，并命名为xxx</p>\n<p><strong>8.删除分支</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d xxx</span><br></pre></td></tr></table></figure>\n<p>删除分支xxx</p>\n<p><strong>9.切换分支</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout xxx</span><br></pre></td></tr></table></figure>\n<p>切换分支到xxx ，默认的分支名是master</p>\n<p><strong>10.将一个分支合并到当前分支</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge xxx</span><br></pre></td></tr></table></figure>\n<p>将xxx分支合并到当前分支</p>\n<hr>\n<h1 id=\"git远程仓库GitHub\"><a href=\"#git远程仓库GitHub\" class=\"headerlink\" title=\"git远程仓库GitHub\"></a>git远程仓库GitHub</h1><blockquote>\n<p>GItHub就是用来备份本地 <code>.git</code> 而已，没有什么高科技原理。</p>\n</blockquote>\n<p><strong>1.生成ssh key</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -b 4096 -C &#39;your Email&#39;</span><br></pre></td></tr></table></figure>\n<p>连续点3个回车，就可以下载到本地目录了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure>\n<p>得到公钥内容，复制到Github个人设置里面就可以了</p>\n<p><strong>2.Github上创建一个远程仓库</strong><br><img src=\"./img/2.png\"><br>github个人主页创建仓库<br><img src=\"./img/3.png\"><br>描述仓库的名称，并且生成仓库</p>\n<p><strong>3.把本地目录上传到远程仓库</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin git@xxxxxxx</span><br></pre></td></tr></table></figure>\n<p><code>origin</code> 是远程仓库的默认名字，可以换，但是建议不要换<br><code>git@xxxxxx</code> 是远程仓库的地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n<p>第一次推送需要写全，以后写<code>git push</code>就可以了，这段代码的意思是推送本地master分支到远程仓库origin的master分支。<br>如果提示<code>git pull</code> 就<code>git pull</code>。提示<code>git pull</code>是因为本地代码与远程仓库有不同，所以<code>git pull</code>就是让本地和远程仓库保持一致。</p>\n<p><strong>4.上传其他分支到github</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin x:x</span><br></pre></td></tr></table></figure>\n<p>提交分支x到远程仓库origin的x分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout x</span><br><span class=\"line\">git push -u origin x</span><br></pre></td></tr></table></figure>\n<p>先切换到x分支，然后在x分支推送到远程仓库</p>\n<p><strong>5.下载远程仓库的代码</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@?&#x2F;xxx.git  &#x2F;&#x2F;会在当前目录创建一个xxx目录</span><br><span class=\"line\">git clone git@?&#x2F;xxx.git yyy  &#x2F;&#x2F;&#x2F;会在本地新建yyy目录</span><br><span class=\"line\">git clone git@?&#x2F;xxx.git . &#x2F;&#x2F;不会新建目录，会在当前目录来装代码和.git</span><br></pre></td></tr></table></figure>\n<p>第三种方法最后当前目录是一个空目录，不然容易覆盖之前的.git，很危险。</p>\n<p><strong>6.git通灵术</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git stash 文件  &#x2F;&#x2F;把某个文件临时藏起来</span><br><span class=\"line\">git stash pop 文件  &#x2F;&#x2F;把某个文件释放出来</span><br></pre></td></tr></table></figure>\n\n<p>资料参考:饥人谷</p>"},{"title":"HTML的历史和学习方法","date":"2020-09-21T16:39:31.000Z","_content":"# __HTML历史__\n__WWW = URL + HTTP + HTML__\nWWW 就是万维网 World Wide Web 中文直翻就是「像世界一样大的网」\n`URL` 就是一个网址\n`HTTP` 一种传输的协议\n`HTML` 超文本编辑语言，这里可以理解成网页\n以上三样东西组成了WWW万维网\n<!--more-->\n> 万维网和互联网是有区别的,互联网出现在万维网之前，互联网就是ip和ip是可以互联的，可以就行数据互通，比如可以发送邮件和文件。而万维网是我知道ip，在浏览器输入ip就可以打开我要看到网页，可以说万维网是基于互联网发明出来的。\n\n<div align=center><img src = \"./img/1.png\" width = \"80%\"></div>\n\n# __HTML的学习方法__\n__HTML全称HtyperText Markup Language 超文本编辑语言__\n狭义的HTML5指，新增的100多个标签及功能\n广义的HTML5指，HTML5和它的朋友们（包括CSS3等）\n\n# __体系化学习__\n1.学习一门语言必须学会什么\n* 语法（代码怎么写）\n* 如何调试（怎么知道自己的代码写错了）\n* 在哪里查资料（其实就是为了抄代码）推荐MDN\n* 标准制定者是谁 HTML的标准制定者是W3C\n\n2.如何学(CRM学习法)\n* Copy 抄代码，抄老师\n* Run 放在自己的机器上运行成功\n* Modify 加一点自己的想法，然后重新运行成\n\n\n资料来源：饥人谷\n\n","source":"_posts/HTML的历史和学习方法.md","raw":"---\ntitle: HTML的历史和学习方法\ndate: 2020-09-21 16:39:31\ntags: HTML\n---\n# __HTML历史__\n__WWW = URL + HTTP + HTML__\nWWW 就是万维网 World Wide Web 中文直翻就是「像世界一样大的网」\n`URL` 就是一个网址\n`HTTP` 一种传输的协议\n`HTML` 超文本编辑语言，这里可以理解成网页\n以上三样东西组成了WWW万维网\n<!--more-->\n> 万维网和互联网是有区别的,互联网出现在万维网之前，互联网就是ip和ip是可以互联的，可以就行数据互通，比如可以发送邮件和文件。而万维网是我知道ip，在浏览器输入ip就可以打开我要看到网页，可以说万维网是基于互联网发明出来的。\n\n<div align=center><img src = \"./img/1.png\" width = \"80%\"></div>\n\n# __HTML的学习方法__\n__HTML全称HtyperText Markup Language 超文本编辑语言__\n狭义的HTML5指，新增的100多个标签及功能\n广义的HTML5指，HTML5和它的朋友们（包括CSS3等）\n\n# __体系化学习__\n1.学习一门语言必须学会什么\n* 语法（代码怎么写）\n* 如何调试（怎么知道自己的代码写错了）\n* 在哪里查资料（其实就是为了抄代码）推荐MDN\n* 标准制定者是谁 HTML的标准制定者是W3C\n\n2.如何学(CRM学习法)\n* Copy 抄代码，抄老师\n* Run 放在自己的机器上运行成功\n* Modify 加一点自己的想法，然后重新运行成\n\n\n资料来源：饥人谷\n\n","slug":"HTML的历史和学习方法","published":1,"updated":"2020-09-21T17:19:41.652Z","_id":"ckfcri0au0000dsfqflgnfhsq","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"HTML历史\"><a href=\"#HTML历史\" class=\"headerlink\" title=\"HTML历史\"></a><strong>HTML历史</strong></h1><p><strong>WWW = URL + HTTP + HTML</strong><br>WWW 就是万维网 World Wide Web 中文直翻就是「像世界一样大的网」<br><code>URL</code> 就是一个网址<br><code>HTTP</code> 一种传输的协议<br><code>HTML</code> 超文本编辑语言，这里可以理解成网页<br>以上三样东西组成了WWW万维网</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>万维网和互联网是有区别的,互联网出现在万维网之前，互联网就是ip和ip是可以互联的，可以就行数据互通，比如可以发送邮件和文件。而万维网是我知道ip，在浏览器输入ip就可以打开我要看到网页，可以说万维网是基于互联网发明出来的。</p>\n</blockquote>\n<div align=center><img src = \"./img/1.png\" width = \"80%\"></div>\n\n<h1 id=\"HTML的学习方法\"><a href=\"#HTML的学习方法\" class=\"headerlink\" title=\"HTML的学习方法\"></a><strong>HTML的学习方法</strong></h1><p><strong>HTML全称HtyperText Markup Language 超文本编辑语言</strong><br>狭义的HTML5指，新增的100多个标签及功能<br>广义的HTML5指，HTML5和它的朋友们（包括CSS3等）</p>\n<h1 id=\"体系化学习\"><a href=\"#体系化学习\" class=\"headerlink\" title=\"体系化学习\"></a><strong>体系化学习</strong></h1><p>1.学习一门语言必须学会什么</p>\n<ul>\n<li>语法（代码怎么写）</li>\n<li>如何调试（怎么知道自己的代码写错了）</li>\n<li>在哪里查资料（其实就是为了抄代码）推荐MDN</li>\n<li>标准制定者是谁 HTML的标准制定者是W3C</li>\n</ul>\n<p>2.如何学(CRM学习法)</p>\n<ul>\n<li>Copy 抄代码，抄老师</li>\n<li>Run 放在自己的机器上运行成功</li>\n<li>Modify 加一点自己的想法，然后重新运行成</li>\n</ul>\n<p>资料来源：饥人谷</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"HTML历史\"><a href=\"#HTML历史\" class=\"headerlink\" title=\"HTML历史\"></a><strong>HTML历史</strong></h1><p><strong>WWW = URL + HTTP + HTML</strong><br>WWW 就是万维网 World Wide Web 中文直翻就是「像世界一样大的网」<br><code>URL</code> 就是一个网址<br><code>HTTP</code> 一种传输的协议<br><code>HTML</code> 超文本编辑语言，这里可以理解成网页<br>以上三样东西组成了WWW万维网</p>","more":"<blockquote>\n<p>万维网和互联网是有区别的,互联网出现在万维网之前，互联网就是ip和ip是可以互联的，可以就行数据互通，比如可以发送邮件和文件。而万维网是我知道ip，在浏览器输入ip就可以打开我要看到网页，可以说万维网是基于互联网发明出来的。</p>\n</blockquote>\n<div align=center><img src = \"./img/1.png\" width = \"80%\"></div>\n\n<h1 id=\"HTML的学习方法\"><a href=\"#HTML的学习方法\" class=\"headerlink\" title=\"HTML的学习方法\"></a><strong>HTML的学习方法</strong></h1><p><strong>HTML全称HtyperText Markup Language 超文本编辑语言</strong><br>狭义的HTML5指，新增的100多个标签及功能<br>广义的HTML5指，HTML5和它的朋友们（包括CSS3等）</p>\n<h1 id=\"体系化学习\"><a href=\"#体系化学习\" class=\"headerlink\" title=\"体系化学习\"></a><strong>体系化学习</strong></h1><p>1.学习一门语言必须学会什么</p>\n<ul>\n<li>语法（代码怎么写）</li>\n<li>如何调试（怎么知道自己的代码写错了）</li>\n<li>在哪里查资料（其实就是为了抄代码）推荐MDN</li>\n<li>标准制定者是谁 HTML的标准制定者是W3C</li>\n</ul>\n<p>2.如何学(CRM学习法)</p>\n<ul>\n<li>Copy 抄代码，抄老师</li>\n<li>Run 放在自己的机器上运行成功</li>\n<li>Modify 加一点自己的想法，然后重新运行成</li>\n</ul>\n<p>资料来源：饥人谷</p>"},{"title":"Markdown的一些语法","date":"2020-09-21T17:27:31.000Z","cover":"./img/markdown.jpg","toc":true,"_content":"\n* __字体加粗__\n```markdown\n__内容__\n```\n<!--more-->\n* __插入入图片__\n```markdown\n![图片的描述](图片的地址)\n```\n这样插入的图片，无法控制大小，和位置（默认都是靠左）\n\n\n* __插入控制大小和位置的图片__\n```html\n<div align=\"center\"><img src = \"图片地址\" width = 50%></div>\n```\nmarkdown里面居然还可以写HTML，惊了...\n\n* __给文字加入超链接__\n```markdown\n[文字]( url )\n```\n* __表格__\n```markdown\n|标题1|标题2|标题3|标题4|\n|----|----|----|----|\n|内容1|内容2|内容3|内容4|\n```\n* __文字字体颜色大小__\n```markdown\n<font color=\"red\" face=\"微软雅黑\" size=7>我是字体</font>\n```\n\n","source":"_posts/Markdown的一些语法.md","raw":"---\ntitle: Markdown的一些语法\ndate: 2020-09-21 17:27:31\ncover: ./img/markdown.jpg\ntags: markdown\ntoc: true\n---\n\n* __字体加粗__\n```markdown\n__内容__\n```\n<!--more-->\n* __插入入图片__\n```markdown\n![图片的描述](图片的地址)\n```\n这样插入的图片，无法控制大小，和位置（默认都是靠左）\n\n\n* __插入控制大小和位置的图片__\n```html\n<div align=\"center\"><img src = \"图片地址\" width = 50%></div>\n```\nmarkdown里面居然还可以写HTML，惊了...\n\n* __给文字加入超链接__\n```markdown\n[文字]( url )\n```\n* __表格__\n```markdown\n|标题1|标题2|标题3|标题4|\n|----|----|----|----|\n|内容1|内容2|内容3|内容4|\n```\n* __文字字体颜色大小__\n```markdown\n<font color=\"red\" face=\"微软雅黑\" size=7>我是字体</font>\n```\n\n","slug":"Markdown的一些语法","published":1,"updated":"2020-09-24T11:03:30.139Z","_id":"ckfct8ks5000009fq7x1u683h","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li><strong>字体加粗</strong><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"strong\">__内容__</span></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a></li>\n<li><strong>插入入图片</strong><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![<span class=\"string\">图片的描述</span>](<span class=\"link\">图片的地址</span>)</span><br></pre></td></tr></table></figure>\n这样插入的图片，无法控制大小，和位置（默认都是靠左）</li>\n</ul>\n<ul>\n<li><p><strong>插入控制大小和位置的图片</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">align</span>=<span class=\"string\">&quot;center&quot;</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span> = <span class=\"string\">&quot;图片地址&quot;</span> <span class=\"attr\">width</span> = <span class=\"string\">50%</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>markdown里面居然还可以写HTML，惊了…</p>\n</li>\n<li><p><strong>给文字加入超链接</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">文字</span>](<span class=\"link\"> url </span>)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>表格</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|标题1|标题2|标题3|标题4|</span><br><span class=\"line\">|----|----|----|----|</span><br><span class=\"line\">|内容1|内容2|内容3|内容4|</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>文字字体颜色大小</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">font</span> <span class=\"attr\">color</span>=<span class=\"string\">&quot;red&quot;</span> <span class=\"attr\">face</span>=<span class=\"string\">&quot;微软雅黑&quot;</span> <span class=\"attr\">size</span>=<span class=\"string\">7</span>&gt;</span></span>我是字体<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">font</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li><strong>字体加粗</strong><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"strong\">__内容__</span></span><br></pre></td></tr></table></figure>","more":"</li>\n<li><strong>插入入图片</strong><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![<span class=\"string\">图片的描述</span>](<span class=\"link\">图片的地址</span>)</span><br></pre></td></tr></table></figure>\n这样插入的图片，无法控制大小，和位置（默认都是靠左）</li>\n</ul>\n<ul>\n<li><p><strong>插入控制大小和位置的图片</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">align</span>=<span class=\"string\">&quot;center&quot;</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span> = <span class=\"string\">&quot;图片地址&quot;</span> <span class=\"attr\">width</span> = <span class=\"string\">50%</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>markdown里面居然还可以写HTML，惊了…</p>\n</li>\n<li><p><strong>给文字加入超链接</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">文字</span>](<span class=\"link\"> url </span>)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>表格</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|标题1|标题2|标题3|标题4|</span><br><span class=\"line\">|----|----|----|----|</span><br><span class=\"line\">|内容1|内容2|内容3|内容4|</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>文字字体颜色大小</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">font</span> <span class=\"attr\">color</span>=<span class=\"string\">&quot;red&quot;</span> <span class=\"attr\">face</span>=<span class=\"string\">&quot;微软雅黑&quot;</span> <span class=\"attr\">size</span>=<span class=\"string\">7</span>&gt;</span></span>我是字体<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">font</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>"},{"title":"HTML标签","date":"2020-09-22T17:12:59.000Z","toc":true,"_content":"## __英语小课堂__\n\n|英文|翻译|英文|翻译|\n|----|----|----|----|\n|heading|标题|body|身体，正文|\n|paragraph|段落|section|章节|\n|article|一篇文章|main|主要|\n|aside|旁边的|anchor|锚点，定点|\n|strong|强壮，重要|emphasis|强调|\n|order|顺序|ordered|有顺序的|\n|unordered|无顺序的|description|描述|\n|term|术语|data|数据|\n|quote|引用|block|块|\n|inline|行内，内联|break|打断|\n<!--more-->\n\n推荐书籍《[网道HTML教程](https://wangdoc.com/html/)》阮一峰的网络文档。\n推荐工具 [JSbin](https://jsbin.com/?html,output) [代码沙盒](https://codesandbox.io/) 测速代码的时候可以用。\n\n## __HTML起手式__\n```HTML\n<!DOCTYPE html>  //文档类型\n<html lang=\"zh-CN\"> //html标签\n<head>\n    <meta charset=\"UTF-8\"> 》//文件的字符编码\n    <meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">  //防止页面缩放\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"/>  //告诉IE用最新的内核渲染页面\n    <title>Document</title>  //网页的标题\n</head>\n<body>\n    <div class=\"\"></div>\n</body>\n</html>\n```\n\n## __章节标签__\n\n标题 `h1~h6`\n章节 `section`\n文章 `article`\n段落 `p`\n头部 `header`\n脚部 `footer`\n主要内容 `main`\n划分 `div`\n其实我觉得html标签就是根据标签的语义，在网页合理使用。让网页看上去是有结构的。\n\n## __全局属性(所有标签都有的属性)__\n`class` 类\n`contenteditable` 可以让该标签内的内容可以被编辑\n`hidden` 让一个东西看不到\n`id` \n`style` 样式\n`tabindex` 用「Tab」键可以在页面里面切换\n`title`鼠标浮动到元素上，可以显示title的内容\n\n## __内容标签__\n`ol + li` 有序列表\n`ul + li` 无序列表\n`dl + dt + dd ` 描述列表\ndl = description list 描述列\ndt = description term 描述的术语\ndd = description data 描述的数据\n\n`pre`  在pre里面的段落，可以保留标签内的格式\n`code` 里面可以写代码\n`hr` 分割线\n`a` 超链接标签\n`em` 强调 语气\n`strong` 强调 本质\n`quote` 引用标签 属于内联标签\n`blockquote` 引用标签 属于块级标签\n\n\n资料参考：饥人谷\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/HTML标签.md","raw":"---\ntitle: HTML标签\ndate: 2020-09-22 17:12:59\ntags: HTML\ntoc : true\n---\n## __英语小课堂__\n\n|英文|翻译|英文|翻译|\n|----|----|----|----|\n|heading|标题|body|身体，正文|\n|paragraph|段落|section|章节|\n|article|一篇文章|main|主要|\n|aside|旁边的|anchor|锚点，定点|\n|strong|强壮，重要|emphasis|强调|\n|order|顺序|ordered|有顺序的|\n|unordered|无顺序的|description|描述|\n|term|术语|data|数据|\n|quote|引用|block|块|\n|inline|行内，内联|break|打断|\n<!--more-->\n\n推荐书籍《[网道HTML教程](https://wangdoc.com/html/)》阮一峰的网络文档。\n推荐工具 [JSbin](https://jsbin.com/?html,output) [代码沙盒](https://codesandbox.io/) 测速代码的时候可以用。\n\n## __HTML起手式__\n```HTML\n<!DOCTYPE html>  //文档类型\n<html lang=\"zh-CN\"> //html标签\n<head>\n    <meta charset=\"UTF-8\"> 》//文件的字符编码\n    <meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">  //防止页面缩放\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"/>  //告诉IE用最新的内核渲染页面\n    <title>Document</title>  //网页的标题\n</head>\n<body>\n    <div class=\"\"></div>\n</body>\n</html>\n```\n\n## __章节标签__\n\n标题 `h1~h6`\n章节 `section`\n文章 `article`\n段落 `p`\n头部 `header`\n脚部 `footer`\n主要内容 `main`\n划分 `div`\n其实我觉得html标签就是根据标签的语义，在网页合理使用。让网页看上去是有结构的。\n\n## __全局属性(所有标签都有的属性)__\n`class` 类\n`contenteditable` 可以让该标签内的内容可以被编辑\n`hidden` 让一个东西看不到\n`id` \n`style` 样式\n`tabindex` 用「Tab」键可以在页面里面切换\n`title`鼠标浮动到元素上，可以显示title的内容\n\n## __内容标签__\n`ol + li` 有序列表\n`ul + li` 无序列表\n`dl + dt + dd ` 描述列表\ndl = description list 描述列\ndt = description term 描述的术语\ndd = description data 描述的数据\n\n`pre`  在pre里面的段落，可以保留标签内的格式\n`code` 里面可以写代码\n`hr` 分割线\n`a` 超链接标签\n`em` 强调 语气\n`strong` 强调 本质\n`quote` 引用标签 属于内联标签\n`blockquote` 引用标签 属于块级标签\n\n\n资料参考：饥人谷\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"HTML标签","published":1,"updated":"2020-09-24T15:30:49.075Z","_id":"ckfe81by60000zvfqdnm557m2","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"英语小课堂\"><a href=\"#英语小课堂\" class=\"headerlink\" title=\"英语小课堂\"></a><strong>英语小课堂</strong></h2><table>\n<thead>\n<tr>\n<th>英文</th>\n<th>翻译</th>\n<th>英文</th>\n<th>翻译</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>heading</td>\n<td>标题</td>\n<td>body</td>\n<td>身体，正文</td>\n</tr>\n<tr>\n<td>paragraph</td>\n<td>段落</td>\n<td>section</td>\n<td>章节</td>\n</tr>\n<tr>\n<td>article</td>\n<td>一篇文章</td>\n<td>main</td>\n<td>主要</td>\n</tr>\n<tr>\n<td>aside</td>\n<td>旁边的</td>\n<td>anchor</td>\n<td>锚点，定点</td>\n</tr>\n<tr>\n<td>strong</td>\n<td>强壮，重要</td>\n<td>emphasis</td>\n<td>强调</td>\n</tr>\n<tr>\n<td>order</td>\n<td>顺序</td>\n<td>ordered</td>\n<td>有顺序的</td>\n</tr>\n<tr>\n<td>unordered</td>\n<td>无顺序的</td>\n<td>description</td>\n<td>描述</td>\n</tr>\n<tr>\n<td>term</td>\n<td>术语</td>\n<td>data</td>\n<td>数据</td>\n</tr>\n<tr>\n<td>quote</td>\n<td>引用</td>\n<td>block</td>\n<td>块</td>\n</tr>\n<tr>\n<td>inline</td>\n<td>行内，内联</td>\n<td>break</td>\n<td>打断</td>\n</tr>\n</tbody></table>\n<a id=\"more\"></a>\n\n<p>推荐书籍《<a href=\"https://wangdoc.com/html/\">网道HTML教程</a>》阮一峰的网络文档。<br>推荐工具 <a href=\"https://jsbin.com/?html,output\">JSbin</a> <a href=\"https://codesandbox.io/\">代码沙盒</a> 测速代码的时候可以用。</p>\n<h2 id=\"HTML起手式\"><a href=\"#HTML起手式\" class=\"headerlink\" title=\"HTML起手式\"></a><strong>HTML起手式</strong></h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span>  //文档类型</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;zh-CN&quot;</span>&gt;</span> //html标签</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span> 》//文件的字符编码</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span>  //防止页面缩放</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;X-UA-Compatible&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;ie=edge&quot;</span>/&gt;</span>  //告诉IE用最新的内核渲染页面</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span>  //网页的标题</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"章节标签\"><a href=\"#章节标签\" class=\"headerlink\" title=\"章节标签\"></a><strong>章节标签</strong></h2><p>标题 <code>h1~h6</code><br>章节 <code>section</code><br>文章 <code>article</code><br>段落 <code>p</code><br>头部 <code>header</code><br>脚部 <code>footer</code><br>主要内容 <code>main</code><br>划分 <code>div</code><br>其实我觉得html标签就是根据标签的语义，在网页合理使用。让网页看上去是有结构的。</p>\n<h2 id=\"全局属性-所有标签都有的属性\"><a href=\"#全局属性-所有标签都有的属性\" class=\"headerlink\" title=\"全局属性(所有标签都有的属性)\"></a><strong>全局属性(所有标签都有的属性)</strong></h2><p><code>class</code> 类<br><code>contenteditable</code> 可以让该标签内的内容可以被编辑<br><code>hidden</code> 让一个东西看不到<br><code>id</code><br><code>style</code> 样式<br><code>tabindex</code> 用「Tab」键可以在页面里面切换<br><code>title</code>鼠标浮动到元素上，可以显示title的内容</p>\n<h2 id=\"内容标签\"><a href=\"#内容标签\" class=\"headerlink\" title=\"内容标签\"></a><strong>内容标签</strong></h2><p><code>ol + li</code> 有序列表<br><code>ul + li</code> 无序列表<br><code>dl + dt + dd </code> 描述列表<br>dl = description list 描述列<br>dt = description term 描述的术语<br>dd = description data 描述的数据</p>\n<p><code>pre</code>  在pre里面的段落，可以保留标签内的格式<br><code>code</code> 里面可以写代码<br><code>hr</code> 分割线<br><code>a</code> 超链接标签<br><code>em</code> 强调 语气<br><code>strong</code> 强调 本质<br><code>quote</code> 引用标签 属于内联标签<br><code>blockquote</code> 引用标签 属于块级标签</p>\n<p>资料参考：饥人谷</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"英语小课堂\"><a href=\"#英语小课堂\" class=\"headerlink\" title=\"英语小课堂\"></a><strong>英语小课堂</strong></h2><table>\n<thead>\n<tr>\n<th>英文</th>\n<th>翻译</th>\n<th>英文</th>\n<th>翻译</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>heading</td>\n<td>标题</td>\n<td>body</td>\n<td>身体，正文</td>\n</tr>\n<tr>\n<td>paragraph</td>\n<td>段落</td>\n<td>section</td>\n<td>章节</td>\n</tr>\n<tr>\n<td>article</td>\n<td>一篇文章</td>\n<td>main</td>\n<td>主要</td>\n</tr>\n<tr>\n<td>aside</td>\n<td>旁边的</td>\n<td>anchor</td>\n<td>锚点，定点</td>\n</tr>\n<tr>\n<td>strong</td>\n<td>强壮，重要</td>\n<td>emphasis</td>\n<td>强调</td>\n</tr>\n<tr>\n<td>order</td>\n<td>顺序</td>\n<td>ordered</td>\n<td>有顺序的</td>\n</tr>\n<tr>\n<td>unordered</td>\n<td>无顺序的</td>\n<td>description</td>\n<td>描述</td>\n</tr>\n<tr>\n<td>term</td>\n<td>术语</td>\n<td>data</td>\n<td>数据</td>\n</tr>\n<tr>\n<td>quote</td>\n<td>引用</td>\n<td>block</td>\n<td>块</td>\n</tr>\n<tr>\n<td>inline</td>\n<td>行内，内联</td>\n<td>break</td>\n<td>打断</td>\n</tr>\n</tbody></table>","more":"<p>推荐书籍《<a href=\"https://wangdoc.com/html/\">网道HTML教程</a>》阮一峰的网络文档。<br>推荐工具 <a href=\"https://jsbin.com/?html,output\">JSbin</a> <a href=\"https://codesandbox.io/\">代码沙盒</a> 测速代码的时候可以用。</p>\n<h2 id=\"HTML起手式\"><a href=\"#HTML起手式\" class=\"headerlink\" title=\"HTML起手式\"></a><strong>HTML起手式</strong></h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span>  //文档类型</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;zh-CN&quot;</span>&gt;</span> //html标签</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span> 》//文件的字符编码</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span>  //防止页面缩放</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;X-UA-Compatible&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;ie=edge&quot;</span>/&gt;</span>  //告诉IE用最新的内核渲染页面</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span>  //网页的标题</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"章节标签\"><a href=\"#章节标签\" class=\"headerlink\" title=\"章节标签\"></a><strong>章节标签</strong></h2><p>标题 <code>h1~h6</code><br>章节 <code>section</code><br>文章 <code>article</code><br>段落 <code>p</code><br>头部 <code>header</code><br>脚部 <code>footer</code><br>主要内容 <code>main</code><br>划分 <code>div</code><br>其实我觉得html标签就是根据标签的语义，在网页合理使用。让网页看上去是有结构的。</p>\n<h2 id=\"全局属性-所有标签都有的属性\"><a href=\"#全局属性-所有标签都有的属性\" class=\"headerlink\" title=\"全局属性(所有标签都有的属性)\"></a><strong>全局属性(所有标签都有的属性)</strong></h2><p><code>class</code> 类<br><code>contenteditable</code> 可以让该标签内的内容可以被编辑<br><code>hidden</code> 让一个东西看不到<br><code>id</code><br><code>style</code> 样式<br><code>tabindex</code> 用「Tab」键可以在页面里面切换<br><code>title</code>鼠标浮动到元素上，可以显示title的内容</p>\n<h2 id=\"内容标签\"><a href=\"#内容标签\" class=\"headerlink\" title=\"内容标签\"></a><strong>内容标签</strong></h2><p><code>ol + li</code> 有序列表<br><code>ul + li</code> 无序列表<br><code>dl + dt + dd </code> 描述列表<br>dl = description list 描述列<br>dt = description term 描述的术语<br>dd = description data 描述的数据</p>\n<p><code>pre</code>  在pre里面的段落，可以保留标签内的格式<br><code>code</code> 里面可以写代码<br><code>hr</code> 分割线<br><code>a</code> 超链接标签<br><code>em</code> 强调 语气<br><code>strong</code> 强调 本质<br><code>quote</code> 引用标签 属于内联标签<br><code>blockquote</code> 引用标签 属于块级标签</p>\n<p>资料参考：饥人谷</p>"},{"title":"HTML重点标签","date":"2020-09-24T08:36:25.000Z","toc":true,"_content":"## __英语小课堂__\n\n|英文|翻译|英文|翻译|英文|翻译|\n|----|----|----|----|----|----|\n|hyper|超级|target|目标|refer+ence|引用|\n|frame|边框|erroe|错误|blank|空白|\n|parent|父母之一|self|自己|load|加载|\n|canvas|画布|\n<!--more-->\n\n## __前端开发打开HTML文件的正确姿势__\n\n1 http-server -c-1 //-c缓存 缓存等于-1 就是不要缓存\n2 parcel xxxx.html\n\n## __a标签__\n\n* 作用：跳转到一个页面，跳转内部锚点，发邮件打电话\n* 常用属性\n\n1 __herf__\n  * 网址\n  * 路径\n  * 文件名 \n    配合download使用，这样a标签就变成了一个下载按钮，可以下载该文件。\n  * 伪协议: javascript:; mailto:邮箱 tel:电话号码 \n    javasctipt:; 里面如果写js代码，就可以执行js命令，如果什么都不写，就会变成一个点击以后没有任何动作的a标签。\n  * id\n    href=\"#xxx\" 可以跳转到本页面，id为xxx的元素上。\n\n2 __target__\n\n  * `_blank` 在空白的页面上打开。\n  * `_self` 在当前页面打开，是默认值\n  * `_top` 配合`ifram`e理解,当一个页面里面，有一个iframe，iframe里面的a标签，target是`_top`的话，就在<font color=red>最上层</font>页面打开。 \n  * `_parent` 配合iframe理解，当一个页面里面，有一个iframe，iframe里面的a标签，target是`_paren`t的话，就在<font color=red>上一层</font>的页面打开\n  * xxx 在一个新的窗口打开并且把该页面命名为xxx，以后再新打开的窗口都会在xxx打开。利用一个窗口打开新的页面。例子：youku防止用户不看广告，所有新开的视频都在一个页面上打开。\n  * iframe 便签的name ，可以在不同的iframe打开。\n\n3 __download__ \n  * 只写`download`，就会把整个网页都下载下来。\n  * `download='xxxx'` 就是下载的文件命名为xxx\n\n## __iframe标签__\n   作用：在网页内内嵌一个窗口。（已经很少使用，只有很多古老的网站还在使用）\n\n## __table标签__\n   table里面要包含 thead tbody tfoot\n   ```html\n   <table>\n     <thead>\n       <tr>  //table raw 表格里的一行\n       \t <th>英文</th> //table head 表头\n         <th>翻译</th>\n       </tr>\n     </thead>\n     <tbody>\n\t<tr>\n\t <td>table</td> //table data 表格里的数据\n         <td>表格</td>\n\t</tr>\n     </tbody>\n     <tfoot></tfoot>\n   </table>\n   ```\n## __img标签__\n   * src=\"图片的地址也可以是相对路径\"\n   * alt=\"xxxx\" 图片下载失败的时候，提示用户alt里面的内容\n   * width，height 单独写一个，图片会自适应\n   * max-width:100% 图片会根据屏幕大小自适应\n\n## __form标签__\n  __作用__ :表示文档中的一个区域，此区域包含交互控件，用于向 Web 服务器提交信息。\n  __属性__\n  * action:xxx 请求一个页面\n  * method:get/post 控制请求是get还是post\n  * autocomplete:on/off 可以自动建议之前输入过的用户名\n  * target:xxxx 提交到那个页面，该页面更新\nform标签里面必须有一个type=submit的东西，不然form就不会提交。\n\n## __input标签__\n  * __作用__ :包含在form标签里面，以便接受来自用户的数据; 可以使用各种类型的输入数据和控件小部件\n  属性太多，具体参考[MDN input](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input)\n\n参考资料:饥人谷\n\n\n\n\n","source":"_posts/HTML重点标签.md","raw":"---\ntitle: HTML重点标签\ndate: 2020-09-24 08:36:25\ntags: HTML\ntoc: true\n---\n## __英语小课堂__\n\n|英文|翻译|英文|翻译|英文|翻译|\n|----|----|----|----|----|----|\n|hyper|超级|target|目标|refer+ence|引用|\n|frame|边框|erroe|错误|blank|空白|\n|parent|父母之一|self|自己|load|加载|\n|canvas|画布|\n<!--more-->\n\n## __前端开发打开HTML文件的正确姿势__\n\n1 http-server -c-1 //-c缓存 缓存等于-1 就是不要缓存\n2 parcel xxxx.html\n\n## __a标签__\n\n* 作用：跳转到一个页面，跳转内部锚点，发邮件打电话\n* 常用属性\n\n1 __herf__\n  * 网址\n  * 路径\n  * 文件名 \n    配合download使用，这样a标签就变成了一个下载按钮，可以下载该文件。\n  * 伪协议: javascript:; mailto:邮箱 tel:电话号码 \n    javasctipt:; 里面如果写js代码，就可以执行js命令，如果什么都不写，就会变成一个点击以后没有任何动作的a标签。\n  * id\n    href=\"#xxx\" 可以跳转到本页面，id为xxx的元素上。\n\n2 __target__\n\n  * `_blank` 在空白的页面上打开。\n  * `_self` 在当前页面打开，是默认值\n  * `_top` 配合`ifram`e理解,当一个页面里面，有一个iframe，iframe里面的a标签，target是`_top`的话，就在<font color=red>最上层</font>页面打开。 \n  * `_parent` 配合iframe理解，当一个页面里面，有一个iframe，iframe里面的a标签，target是`_paren`t的话，就在<font color=red>上一层</font>的页面打开\n  * xxx 在一个新的窗口打开并且把该页面命名为xxx，以后再新打开的窗口都会在xxx打开。利用一个窗口打开新的页面。例子：youku防止用户不看广告，所有新开的视频都在一个页面上打开。\n  * iframe 便签的name ，可以在不同的iframe打开。\n\n3 __download__ \n  * 只写`download`，就会把整个网页都下载下来。\n  * `download='xxxx'` 就是下载的文件命名为xxx\n\n## __iframe标签__\n   作用：在网页内内嵌一个窗口。（已经很少使用，只有很多古老的网站还在使用）\n\n## __table标签__\n   table里面要包含 thead tbody tfoot\n   ```html\n   <table>\n     <thead>\n       <tr>  //table raw 表格里的一行\n       \t <th>英文</th> //table head 表头\n         <th>翻译</th>\n       </tr>\n     </thead>\n     <tbody>\n\t<tr>\n\t <td>table</td> //table data 表格里的数据\n         <td>表格</td>\n\t</tr>\n     </tbody>\n     <tfoot></tfoot>\n   </table>\n   ```\n## __img标签__\n   * src=\"图片的地址也可以是相对路径\"\n   * alt=\"xxxx\" 图片下载失败的时候，提示用户alt里面的内容\n   * width，height 单独写一个，图片会自适应\n   * max-width:100% 图片会根据屏幕大小自适应\n\n## __form标签__\n  __作用__ :表示文档中的一个区域，此区域包含交互控件，用于向 Web 服务器提交信息。\n  __属性__\n  * action:xxx 请求一个页面\n  * method:get/post 控制请求是get还是post\n  * autocomplete:on/off 可以自动建议之前输入过的用户名\n  * target:xxxx 提交到那个页面，该页面更新\nform标签里面必须有一个type=submit的东西，不然form就不会提交。\n\n## __input标签__\n  * __作用__ :包含在form标签里面，以便接受来自用户的数据; 可以使用各种类型的输入数据和控件小部件\n  属性太多，具体参考[MDN input](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input)\n\n参考资料:饥人谷\n\n\n\n\n","slug":"HTML重点标签","published":1,"updated":"2020-09-24T10:59:59.487Z","_id":"ckfgkinwi000016fq84s42i8z","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"英语小课堂\"><a href=\"#英语小课堂\" class=\"headerlink\" title=\"英语小课堂\"></a><strong>英语小课堂</strong></h2><table>\n<thead>\n<tr>\n<th>英文</th>\n<th>翻译</th>\n<th>英文</th>\n<th>翻译</th>\n<th>英文</th>\n<th>翻译</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>hyper</td>\n<td>超级</td>\n<td>target</td>\n<td>目标</td>\n<td>refer+ence</td>\n<td>引用</td>\n</tr>\n<tr>\n<td>frame</td>\n<td>边框</td>\n<td>erroe</td>\n<td>错误</td>\n<td>blank</td>\n<td>空白</td>\n</tr>\n<tr>\n<td>parent</td>\n<td>父母之一</td>\n<td>self</td>\n<td>自己</td>\n<td>load</td>\n<td>加载</td>\n</tr>\n<tr>\n<td>canvas</td>\n<td>画布</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<a id=\"more\"></a>\n\n<h2 id=\"前端开发打开HTML文件的正确姿势\"><a href=\"#前端开发打开HTML文件的正确姿势\" class=\"headerlink\" title=\"前端开发打开HTML文件的正确姿势\"></a><strong>前端开发打开HTML文件的正确姿势</strong></h2><p>1 http-server -c-1 //-c缓存 缓存等于-1 就是不要缓存<br>2 parcel xxxx.html</p>\n<h2 id=\"a标签\"><a href=\"#a标签\" class=\"headerlink\" title=\"a标签\"></a><strong>a标签</strong></h2><ul>\n<li>作用：跳转到一个页面，跳转内部锚点，发邮件打电话</li>\n<li>常用属性</li>\n</ul>\n<p>1 <strong>herf</strong></p>\n<ul>\n<li>网址</li>\n<li>路径</li>\n<li>文件名<br>配合download使用，这样a标签就变成了一个下载按钮，可以下载该文件。</li>\n<li>伪协议: javascript:; mailto:邮箱 tel:电话号码<br>javasctipt:; 里面如果写js代码，就可以执行js命令，如果什么都不写，就会变成一个点击以后没有任何动作的a标签。</li>\n<li>id<br>href=”#xxx” 可以跳转到本页面，id为xxx的元素上。</li>\n</ul>\n<p>2 <strong>target</strong></p>\n<ul>\n<li><code>_blank</code> 在空白的页面上打开。</li>\n<li><code>_self</code> 在当前页面打开，是默认值</li>\n<li><code>_top</code> 配合<code>ifram</code>e理解,当一个页面里面，有一个iframe，iframe里面的a标签，target是<code>_top</code>的话，就在<font color=red>最上层</font>页面打开。 </li>\n<li><code>_parent</code> 配合iframe理解，当一个页面里面，有一个iframe，iframe里面的a标签，target是<code>_paren</code>t的话，就在<font color=red>上一层</font>的页面打开</li>\n<li>xxx 在一个新的窗口打开并且把该页面命名为xxx，以后再新打开的窗口都会在xxx打开。利用一个窗口打开新的页面。例子：youku防止用户不看广告，所有新开的视频都在一个页面上打开。</li>\n<li>iframe 便签的name ，可以在不同的iframe打开。</li>\n</ul>\n<p>3 <strong>download</strong> </p>\n<ul>\n<li>只写<code>download</code>，就会把整个网页都下载下来。</li>\n<li><code>download=&#39;xxxx&#39;</code> 就是下载的文件命名为xxx</li>\n</ul>\n<h2 id=\"iframe标签\"><a href=\"#iframe标签\" class=\"headerlink\" title=\"iframe标签\"></a><strong>iframe标签</strong></h2><p>   作用：在网页内内嵌一个窗口。（已经很少使用，只有很多古老的网站还在使用）</p>\n<h2 id=\"table标签\"><a href=\"#table标签\" class=\"headerlink\" title=\"table标签\"></a><strong>table标签</strong></h2><p>   table里面要包含 thead tbody tfoot<br>   <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">thead</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span>  //table raw 表格里的一行</span><br><span class=\"line\">      \t <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>英文<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span> //table head 表头</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>翻译<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">thead</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>table<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span> //table data 表格里的数据</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>表格<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tfoot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">tfoot</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"img标签\"><a href=\"#img标签\" class=\"headerlink\" title=\"img标签\"></a><strong>img标签</strong></h2><ul>\n<li>src=”图片的地址也可以是相对路径”</li>\n<li>alt=”xxxx” 图片下载失败的时候，提示用户alt里面的内容</li>\n<li>width，height 单独写一个，图片会自适应</li>\n<li>max-width:100% 图片会根据屏幕大小自适应</li>\n</ul>\n<h2 id=\"form标签\"><a href=\"#form标签\" class=\"headerlink\" title=\"form标签\"></a><strong>form标签</strong></h2><p>  <strong>作用</strong> :表示文档中的一个区域，此区域包含交互控件，用于向 Web 服务器提交信息。<br>  <strong>属性</strong></p>\n<ul>\n<li>action:xxx 请求一个页面</li>\n<li>method:get/post 控制请求是get还是post</li>\n<li>autocomplete:on/off 可以自动建议之前输入过的用户名</li>\n<li>target:xxxx 提交到那个页面，该页面更新<br>form标签里面必须有一个type=submit的东西，不然form就不会提交。</li>\n</ul>\n<h2 id=\"input标签\"><a href=\"#input标签\" class=\"headerlink\" title=\"input标签\"></a><strong>input标签</strong></h2><ul>\n<li><strong>作用</strong> :包含在form标签里面，以便接受来自用户的数据; 可以使用各种类型的输入数据和控件小部件<br>属性太多，具体参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input\">MDN input</a></li>\n</ul>\n<p>参考资料:饥人谷</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"英语小课堂\"><a href=\"#英语小课堂\" class=\"headerlink\" title=\"英语小课堂\"></a><strong>英语小课堂</strong></h2><table>\n<thead>\n<tr>\n<th>英文</th>\n<th>翻译</th>\n<th>英文</th>\n<th>翻译</th>\n<th>英文</th>\n<th>翻译</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>hyper</td>\n<td>超级</td>\n<td>target</td>\n<td>目标</td>\n<td>refer+ence</td>\n<td>引用</td>\n</tr>\n<tr>\n<td>frame</td>\n<td>边框</td>\n<td>erroe</td>\n<td>错误</td>\n<td>blank</td>\n<td>空白</td>\n</tr>\n<tr>\n<td>parent</td>\n<td>父母之一</td>\n<td>self</td>\n<td>自己</td>\n<td>load</td>\n<td>加载</td>\n</tr>\n<tr>\n<td>canvas</td>\n<td>画布</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>","more":"<h2 id=\"前端开发打开HTML文件的正确姿势\"><a href=\"#前端开发打开HTML文件的正确姿势\" class=\"headerlink\" title=\"前端开发打开HTML文件的正确姿势\"></a><strong>前端开发打开HTML文件的正确姿势</strong></h2><p>1 http-server -c-1 //-c缓存 缓存等于-1 就是不要缓存<br>2 parcel xxxx.html</p>\n<h2 id=\"a标签\"><a href=\"#a标签\" class=\"headerlink\" title=\"a标签\"></a><strong>a标签</strong></h2><ul>\n<li>作用：跳转到一个页面，跳转内部锚点，发邮件打电话</li>\n<li>常用属性</li>\n</ul>\n<p>1 <strong>herf</strong></p>\n<ul>\n<li>网址</li>\n<li>路径</li>\n<li>文件名<br>配合download使用，这样a标签就变成了一个下载按钮，可以下载该文件。</li>\n<li>伪协议: javascript:; mailto:邮箱 tel:电话号码<br>javasctipt:; 里面如果写js代码，就可以执行js命令，如果什么都不写，就会变成一个点击以后没有任何动作的a标签。</li>\n<li>id<br>href=”#xxx” 可以跳转到本页面，id为xxx的元素上。</li>\n</ul>\n<p>2 <strong>target</strong></p>\n<ul>\n<li><code>_blank</code> 在空白的页面上打开。</li>\n<li><code>_self</code> 在当前页面打开，是默认值</li>\n<li><code>_top</code> 配合<code>ifram</code>e理解,当一个页面里面，有一个iframe，iframe里面的a标签，target是<code>_top</code>的话，就在<font color=red>最上层</font>页面打开。 </li>\n<li><code>_parent</code> 配合iframe理解，当一个页面里面，有一个iframe，iframe里面的a标签，target是<code>_paren</code>t的话，就在<font color=red>上一层</font>的页面打开</li>\n<li>xxx 在一个新的窗口打开并且把该页面命名为xxx，以后再新打开的窗口都会在xxx打开。利用一个窗口打开新的页面。例子：youku防止用户不看广告，所有新开的视频都在一个页面上打开。</li>\n<li>iframe 便签的name ，可以在不同的iframe打开。</li>\n</ul>\n<p>3 <strong>download</strong> </p>\n<ul>\n<li>只写<code>download</code>，就会把整个网页都下载下来。</li>\n<li><code>download=&#39;xxxx&#39;</code> 就是下载的文件命名为xxx</li>\n</ul>\n<h2 id=\"iframe标签\"><a href=\"#iframe标签\" class=\"headerlink\" title=\"iframe标签\"></a><strong>iframe标签</strong></h2><p>   作用：在网页内内嵌一个窗口。（已经很少使用，只有很多古老的网站还在使用）</p>\n<h2 id=\"table标签\"><a href=\"#table标签\" class=\"headerlink\" title=\"table标签\"></a><strong>table标签</strong></h2><p>   table里面要包含 thead tbody tfoot<br>   <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">thead</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span>  //table raw 表格里的一行</span><br><span class=\"line\">      \t <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>英文<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span> //table head 表头</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>翻译<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">thead</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>table<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span> //table data 表格里的数据</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>表格<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tfoot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">tfoot</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"img标签\"><a href=\"#img标签\" class=\"headerlink\" title=\"img标签\"></a><strong>img标签</strong></h2><ul>\n<li>src=”图片的地址也可以是相对路径”</li>\n<li>alt=”xxxx” 图片下载失败的时候，提示用户alt里面的内容</li>\n<li>width，height 单独写一个，图片会自适应</li>\n<li>max-width:100% 图片会根据屏幕大小自适应</li>\n</ul>\n<h2 id=\"form标签\"><a href=\"#form标签\" class=\"headerlink\" title=\"form标签\"></a><strong>form标签</strong></h2><p>  <strong>作用</strong> :表示文档中的一个区域，此区域包含交互控件，用于向 Web 服务器提交信息。<br>  <strong>属性</strong></p>\n<ul>\n<li>action:xxx 请求一个页面</li>\n<li>method:get/post 控制请求是get还是post</li>\n<li>autocomplete:on/off 可以自动建议之前输入过的用户名</li>\n<li>target:xxxx 提交到那个页面，该页面更新<br>form标签里面必须有一个type=submit的东西，不然form就不会提交。</li>\n</ul>\n<h2 id=\"input标签\"><a href=\"#input标签\" class=\"headerlink\" title=\"input标签\"></a><strong>input标签</strong></h2><ul>\n<li><strong>作用</strong> :包含在form标签里面，以便接受来自用户的数据; 可以使用各种类型的输入数据和控件小部件<br>属性太多，具体参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input\">MDN input</a></li>\n</ul>\n<p>参考资料:饥人谷</p>"},{"title":"Ubuntu网络基本常识","date":"2020-09-26T15:43:33.000Z","toc":true,"cover":"./img/ubuntu.jpg","_content":"## __基本命令__\n\n* <font color=\"#DC461D\"><b>ifconfig</b></font>  查看ubuntu网络信息\n* <font color=\"#DC461D\"><b>ifconfig</b><i>网卡名</i></font> 查看网卡信息\n* <font color=\"#DC461D\"><b>sudo ifconfig up/down</b></font> 激活或禁用网卡\n* <font color=\"#DC461D\"><b>sudo /etc/networking star/stop</b></font> 启用或禁用网络\n<!--more-->\n\n## __Ubuntu18.04设置静态ip和动态ip方法__\n\n### __新旧版本对比__\n* 之前Ubuntu16.04版本里的网卡配置文件 /etc/network/interfaces  不起作用了，改成了netplan方式。\n\n### __什么是netplan__\n* netplan官网说它是一个在Linux系统中简单方便配置网络的程序，使用YAML格式的文件进行配置。\n\n### __netplan工作方式__\n* netplan 从配置文件 `/etc/netplan/*.yaml` 读取网络配置，启动后 netplan 在 `/run` 目录中生成特定网卡名称后缀的配置文件，然后将网卡设备的控制权移交给特定的网络守护程序。\n\n### __查看网卡用netplan配置信息__\n```\nroot@leeho:~# networkctl status ens160\n● 2: ens160\n       Link File: /lib/systemd/network/99-default.link\n    Network File: /run/systemd/network/10-netplan-ens160.network\n            Type: ether\n           State: routable (configured)\n            Path: pci-0000:03:00.0\n          Driver: vmxnet3\n          Vendor: VMware\n           Model: VMXNET3 Ethernet Controller\n      HW Address: 00:0c:29:04:52:18 (VMware, Inc.)\n         Address: 192.168.10.4\n                  fdb3:3ac8:f5cf::a36\n                  fdb3:3ac8:f5cf:0:20c:29ff:fe04:5218\n                  fe80::20c:29ff:fe04:5218\n         Gateway: 192.168.10.3 (VMware, Inc.)\n                  fe80::20c:29ff:fe86:36cf (VMware, Inc.)\n             DNS: 192.168.10.3\n                  223.5.5.5\n                  fdb3:3ac8:f5cf::1\n```\n### __如何使用netplan__\n* 配置文件：`/etc/netplan/*.yaml`\n* 命令：`netplan apply`\n* 每个网卡都需要在 `/etc/netplan` 目录中设置配置文件，在配置中指定网卡ip信息，使用DHCP或者静态ip方式。`/etc/netplan/` 目录下的配置文件，扩展名为.yaml（例如 `/etc/netplan/config.yaml`），然后运行 netplan apply 此命令分析配置信息并将其应用生效。配置文档示例：\n```\n#网卡eth0使用dhcp方式配置ip网络，配置如下。yaml配置是用空格作为缩进对齐，不能使用tab键。\nnetwork:\n  version: 2\n  renderer: networkd\n  ethernets:\n    eth0:\n      dhcp4: yes\n      dhcp6: no\n#网卡eth0使用静态ip方式，用关键字addresses指定ip地址和子网掩码（支持ipv4和ivp6），gateway4指定网关ip，nameservers 指定DNS。\nnetwork:\n  version: 2\n  renderer: networkd\n  ethernets:\n    eth0:\n      addresses:\n      - 10.10.10.2/24\n      gateway4: 10.10.10.1\n      nameservers:\n          search: [mydomain, otherdomain]\n          addresses: [10.10.10.1, 1.1.1.1]\n```\n配置文件里的关键字说明：\n`renderer`：指定后端网络服务，支持networkd（Systemd-networkd） 和 Network,Manager两种，默认是networkd。\n`ethernets`：指定是以太网配置，其他的还包括 wifis 或者 bridges\n`eth0`：以太网网卡名称\n`dhcp4`：开启使用ipv4的DHCP，默认是关闭。\n`dhcp6`：开启使用ipv6的DHCP，默认是关闭。\n`addresses`：对应网卡配置的静态ip地址，是ip/掩码的格式，支持ipv6地址，例如 addresses: [192.168.14.2/24, \"2001:1::1/64\"]\n`gateway4, gateway6`：指定IPv4/6默认网关，使用静态ip配置时使用。例如IPv4: gateway4: 172.16.0.1 例如IPv6: gateway6: \"2001:4::1\"\n`nameservers`：设置DNS服务器和搜索域。有两个受支持的字段：addresses:是DNS地址列表，search:是搜索域列表,没有特殊需要可以不配置search这项。\n\n资源来源:https://developer.aliyun.com/article/744737\n\n\n","source":"_posts/Ubuntu网络基本常识.md","raw":"---\ntitle: Ubuntu网络基本常识\ndate: 2020-09-26 15:43:33\ntags: ubuntu网络\ntoc: true\ncover: ./img/ubuntu.jpg\n---\n## __基本命令__\n\n* <font color=\"#DC461D\"><b>ifconfig</b></font>  查看ubuntu网络信息\n* <font color=\"#DC461D\"><b>ifconfig</b><i>网卡名</i></font> 查看网卡信息\n* <font color=\"#DC461D\"><b>sudo ifconfig up/down</b></font> 激活或禁用网卡\n* <font color=\"#DC461D\"><b>sudo /etc/networking star/stop</b></font> 启用或禁用网络\n<!--more-->\n\n## __Ubuntu18.04设置静态ip和动态ip方法__\n\n### __新旧版本对比__\n* 之前Ubuntu16.04版本里的网卡配置文件 /etc/network/interfaces  不起作用了，改成了netplan方式。\n\n### __什么是netplan__\n* netplan官网说它是一个在Linux系统中简单方便配置网络的程序，使用YAML格式的文件进行配置。\n\n### __netplan工作方式__\n* netplan 从配置文件 `/etc/netplan/*.yaml` 读取网络配置，启动后 netplan 在 `/run` 目录中生成特定网卡名称后缀的配置文件，然后将网卡设备的控制权移交给特定的网络守护程序。\n\n### __查看网卡用netplan配置信息__\n```\nroot@leeho:~# networkctl status ens160\n● 2: ens160\n       Link File: /lib/systemd/network/99-default.link\n    Network File: /run/systemd/network/10-netplan-ens160.network\n            Type: ether\n           State: routable (configured)\n            Path: pci-0000:03:00.0\n          Driver: vmxnet3\n          Vendor: VMware\n           Model: VMXNET3 Ethernet Controller\n      HW Address: 00:0c:29:04:52:18 (VMware, Inc.)\n         Address: 192.168.10.4\n                  fdb3:3ac8:f5cf::a36\n                  fdb3:3ac8:f5cf:0:20c:29ff:fe04:5218\n                  fe80::20c:29ff:fe04:5218\n         Gateway: 192.168.10.3 (VMware, Inc.)\n                  fe80::20c:29ff:fe86:36cf (VMware, Inc.)\n             DNS: 192.168.10.3\n                  223.5.5.5\n                  fdb3:3ac8:f5cf::1\n```\n### __如何使用netplan__\n* 配置文件：`/etc/netplan/*.yaml`\n* 命令：`netplan apply`\n* 每个网卡都需要在 `/etc/netplan` 目录中设置配置文件，在配置中指定网卡ip信息，使用DHCP或者静态ip方式。`/etc/netplan/` 目录下的配置文件，扩展名为.yaml（例如 `/etc/netplan/config.yaml`），然后运行 netplan apply 此命令分析配置信息并将其应用生效。配置文档示例：\n```\n#网卡eth0使用dhcp方式配置ip网络，配置如下。yaml配置是用空格作为缩进对齐，不能使用tab键。\nnetwork:\n  version: 2\n  renderer: networkd\n  ethernets:\n    eth0:\n      dhcp4: yes\n      dhcp6: no\n#网卡eth0使用静态ip方式，用关键字addresses指定ip地址和子网掩码（支持ipv4和ivp6），gateway4指定网关ip，nameservers 指定DNS。\nnetwork:\n  version: 2\n  renderer: networkd\n  ethernets:\n    eth0:\n      addresses:\n      - 10.10.10.2/24\n      gateway4: 10.10.10.1\n      nameservers:\n          search: [mydomain, otherdomain]\n          addresses: [10.10.10.1, 1.1.1.1]\n```\n配置文件里的关键字说明：\n`renderer`：指定后端网络服务，支持networkd（Systemd-networkd） 和 Network,Manager两种，默认是networkd。\n`ethernets`：指定是以太网配置，其他的还包括 wifis 或者 bridges\n`eth0`：以太网网卡名称\n`dhcp4`：开启使用ipv4的DHCP，默认是关闭。\n`dhcp6`：开启使用ipv6的DHCP，默认是关闭。\n`addresses`：对应网卡配置的静态ip地址，是ip/掩码的格式，支持ipv6地址，例如 addresses: [192.168.14.2/24, \"2001:1::1/64\"]\n`gateway4, gateway6`：指定IPv4/6默认网关，使用静态ip配置时使用。例如IPv4: gateway4: 172.16.0.1 例如IPv6: gateway6: \"2001:4::1\"\n`nameservers`：设置DNS服务器和搜索域。有两个受支持的字段：addresses:是DNS地址列表，search:是搜索域列表,没有特殊需要可以不配置search这项。\n\n资源来源:https://developer.aliyun.com/article/744737\n\n\n","slug":"Ubuntu网络基本常识","published":1,"updated":"2020-09-26T16:29:55.235Z","_id":"ckfjuh4ut0000tufqh4v86j2y","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a><strong>基本命令</strong></h2><ul>\n<li><font color=\"#DC461D\"><b>ifconfig</b></font>  查看ubuntu网络信息</li>\n<li><font color=\"#DC461D\"><b>ifconfig</b><i>网卡名</i></font> 查看网卡信息</li>\n<li><font color=\"#DC461D\"><b>sudo ifconfig up/down</b></font> 激活或禁用网卡</li>\n<li><font color=\"#DC461D\"><b>sudo /etc/networking star/stop</b></font> 启用或禁用网络<a id=\"more\"></a>\n\n</li>\n</ul>\n<h2 id=\"Ubuntu18-04设置静态ip和动态ip方法\"><a href=\"#Ubuntu18-04设置静态ip和动态ip方法\" class=\"headerlink\" title=\"Ubuntu18.04设置静态ip和动态ip方法\"></a><strong>Ubuntu18.04设置静态ip和动态ip方法</strong></h2><h3 id=\"新旧版本对比\"><a href=\"#新旧版本对比\" class=\"headerlink\" title=\"新旧版本对比\"></a><strong>新旧版本对比</strong></h3><ul>\n<li>之前Ubuntu16.04版本里的网卡配置文件 /etc/network/interfaces  不起作用了，改成了netplan方式。</li>\n</ul>\n<h3 id=\"什么是netplan\"><a href=\"#什么是netplan\" class=\"headerlink\" title=\"什么是netplan\"></a><strong>什么是netplan</strong></h3><ul>\n<li>netplan官网说它是一个在Linux系统中简单方便配置网络的程序，使用YAML格式的文件进行配置。</li>\n</ul>\n<h3 id=\"netplan工作方式\"><a href=\"#netplan工作方式\" class=\"headerlink\" title=\"netplan工作方式\"></a><strong>netplan工作方式</strong></h3><ul>\n<li>netplan 从配置文件 <code>/etc/netplan/*.yaml</code> 读取网络配置，启动后 netplan 在 <code>/run</code> 目录中生成特定网卡名称后缀的配置文件，然后将网卡设备的控制权移交给特定的网络守护程序。</li>\n</ul>\n<h3 id=\"查看网卡用netplan配置信息\"><a href=\"#查看网卡用netplan配置信息\" class=\"headerlink\" title=\"查看网卡用netplan配置信息\"></a><strong>查看网卡用netplan配置信息</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@leeho:~# networkctl status ens160</span><br><span class=\"line\">● 2: ens160</span><br><span class=\"line\">       Link File: &#x2F;lib&#x2F;systemd&#x2F;network&#x2F;99-default.link</span><br><span class=\"line\">    Network File: &#x2F;run&#x2F;systemd&#x2F;network&#x2F;10-netplan-ens160.network</span><br><span class=\"line\">            Type: ether</span><br><span class=\"line\">           State: routable (configured)</span><br><span class=\"line\">            Path: pci-0000:03:00.0</span><br><span class=\"line\">          Driver: vmxnet3</span><br><span class=\"line\">          Vendor: VMware</span><br><span class=\"line\">           Model: VMXNET3 Ethernet Controller</span><br><span class=\"line\">      HW Address: 00:0c:29:04:52:18 (VMware, Inc.)</span><br><span class=\"line\">         Address: 192.168.10.4</span><br><span class=\"line\">                  fdb3:3ac8:f5cf::a36</span><br><span class=\"line\">                  fdb3:3ac8:f5cf:0:20c:29ff:fe04:5218</span><br><span class=\"line\">                  fe80::20c:29ff:fe04:5218</span><br><span class=\"line\">         Gateway: 192.168.10.3 (VMware, Inc.)</span><br><span class=\"line\">                  fe80::20c:29ff:fe86:36cf (VMware, Inc.)</span><br><span class=\"line\">             DNS: 192.168.10.3</span><br><span class=\"line\">                  223.5.5.5</span><br><span class=\"line\">                  fdb3:3ac8:f5cf::1</span><br></pre></td></tr></table></figure>\n<h3 id=\"如何使用netplan\"><a href=\"#如何使用netplan\" class=\"headerlink\" title=\"如何使用netplan\"></a><strong>如何使用netplan</strong></h3><ul>\n<li>配置文件：<code>/etc/netplan/*.yaml</code></li>\n<li>命令：<code>netplan apply</code></li>\n<li>每个网卡都需要在 <code>/etc/netplan</code> 目录中设置配置文件，在配置中指定网卡ip信息，使用DHCP或者静态ip方式。<code>/etc/netplan/</code> 目录下的配置文件，扩展名为.yaml（例如 <code>/etc/netplan/config.yaml</code>），然后运行 netplan apply 此命令分析配置信息并将其应用生效。配置文档示例：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#网卡eth0使用dhcp方式配置ip网络，配置如下。yaml配置是用空格作为缩进对齐，不能使用tab键。</span><br><span class=\"line\">network:</span><br><span class=\"line\">  version: 2</span><br><span class=\"line\">  renderer: networkd</span><br><span class=\"line\">  ethernets:</span><br><span class=\"line\">    eth0:</span><br><span class=\"line\">      dhcp4: yes</span><br><span class=\"line\">      dhcp6: no</span><br><span class=\"line\">#网卡eth0使用静态ip方式，用关键字addresses指定ip地址和子网掩码（支持ipv4和ivp6），gateway4指定网关ip，nameservers 指定DNS。</span><br><span class=\"line\">network:</span><br><span class=\"line\">  version: 2</span><br><span class=\"line\">  renderer: networkd</span><br><span class=\"line\">  ethernets:</span><br><span class=\"line\">    eth0:</span><br><span class=\"line\">      addresses:</span><br><span class=\"line\">      - 10.10.10.2&#x2F;24</span><br><span class=\"line\">      gateway4: 10.10.10.1</span><br><span class=\"line\">      nameservers:</span><br><span class=\"line\">          search: [mydomain, otherdomain]</span><br><span class=\"line\">          addresses: [10.10.10.1, 1.1.1.1]</span><br></pre></td></tr></table></figure>\n配置文件里的关键字说明：<br><code>renderer</code>：指定后端网络服务，支持networkd（Systemd-networkd） 和 Network,Manager两种，默认是networkd。<br><code>ethernets</code>：指定是以太网配置，其他的还包括 wifis 或者 bridges<br><code>eth0</code>：以太网网卡名称<br><code>dhcp4</code>：开启使用ipv4的DHCP，默认是关闭。<br><code>dhcp6</code>：开启使用ipv6的DHCP，默认是关闭。<br><code>addresses</code>：对应网卡配置的静态ip地址，是ip/掩码的格式，支持ipv6地址，例如 addresses: [192.168.14.2/24, “2001:1::1/64”]<br><code>gateway4, gateway6</code>：指定IPv4/6默认网关，使用静态ip配置时使用。例如IPv4: gateway4: 172.16.0.1 例如IPv6: gateway6: “2001:4::1”<br><code>nameservers</code>：设置DNS服务器和搜索域。有两个受支持的字段：addresses:是DNS地址列表，search:是搜索域列表,没有特殊需要可以不配置search这项。</li>\n</ul>\n<p>资源来源:<a href=\"https://developer.aliyun.com/article/744737\">https://developer.aliyun.com/article/744737</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a><strong>基本命令</strong></h2><ul>\n<li><font color=\"#DC461D\"><b>ifconfig</b></font>  查看ubuntu网络信息</li>\n<li><font color=\"#DC461D\"><b>ifconfig</b><i>网卡名</i></font> 查看网卡信息</li>\n<li><font color=\"#DC461D\"><b>sudo ifconfig up/down</b></font> 激活或禁用网卡</li>\n<li><font color=\"#DC461D\"><b>sudo /etc/networking star/stop</b></font> 启用或禁用网络","more":"</li>\n</ul>\n<h2 id=\"Ubuntu18-04设置静态ip和动态ip方法\"><a href=\"#Ubuntu18-04设置静态ip和动态ip方法\" class=\"headerlink\" title=\"Ubuntu18.04设置静态ip和动态ip方法\"></a><strong>Ubuntu18.04设置静态ip和动态ip方法</strong></h2><h3 id=\"新旧版本对比\"><a href=\"#新旧版本对比\" class=\"headerlink\" title=\"新旧版本对比\"></a><strong>新旧版本对比</strong></h3><ul>\n<li>之前Ubuntu16.04版本里的网卡配置文件 /etc/network/interfaces  不起作用了，改成了netplan方式。</li>\n</ul>\n<h3 id=\"什么是netplan\"><a href=\"#什么是netplan\" class=\"headerlink\" title=\"什么是netplan\"></a><strong>什么是netplan</strong></h3><ul>\n<li>netplan官网说它是一个在Linux系统中简单方便配置网络的程序，使用YAML格式的文件进行配置。</li>\n</ul>\n<h3 id=\"netplan工作方式\"><a href=\"#netplan工作方式\" class=\"headerlink\" title=\"netplan工作方式\"></a><strong>netplan工作方式</strong></h3><ul>\n<li>netplan 从配置文件 <code>/etc/netplan/*.yaml</code> 读取网络配置，启动后 netplan 在 <code>/run</code> 目录中生成特定网卡名称后缀的配置文件，然后将网卡设备的控制权移交给特定的网络守护程序。</li>\n</ul>\n<h3 id=\"查看网卡用netplan配置信息\"><a href=\"#查看网卡用netplan配置信息\" class=\"headerlink\" title=\"查看网卡用netplan配置信息\"></a><strong>查看网卡用netplan配置信息</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@leeho:~# networkctl status ens160</span><br><span class=\"line\">● 2: ens160</span><br><span class=\"line\">       Link File: &#x2F;lib&#x2F;systemd&#x2F;network&#x2F;99-default.link</span><br><span class=\"line\">    Network File: &#x2F;run&#x2F;systemd&#x2F;network&#x2F;10-netplan-ens160.network</span><br><span class=\"line\">            Type: ether</span><br><span class=\"line\">           State: routable (configured)</span><br><span class=\"line\">            Path: pci-0000:03:00.0</span><br><span class=\"line\">          Driver: vmxnet3</span><br><span class=\"line\">          Vendor: VMware</span><br><span class=\"line\">           Model: VMXNET3 Ethernet Controller</span><br><span class=\"line\">      HW Address: 00:0c:29:04:52:18 (VMware, Inc.)</span><br><span class=\"line\">         Address: 192.168.10.4</span><br><span class=\"line\">                  fdb3:3ac8:f5cf::a36</span><br><span class=\"line\">                  fdb3:3ac8:f5cf:0:20c:29ff:fe04:5218</span><br><span class=\"line\">                  fe80::20c:29ff:fe04:5218</span><br><span class=\"line\">         Gateway: 192.168.10.3 (VMware, Inc.)</span><br><span class=\"line\">                  fe80::20c:29ff:fe86:36cf (VMware, Inc.)</span><br><span class=\"line\">             DNS: 192.168.10.3</span><br><span class=\"line\">                  223.5.5.5</span><br><span class=\"line\">                  fdb3:3ac8:f5cf::1</span><br></pre></td></tr></table></figure>\n<h3 id=\"如何使用netplan\"><a href=\"#如何使用netplan\" class=\"headerlink\" title=\"如何使用netplan\"></a><strong>如何使用netplan</strong></h3><ul>\n<li>配置文件：<code>/etc/netplan/*.yaml</code></li>\n<li>命令：<code>netplan apply</code></li>\n<li>每个网卡都需要在 <code>/etc/netplan</code> 目录中设置配置文件，在配置中指定网卡ip信息，使用DHCP或者静态ip方式。<code>/etc/netplan/</code> 目录下的配置文件，扩展名为.yaml（例如 <code>/etc/netplan/config.yaml</code>），然后运行 netplan apply 此命令分析配置信息并将其应用生效。配置文档示例：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#网卡eth0使用dhcp方式配置ip网络，配置如下。yaml配置是用空格作为缩进对齐，不能使用tab键。</span><br><span class=\"line\">network:</span><br><span class=\"line\">  version: 2</span><br><span class=\"line\">  renderer: networkd</span><br><span class=\"line\">  ethernets:</span><br><span class=\"line\">    eth0:</span><br><span class=\"line\">      dhcp4: yes</span><br><span class=\"line\">      dhcp6: no</span><br><span class=\"line\">#网卡eth0使用静态ip方式，用关键字addresses指定ip地址和子网掩码（支持ipv4和ivp6），gateway4指定网关ip，nameservers 指定DNS。</span><br><span class=\"line\">network:</span><br><span class=\"line\">  version: 2</span><br><span class=\"line\">  renderer: networkd</span><br><span class=\"line\">  ethernets:</span><br><span class=\"line\">    eth0:</span><br><span class=\"line\">      addresses:</span><br><span class=\"line\">      - 10.10.10.2&#x2F;24</span><br><span class=\"line\">      gateway4: 10.10.10.1</span><br><span class=\"line\">      nameservers:</span><br><span class=\"line\">          search: [mydomain, otherdomain]</span><br><span class=\"line\">          addresses: [10.10.10.1, 1.1.1.1]</span><br></pre></td></tr></table></figure>\n配置文件里的关键字说明：<br><code>renderer</code>：指定后端网络服务，支持networkd（Systemd-networkd） 和 Network,Manager两种，默认是networkd。<br><code>ethernets</code>：指定是以太网配置，其他的还包括 wifis 或者 bridges<br><code>eth0</code>：以太网网卡名称<br><code>dhcp4</code>：开启使用ipv4的DHCP，默认是关闭。<br><code>dhcp6</code>：开启使用ipv6的DHCP，默认是关闭。<br><code>addresses</code>：对应网卡配置的静态ip地址，是ip/掩码的格式，支持ipv6地址，例如 addresses: [192.168.14.2/24, “2001:1::1/64”]<br><code>gateway4, gateway6</code>：指定IPv4/6默认网关，使用静态ip配置时使用。例如IPv4: gateway4: 172.16.0.1 例如IPv6: gateway6: “2001:4::1”<br><code>nameservers</code>：设置DNS服务器和搜索域。有两个受支持的字段：addresses:是DNS地址列表，search:是搜索域列表,没有特殊需要可以不配置search这项。</li>\n</ul>\n<p>资源来源:<a href=\"https://developer.aliyun.com/article/744737\">https://developer.aliyun.com/article/744737</a></p>"},{"title":"CSS基础概念","date":"2020-09-29T17:03:22.000Z","toc":true,"cover":"./img/csslogo.jpg","_content":"## __CSS的历史__\n* CSS全称_Cascading Style Sheets_ ，又称层叠样式表。\n* 于1994年，哈肯·维姆·莱和伯特·波斯合作设计CSS。他们在1994年首次在芝加哥的一次会议上第一次展示了CSS的建议。\n<!--more-->\n\n## __层叠指的是什么__\n* 样式层叠\n可以多次对同一选择器进行样式声明\n* 选择器层叠\n可以用不同选择器对同一元素进行样式声明\n* 文件层叠\n可以用多个文件进行层叠\n\n## __CSS的历史版本__\n<div align=\"center\" ><img src=\"./img/2.png\"></div>\n\n## __CSS语法__\n* 样式语法\n```css\n选择器{\n 属性名：属性值;\n /*注释*/\n}\n```\n* @语法\n```css\n@charset \"UTF-8\"; //告诉浏览器用UTF-8的编码方式解析；必须放在第一行；\n@import url(style.css); //从外部引入CSS样式；\n@media (min-width:100px) and (max-width:200px){\n   样式语法\n} //当设备的最小宽度为100px,最大宽度为200px时，才会执行。\n```\n\n## __如何调试__\n* Border调试法\n```CSS\nborder:1px solid red;\n```\n怀疑某个元素有问题，就给这个元素加个border，border没有出现，说明选择器错了或者语法错了，border出现了，看看边界是否符合预期。\n\n## __在哪查资料__\n* Google搜索关键词时加MDN\n* CSS tricks https://css-tricks.com/\n* 张鑫旭的博客\n\n## __CSS文档流__\n<div align=\"center\" ><img src=\"./img/1.png\"></div>\n\n* 流动方向\n`inline`元素从左到右，达到最右才会换行\n`block`元素从上到下，每一个都另起一行\n`inline-block`元素从左到右，但是都是以块的形式存在，不会分离\n\n## __元素的高度和宽度__\n<div align=\"center\" ><img src=\"./img/3.png\"></div>\n\n元素不分是内联还是块级元素，可以通过`display`来设置元素是块级元素还是内联元素。\n\n* 宽度\n`inline`元素的宽度为内部`inline`元素的和，不能用宽度来指定，可以由`padding`来把宽度撑开。\n`block`元素默认自动计算宽度，默认是占满一行，但不是100%,但是不建议写宽度100%，可以由`width`来指定。\n`inline-block`元素，默认宽度是有里面的内容来决定，但是也可以由`width`来指定。\n\n* 高度\n`inline`元素高度由`line-height`间接决定的，跟`height`无关。虽然可以通过padding来把inline元素撑开，但那不是它的高度，而是他的可视高地。\n`block`元素高度由内部文档流元素觉得，可以通过`height`来设定\n`inline-block`跟block类似，可以通过`height`来设定\n\n## __overflow溢出__\n* 当内容的宽度和高度大于容器的时候，会溢出容器。可以通过overflow来设置是否显示滚动条。\n```CSS\noverflow:auto // 只有当文字溢出的时候，才会显示，不溢出就不会显示。\noverflow:scroll // 不管是否溢出，都显示滚动条。\noverflow:hidden // 直接隐藏溢出部分 \noverflow:visible //默认设置，会显示溢出部分\n```\n\n## __盒模型__\n<div align=\"center\" ><img src=\"./img/4.png\"></div>\n* 盒模型有两种，一种是content盒模型/内容盒模型 ； 一种是border盒模型/边框盒模型。\ncontent盒模型-内容就是盒子的边界。\nborder盒模型-边框才是盒子的边界。\n\n* 公式\ncontent-box width/height = 内容的宽度\nborder-box width/height = 内容宽度 + padding + border\n\n## __margin合并__\n* 哪些情况会发送`margin`合并\n 父子`margin`合并\n 兄弟元素`margin`合并\n\n\n* 如何组织`margin`合并\n 父子合并用`padding`/`border`挡住\n 父子合并用`overflow:hidden`挡住\n 父子合并用`display:flex`\n 兄弟合并用`inline-block`消除\n\n## __基本单位__\n* 长度单位\npx  像素\nem  相对于自身font-size的倍数\n%\n整数\n\n* 颜色\n十六进制#FF6600 或者 #F60\nRGBA颜色rgb(0,0.0)或者rgba(0,0,0,1) rgba最后的1，表示透明度，1代表不透明，0代表完全透明\n\n资源来源:饥人谷\n","source":"_posts/CSS基础.md","raw":"---\ntitle: CSS基础概念\ndate: 2020-09-29 17:03:22\ntags: CSS\ntoc: true\ncover: ./img/csslogo.jpg\n---\n## __CSS的历史__\n* CSS全称_Cascading Style Sheets_ ，又称层叠样式表。\n* 于1994年，哈肯·维姆·莱和伯特·波斯合作设计CSS。他们在1994年首次在芝加哥的一次会议上第一次展示了CSS的建议。\n<!--more-->\n\n## __层叠指的是什么__\n* 样式层叠\n可以多次对同一选择器进行样式声明\n* 选择器层叠\n可以用不同选择器对同一元素进行样式声明\n* 文件层叠\n可以用多个文件进行层叠\n\n## __CSS的历史版本__\n<div align=\"center\" ><img src=\"./img/2.png\"></div>\n\n## __CSS语法__\n* 样式语法\n```css\n选择器{\n 属性名：属性值;\n /*注释*/\n}\n```\n* @语法\n```css\n@charset \"UTF-8\"; //告诉浏览器用UTF-8的编码方式解析；必须放在第一行；\n@import url(style.css); //从外部引入CSS样式；\n@media (min-width:100px) and (max-width:200px){\n   样式语法\n} //当设备的最小宽度为100px,最大宽度为200px时，才会执行。\n```\n\n## __如何调试__\n* Border调试法\n```CSS\nborder:1px solid red;\n```\n怀疑某个元素有问题，就给这个元素加个border，border没有出现，说明选择器错了或者语法错了，border出现了，看看边界是否符合预期。\n\n## __在哪查资料__\n* Google搜索关键词时加MDN\n* CSS tricks https://css-tricks.com/\n* 张鑫旭的博客\n\n## __CSS文档流__\n<div align=\"center\" ><img src=\"./img/1.png\"></div>\n\n* 流动方向\n`inline`元素从左到右，达到最右才会换行\n`block`元素从上到下，每一个都另起一行\n`inline-block`元素从左到右，但是都是以块的形式存在，不会分离\n\n## __元素的高度和宽度__\n<div align=\"center\" ><img src=\"./img/3.png\"></div>\n\n元素不分是内联还是块级元素，可以通过`display`来设置元素是块级元素还是内联元素。\n\n* 宽度\n`inline`元素的宽度为内部`inline`元素的和，不能用宽度来指定，可以由`padding`来把宽度撑开。\n`block`元素默认自动计算宽度，默认是占满一行，但不是100%,但是不建议写宽度100%，可以由`width`来指定。\n`inline-block`元素，默认宽度是有里面的内容来决定，但是也可以由`width`来指定。\n\n* 高度\n`inline`元素高度由`line-height`间接决定的，跟`height`无关。虽然可以通过padding来把inline元素撑开，但那不是它的高度，而是他的可视高地。\n`block`元素高度由内部文档流元素觉得，可以通过`height`来设定\n`inline-block`跟block类似，可以通过`height`来设定\n\n## __overflow溢出__\n* 当内容的宽度和高度大于容器的时候，会溢出容器。可以通过overflow来设置是否显示滚动条。\n```CSS\noverflow:auto // 只有当文字溢出的时候，才会显示，不溢出就不会显示。\noverflow:scroll // 不管是否溢出，都显示滚动条。\noverflow:hidden // 直接隐藏溢出部分 \noverflow:visible //默认设置，会显示溢出部分\n```\n\n## __盒模型__\n<div align=\"center\" ><img src=\"./img/4.png\"></div>\n* 盒模型有两种，一种是content盒模型/内容盒模型 ； 一种是border盒模型/边框盒模型。\ncontent盒模型-内容就是盒子的边界。\nborder盒模型-边框才是盒子的边界。\n\n* 公式\ncontent-box width/height = 内容的宽度\nborder-box width/height = 内容宽度 + padding + border\n\n## __margin合并__\n* 哪些情况会发送`margin`合并\n 父子`margin`合并\n 兄弟元素`margin`合并\n\n\n* 如何组织`margin`合并\n 父子合并用`padding`/`border`挡住\n 父子合并用`overflow:hidden`挡住\n 父子合并用`display:flex`\n 兄弟合并用`inline-block`消除\n\n## __基本单位__\n* 长度单位\npx  像素\nem  相对于自身font-size的倍数\n%\n整数\n\n* 颜色\n十六进制#FF6600 或者 #F60\nRGBA颜色rgb(0,0.0)或者rgba(0,0,0,1) rgba最后的1，表示透明度，1代表不透明，0代表完全透明\n\n资源来源:饥人谷\n","slug":"CSS基础","published":1,"updated":"2020-09-29T18:26:23.824Z","_id":"ckfo7o8j40000xrfq2424dj55","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"CSS的历史\"><a href=\"#CSS的历史\" class=\"headerlink\" title=\"CSS的历史\"></a><strong>CSS的历史</strong></h2><ul>\n<li>CSS全称<em>Cascading Style Sheets</em> ，又称层叠样式表。</li>\n<li>于1994年，哈肯·维姆·莱和伯特·波斯合作设计CSS。他们在1994年首次在芝加哥的一次会议上第一次展示了CSS的建议。<a id=\"more\"></a>\n\n</li>\n</ul>\n<h2 id=\"层叠指的是什么\"><a href=\"#层叠指的是什么\" class=\"headerlink\" title=\"层叠指的是什么\"></a><strong>层叠指的是什么</strong></h2><ul>\n<li>样式层叠<br>可以多次对同一选择器进行样式声明</li>\n<li>选择器层叠<br>可以用不同选择器对同一元素进行样式声明</li>\n<li>文件层叠<br>可以用多个文件进行层叠</li>\n</ul>\n<h2 id=\"CSS的历史版本\"><a href=\"#CSS的历史版本\" class=\"headerlink\" title=\"CSS的历史版本\"></a><strong>CSS的历史版本</strong></h2><div align=\"center\" ><img src=\"./img/2.png\"></div>\n\n<h2 id=\"CSS语法\"><a href=\"#CSS语法\" class=\"headerlink\" title=\"CSS语法\"></a><strong>CSS语法</strong></h2><ul>\n<li>样式语法<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">选择器&#123;</span><br><span class=\"line\"> 属性名：属性值;</span><br><span class=\"line\"> <span class=\"comment\">/*注释*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>@语法<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@charset &quot;UTF-8&quot;; //告诉浏览器用UTF-8的编码方式解析；必须放在第一行；</span><br><span class=\"line\">@import url(style.css); //从外部引入CSS样式；</span><br><span class=\"line\"><span class=\"keyword\">@media</span> (<span class=\"attribute\">min-width:</span><span class=\"number\">100px</span>) <span class=\"keyword\">and</span> (<span class=\"attribute\">max-width:</span><span class=\"number\">200px</span>)&#123;</span><br><span class=\"line\">   样式语法</span><br><span class=\"line\">&#125; //当设备的最小宽度为100px,最大宽度为200px时，才会执行。</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"如何调试\"><a href=\"#如何调试\" class=\"headerlink\" title=\"如何调试\"></a><strong>如何调试</strong></h2><ul>\n<li>Border调试法<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">border</span><span class=\"selector-pseudo\">:1px</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">red</span>;</span><br></pre></td></tr></table></figure>\n怀疑某个元素有问题，就给这个元素加个border，border没有出现，说明选择器错了或者语法错了，border出现了，看看边界是否符合预期。</li>\n</ul>\n<h2 id=\"在哪查资料\"><a href=\"#在哪查资料\" class=\"headerlink\" title=\"在哪查资料\"></a><strong>在哪查资料</strong></h2><ul>\n<li>Google搜索关键词时加MDN</li>\n<li>CSS tricks <a href=\"https://css-tricks.com/\">https://css-tricks.com/</a></li>\n<li>张鑫旭的博客</li>\n</ul>\n<h2 id=\"CSS文档流\"><a href=\"#CSS文档流\" class=\"headerlink\" title=\"CSS文档流\"></a><strong>CSS文档流</strong></h2><div align=\"center\" ><img src=\"./img/1.png\"></div>\n\n<ul>\n<li>流动方向<br><code>inline</code>元素从左到右，达到最右才会换行<br><code>block</code>元素从上到下，每一个都另起一行<br><code>inline-block</code>元素从左到右，但是都是以块的形式存在，不会分离</li>\n</ul>\n<h2 id=\"元素的高度和宽度\"><a href=\"#元素的高度和宽度\" class=\"headerlink\" title=\"元素的高度和宽度\"></a><strong>元素的高度和宽度</strong></h2><div align=\"center\" ><img src=\"./img/3.png\"></div>\n\n<p>元素不分是内联还是块级元素，可以通过<code>display</code>来设置元素是块级元素还是内联元素。</p>\n<ul>\n<li><p>宽度<br><code>inline</code>元素的宽度为内部<code>inline</code>元素的和，不能用宽度来指定，可以由<code>padding</code>来把宽度撑开。<br><code>block</code>元素默认自动计算宽度，默认是占满一行，但不是100%,但是不建议写宽度100%，可以由<code>width</code>来指定。<br><code>inline-block</code>元素，默认宽度是有里面的内容来决定，但是也可以由<code>width</code>来指定。</p>\n</li>\n<li><p>高度<br><code>inline</code>元素高度由<code>line-height</code>间接决定的，跟<code>height</code>无关。虽然可以通过padding来把inline元素撑开，但那不是它的高度，而是他的可视高地。<br><code>block</code>元素高度由内部文档流元素觉得，可以通过<code>height</code>来设定<br><code>inline-block</code>跟block类似，可以通过<code>height</code>来设定</p>\n</li>\n</ul>\n<h2 id=\"overflow溢出\"><a href=\"#overflow溢出\" class=\"headerlink\" title=\"overflow溢出\"></a><strong>overflow溢出</strong></h2><ul>\n<li>当内容的宽度和高度大于容器的时候，会溢出容器。可以通过overflow来设置是否显示滚动条。<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">overflow:auto // 只有当文字溢出的时候，才会显示，不溢出就不会显示。</span><br><span class=\"line\">overflow:scroll // 不管是否溢出，都显示滚动条。</span><br><span class=\"line\">overflow:hidden // 直接隐藏溢出部分 </span><br><span class=\"line\">overflow:visible //默认设置，会显示溢出部分</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"盒模型\"><a href=\"#盒模型\" class=\"headerlink\" title=\"盒模型\"></a><strong>盒模型</strong></h2><div align=\"center\" ><img src=\"./img/4.png\"></div>\n* 盒模型有两种，一种是content盒模型/内容盒模型 ； 一种是border盒模型/边框盒模型。\ncontent盒模型-内容就是盒子的边界。\nborder盒模型-边框才是盒子的边界。\n\n<ul>\n<li>公式<br>content-box width/height = 内容的宽度<br>border-box width/height = 内容宽度 + padding + border</li>\n</ul>\n<h2 id=\"margin合并\"><a href=\"#margin合并\" class=\"headerlink\" title=\"margin合并\"></a><strong>margin合并</strong></h2><ul>\n<li>哪些情况会发送<code>margin</code>合并<br>父子<code>margin</code>合并<br>兄弟元素<code>margin</code>合并</li>\n</ul>\n<ul>\n<li>如何组织<code>margin</code>合并<br>父子合并用<code>padding</code>/<code>border</code>挡住<br>父子合并用<code>overflow:hidden</code>挡住<br>父子合并用<code>display:flex</code><br>兄弟合并用<code>inline-block</code>消除</li>\n</ul>\n<h2 id=\"基本单位\"><a href=\"#基本单位\" class=\"headerlink\" title=\"基本单位\"></a><strong>基本单位</strong></h2><ul>\n<li><p>长度单位<br>px  像素<br>em  相对于自身font-size的倍数<br>%<br>整数</p>\n</li>\n<li><p>颜色<br>十六进制#FF6600 或者 #F60<br>RGBA颜色rgb(0,0.0)或者rgba(0,0,0,1) rgba最后的1，表示透明度，1代表不透明，0代表完全透明</p>\n</li>\n</ul>\n<p>资源来源:饥人谷</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"CSS的历史\"><a href=\"#CSS的历史\" class=\"headerlink\" title=\"CSS的历史\"></a><strong>CSS的历史</strong></h2><ul>\n<li>CSS全称<em>Cascading Style Sheets</em> ，又称层叠样式表。</li>\n<li>于1994年，哈肯·维姆·莱和伯特·波斯合作设计CSS。他们在1994年首次在芝加哥的一次会议上第一次展示了CSS的建议。","more":"</li>\n</ul>\n<h2 id=\"层叠指的是什么\"><a href=\"#层叠指的是什么\" class=\"headerlink\" title=\"层叠指的是什么\"></a><strong>层叠指的是什么</strong></h2><ul>\n<li>样式层叠<br>可以多次对同一选择器进行样式声明</li>\n<li>选择器层叠<br>可以用不同选择器对同一元素进行样式声明</li>\n<li>文件层叠<br>可以用多个文件进行层叠</li>\n</ul>\n<h2 id=\"CSS的历史版本\"><a href=\"#CSS的历史版本\" class=\"headerlink\" title=\"CSS的历史版本\"></a><strong>CSS的历史版本</strong></h2><div align=\"center\" ><img src=\"./img/2.png\"></div>\n\n<h2 id=\"CSS语法\"><a href=\"#CSS语法\" class=\"headerlink\" title=\"CSS语法\"></a><strong>CSS语法</strong></h2><ul>\n<li>样式语法<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">选择器&#123;</span><br><span class=\"line\"> 属性名：属性值;</span><br><span class=\"line\"> <span class=\"comment\">/*注释*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>@语法<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@charset &quot;UTF-8&quot;; //告诉浏览器用UTF-8的编码方式解析；必须放在第一行；</span><br><span class=\"line\">@import url(style.css); //从外部引入CSS样式；</span><br><span class=\"line\"><span class=\"keyword\">@media</span> (<span class=\"attribute\">min-width:</span><span class=\"number\">100px</span>) <span class=\"keyword\">and</span> (<span class=\"attribute\">max-width:</span><span class=\"number\">200px</span>)&#123;</span><br><span class=\"line\">   样式语法</span><br><span class=\"line\">&#125; //当设备的最小宽度为100px,最大宽度为200px时，才会执行。</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"如何调试\"><a href=\"#如何调试\" class=\"headerlink\" title=\"如何调试\"></a><strong>如何调试</strong></h2><ul>\n<li>Border调试法<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">border</span><span class=\"selector-pseudo\">:1px</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">red</span>;</span><br></pre></td></tr></table></figure>\n怀疑某个元素有问题，就给这个元素加个border，border没有出现，说明选择器错了或者语法错了，border出现了，看看边界是否符合预期。</li>\n</ul>\n<h2 id=\"在哪查资料\"><a href=\"#在哪查资料\" class=\"headerlink\" title=\"在哪查资料\"></a><strong>在哪查资料</strong></h2><ul>\n<li>Google搜索关键词时加MDN</li>\n<li>CSS tricks <a href=\"https://css-tricks.com/\">https://css-tricks.com/</a></li>\n<li>张鑫旭的博客</li>\n</ul>\n<h2 id=\"CSS文档流\"><a href=\"#CSS文档流\" class=\"headerlink\" title=\"CSS文档流\"></a><strong>CSS文档流</strong></h2><div align=\"center\" ><img src=\"./img/1.png\"></div>\n\n<ul>\n<li>流动方向<br><code>inline</code>元素从左到右，达到最右才会换行<br><code>block</code>元素从上到下，每一个都另起一行<br><code>inline-block</code>元素从左到右，但是都是以块的形式存在，不会分离</li>\n</ul>\n<h2 id=\"元素的高度和宽度\"><a href=\"#元素的高度和宽度\" class=\"headerlink\" title=\"元素的高度和宽度\"></a><strong>元素的高度和宽度</strong></h2><div align=\"center\" ><img src=\"./img/3.png\"></div>\n\n<p>元素不分是内联还是块级元素，可以通过<code>display</code>来设置元素是块级元素还是内联元素。</p>\n<ul>\n<li><p>宽度<br><code>inline</code>元素的宽度为内部<code>inline</code>元素的和，不能用宽度来指定，可以由<code>padding</code>来把宽度撑开。<br><code>block</code>元素默认自动计算宽度，默认是占满一行，但不是100%,但是不建议写宽度100%，可以由<code>width</code>来指定。<br><code>inline-block</code>元素，默认宽度是有里面的内容来决定，但是也可以由<code>width</code>来指定。</p>\n</li>\n<li><p>高度<br><code>inline</code>元素高度由<code>line-height</code>间接决定的，跟<code>height</code>无关。虽然可以通过padding来把inline元素撑开，但那不是它的高度，而是他的可视高地。<br><code>block</code>元素高度由内部文档流元素觉得，可以通过<code>height</code>来设定<br><code>inline-block</code>跟block类似，可以通过<code>height</code>来设定</p>\n</li>\n</ul>\n<h2 id=\"overflow溢出\"><a href=\"#overflow溢出\" class=\"headerlink\" title=\"overflow溢出\"></a><strong>overflow溢出</strong></h2><ul>\n<li>当内容的宽度和高度大于容器的时候，会溢出容器。可以通过overflow来设置是否显示滚动条。<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">overflow:auto // 只有当文字溢出的时候，才会显示，不溢出就不会显示。</span><br><span class=\"line\">overflow:scroll // 不管是否溢出，都显示滚动条。</span><br><span class=\"line\">overflow:hidden // 直接隐藏溢出部分 </span><br><span class=\"line\">overflow:visible //默认设置，会显示溢出部分</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"盒模型\"><a href=\"#盒模型\" class=\"headerlink\" title=\"盒模型\"></a><strong>盒模型</strong></h2><div align=\"center\" ><img src=\"./img/4.png\"></div>\n* 盒模型有两种，一种是content盒模型/内容盒模型 ； 一种是border盒模型/边框盒模型。\ncontent盒模型-内容就是盒子的边界。\nborder盒模型-边框才是盒子的边界。\n\n<ul>\n<li>公式<br>content-box width/height = 内容的宽度<br>border-box width/height = 内容宽度 + padding + border</li>\n</ul>\n<h2 id=\"margin合并\"><a href=\"#margin合并\" class=\"headerlink\" title=\"margin合并\"></a><strong>margin合并</strong></h2><ul>\n<li>哪些情况会发送<code>margin</code>合并<br>父子<code>margin</code>合并<br>兄弟元素<code>margin</code>合并</li>\n</ul>\n<ul>\n<li>如何组织<code>margin</code>合并<br>父子合并用<code>padding</code>/<code>border</code>挡住<br>父子合并用<code>overflow:hidden</code>挡住<br>父子合并用<code>display:flex</code><br>兄弟合并用<code>inline-block</code>消除</li>\n</ul>\n<h2 id=\"基本单位\"><a href=\"#基本单位\" class=\"headerlink\" title=\"基本单位\"></a><strong>基本单位</strong></h2><ul>\n<li><p>长度单位<br>px  像素<br>em  相对于自身font-size的倍数<br>%<br>整数</p>\n</li>\n<li><p>颜色<br>十六进制#FF6600 或者 #F60<br>RGBA颜色rgb(0,0.0)或者rgba(0,0,0,1) rgba最后的1，表示透明度，1代表不透明，0代表完全透明</p>\n</li>\n</ul>\n<p>资源来源:饥人谷</p>"},{"title":"CSS布局","date":"2020-09-29T18:29:46.000Z","toc":true,"cover":"./img/csslayout.jpg","_content":"## __布局是什么__\n* 把页面分成一块一块的，按左中右，上中下排列\n\n## __布局分类__\n1. 固定宽度布局，一般宽度为960px/1000px/1024px\n2. 不固定宽度布局，主要靠文档流的原理来布局\n3. 响应式布局，意思就是pc上固定宽度，手机上不固定宽度。是一种混合型的布局。\n<!--more-->\n\n## __布局思路__\n<div align=\"center\"><img src=\"./img/1.png\"></div>\n\n## __float布局__\n* float布局会让元素脱离文档流。\n* 在子元素上加上`float:left/right` \n* 因为float让元素脱离了文档流，父元素就“包不住”子元素，为了避免异常发生，所以父元素上需要清除浮动。\n```css\n.clear{\n content:\"\";\n display:block;\n both:clear;\n}\n```\n把`clear`这个类名加到父元素的类上，就可以清除浮动。\n\n## __负margin__\n在做平均布局的时候，最后一个元素的margin-right生效，因为空间不够，会把最后一个元素挤到下一排，现在我们可以用一个容器把元素包起来，然后在设置负margin，就可以让最后一个元素不被挤到下一排。因为正数的margin会让元素移动，但是如果margin的值是负数的话，就会让元素让css读取的空间增加。\n\n## __:nth-child()选择器__\n平均布局除了可以用负margin来解决，也可以用`:nth-child()`选择器，来解决，可以选择到最后一个元素的margin-right为0，来解决被到下一排的问题\n```html\n.parent div:nth-child(5){\n   margin-right:0px;\n}\n<div class='paretn'>\n  <div>1</div>\n  <div>2</div>\n  <div>3</div>\n  <div>4</div>\n  <div>5</div>\n</div>\n```\n## __flex布局__\nFlex是`Flexble Box`的缩写，意为'弹性盒子'，用来为盒模型提供最大的灵活性。\n任何一个容器都可以指定为flex布局\n```css\n.box{\n  display:flex;\n}\n```\n行内元素也可以使用flex布局\n```css\n.box{\n  display:inline-flex;\n}\n```\n设置为flex的元素，子元素`float`、`clear`、`vertical-align`属性就会失效。\n\n采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"。\n\n### __容器的属性__\n```css\nflex-direction  //决定项目的排列方向\nflex-wrap  // 怎么样换行,默认情况下，元素都会在一行，不会换行\nflex-flow  // flex-direction和flex-wrap的缩写\njustify-content // 主轴的对齐方式\nalign-items // 定义项目在交叉轴(垂直)上如何对齐\nalign-content // 多行内容，如何排列\n```\n### __flex-direction__\n决定主轴的方向，即项目的排列方向\n<div align=\"center\"><img src=\"./img/2.png\"></div>\n```css\n.box{\n flex-direction:row | row-reverse | column | column-reverse\n}\n```\n\n`row`(默认值)：主轴为水平方向，起点在左端\n`row-reverse`: 主轴为水平方向，起点在右端\n`column`:主轴垂直方向，起点在上沿\n`column-reverse`：主轴为垂直方向，起点在下沿\n\n\n### __flex-wrap__\n默认情况下，项目都会排在一条线上，`flex-wrap`定义，如果一条线上排不下，是否换行。\n\n<div align='center'><img src='./img/3.png'></div>\n\n```css\n.box{\nflex-wrap: nowrap | wrap | wrap-reverse;\n}\n```\n\n`nowrap` 默认属性，默认情况不管多少元素都是排在一行\n`wrap` 换行，空间不够就换行\n`wrap-reverse` 也是换行，不过是反过来的\n\n### __flex-flow__\n`flex-flow`属性是`flex-direction`和`flex-wrap`属性的缩写形式，默认值为`row  nowrap`。\n```css\n.box{\nflex-flow: <flex-direction> || <flex-wrap>;\n}\n```\n\n### __justify-content__\n`justify-content`定义项目在主轴上的对齐方式。\n```css\n.box{\njustify-content: flex-start | flex-end | center | space-between | space-around|\n}\n```\n<div align='center'><img src='./img/4.png'></div>\n\n`flex-start` 默认值，左对齐\n`flex-end` 右对齐\n`center` 居中\n`space-between` 两端对齐，项目之间的空间都相等\n`space-around` 每个项目两侧间隔都相等。\n`space-evenly` 每个项目之间的距离都是相等的.\n### __align-items__\n`align-items`属性定义项目在垂直方向上如何对齐。\n```css\n.box{\nalign-items: flex-start | flex-end | ceneten | baseline | stretch；\n}\n```\n<div align='center'><img src='./img/5.png'></div>\n\n`flex-start` 垂直的起点对齐\n`flex-end`垂直方向的重点对齐\n`center`垂直方向的中点对齐\n`baseline`项目的第一行文字的基线对齐\n`stretch`默认值，如果项目没有设置高度，将占满容器的高度\n\n### __align-content__\n`align-content`属性定义多跟轴线对齐方式，如果只有一跟轴线改属性不起作用。\n```css\n.box{\nalign-content: flex-start | flex-end | center | space-between | space-around | stretch |\n}\n```\n\n<div align='center'><img src='./img/6.png'></div>\n\n`flex-start`与交叉轴的起点对齐\n`flex-end`与交叉轴的终点对齐\n`center`与交叉的中点对齐\n`space-between`\t与交叉轴两端对齐，轴线之间的间隔平均分布\n`space-around` 每跟轴线两侧间隔都相等\n`stretch`轴线占满整个交叉轴，默认值\n\n### __项目属性__\n### __order__\n定义项目的排列顺序，数值越大，排列越靠前，默认为0\n```css\n.item{\norder:<整数>\n}\n```\n<div align='center'><img src='./img/7.png'></div>\n\n### __flex-grow__\n定义项目的放大比例，默认为0，就是如果存在剩余空间，也不放大。\n```css\n.item{\nflex-grow:<数字>\n}\n```\n<div align='center'><img src='./img/8.png'></div>\n\n如果所有项目的`flex-grow`属性都为1，则他们将等分剩余空间。如果一个项目的`flex-grow`属性为2，其他项目都为1，则前者占据的剩余空间将比其他项目多一倍\n\n### __flex-shrink__\n`flex-shrink`定义了项目缩小的比例，默认是1即如果空间不足，项目将怎么缩小。\n```css\n.item{\nflex-shrink:<数字>\n}\n```\n<div align='center'><img src='./img/9.png'></div>\n\n如果所有项目的`flex-shrink`属性都为1，当空间不足时，都将等比例缩小，如果一个项目的`flex-shrink`属性为0，其他项目为1，则空间缩小的时候，前者不缩小。\n\n### __flex-basis__\n定义了在分配多余空间之前，项目占据主轴空间，浏览器根据这个属性，计算主轴是否有多余空间，它的默认值为0，即项目的本来大小。\n\n### __flex__\n`flex`属性是`flex-grow`,`flex-shrink`和`flex-basis`的缩写\n\n### __align-self__\n`align-self`属性允许单个项目与其他项目不一样的对齐方式，可以覆盖`align-items`属性\n<div align='center'><img src='./img/10.png'></div>\n\n\n资料参考：\n阮一峰flex布局教程：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\n饥人谷\n\n\n","source":"_posts/CSS布局.md","raw":"---\ntitle: CSS布局\ndate: 2020-09-29 18:29:46\ntags: CSS\ntoc: true\ncover: ./img/csslayout.jpg\n---\n## __布局是什么__\n* 把页面分成一块一块的，按左中右，上中下排列\n\n## __布局分类__\n1. 固定宽度布局，一般宽度为960px/1000px/1024px\n2. 不固定宽度布局，主要靠文档流的原理来布局\n3. 响应式布局，意思就是pc上固定宽度，手机上不固定宽度。是一种混合型的布局。\n<!--more-->\n\n## __布局思路__\n<div align=\"center\"><img src=\"./img/1.png\"></div>\n\n## __float布局__\n* float布局会让元素脱离文档流。\n* 在子元素上加上`float:left/right` \n* 因为float让元素脱离了文档流，父元素就“包不住”子元素，为了避免异常发生，所以父元素上需要清除浮动。\n```css\n.clear{\n content:\"\";\n display:block;\n both:clear;\n}\n```\n把`clear`这个类名加到父元素的类上，就可以清除浮动。\n\n## __负margin__\n在做平均布局的时候，最后一个元素的margin-right生效，因为空间不够，会把最后一个元素挤到下一排，现在我们可以用一个容器把元素包起来，然后在设置负margin，就可以让最后一个元素不被挤到下一排。因为正数的margin会让元素移动，但是如果margin的值是负数的话，就会让元素让css读取的空间增加。\n\n## __:nth-child()选择器__\n平均布局除了可以用负margin来解决，也可以用`:nth-child()`选择器，来解决，可以选择到最后一个元素的margin-right为0，来解决被到下一排的问题\n```html\n.parent div:nth-child(5){\n   margin-right:0px;\n}\n<div class='paretn'>\n  <div>1</div>\n  <div>2</div>\n  <div>3</div>\n  <div>4</div>\n  <div>5</div>\n</div>\n```\n## __flex布局__\nFlex是`Flexble Box`的缩写，意为'弹性盒子'，用来为盒模型提供最大的灵活性。\n任何一个容器都可以指定为flex布局\n```css\n.box{\n  display:flex;\n}\n```\n行内元素也可以使用flex布局\n```css\n.box{\n  display:inline-flex;\n}\n```\n设置为flex的元素，子元素`float`、`clear`、`vertical-align`属性就会失效。\n\n采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"。\n\n### __容器的属性__\n```css\nflex-direction  //决定项目的排列方向\nflex-wrap  // 怎么样换行,默认情况下，元素都会在一行，不会换行\nflex-flow  // flex-direction和flex-wrap的缩写\njustify-content // 主轴的对齐方式\nalign-items // 定义项目在交叉轴(垂直)上如何对齐\nalign-content // 多行内容，如何排列\n```\n### __flex-direction__\n决定主轴的方向，即项目的排列方向\n<div align=\"center\"><img src=\"./img/2.png\"></div>\n```css\n.box{\n flex-direction:row | row-reverse | column | column-reverse\n}\n```\n\n`row`(默认值)：主轴为水平方向，起点在左端\n`row-reverse`: 主轴为水平方向，起点在右端\n`column`:主轴垂直方向，起点在上沿\n`column-reverse`：主轴为垂直方向，起点在下沿\n\n\n### __flex-wrap__\n默认情况下，项目都会排在一条线上，`flex-wrap`定义，如果一条线上排不下，是否换行。\n\n<div align='center'><img src='./img/3.png'></div>\n\n```css\n.box{\nflex-wrap: nowrap | wrap | wrap-reverse;\n}\n```\n\n`nowrap` 默认属性，默认情况不管多少元素都是排在一行\n`wrap` 换行，空间不够就换行\n`wrap-reverse` 也是换行，不过是反过来的\n\n### __flex-flow__\n`flex-flow`属性是`flex-direction`和`flex-wrap`属性的缩写形式，默认值为`row  nowrap`。\n```css\n.box{\nflex-flow: <flex-direction> || <flex-wrap>;\n}\n```\n\n### __justify-content__\n`justify-content`定义项目在主轴上的对齐方式。\n```css\n.box{\njustify-content: flex-start | flex-end | center | space-between | space-around|\n}\n```\n<div align='center'><img src='./img/4.png'></div>\n\n`flex-start` 默认值，左对齐\n`flex-end` 右对齐\n`center` 居中\n`space-between` 两端对齐，项目之间的空间都相等\n`space-around` 每个项目两侧间隔都相等。\n`space-evenly` 每个项目之间的距离都是相等的.\n### __align-items__\n`align-items`属性定义项目在垂直方向上如何对齐。\n```css\n.box{\nalign-items: flex-start | flex-end | ceneten | baseline | stretch；\n}\n```\n<div align='center'><img src='./img/5.png'></div>\n\n`flex-start` 垂直的起点对齐\n`flex-end`垂直方向的重点对齐\n`center`垂直方向的中点对齐\n`baseline`项目的第一行文字的基线对齐\n`stretch`默认值，如果项目没有设置高度，将占满容器的高度\n\n### __align-content__\n`align-content`属性定义多跟轴线对齐方式，如果只有一跟轴线改属性不起作用。\n```css\n.box{\nalign-content: flex-start | flex-end | center | space-between | space-around | stretch |\n}\n```\n\n<div align='center'><img src='./img/6.png'></div>\n\n`flex-start`与交叉轴的起点对齐\n`flex-end`与交叉轴的终点对齐\n`center`与交叉的中点对齐\n`space-between`\t与交叉轴两端对齐，轴线之间的间隔平均分布\n`space-around` 每跟轴线两侧间隔都相等\n`stretch`轴线占满整个交叉轴，默认值\n\n### __项目属性__\n### __order__\n定义项目的排列顺序，数值越大，排列越靠前，默认为0\n```css\n.item{\norder:<整数>\n}\n```\n<div align='center'><img src='./img/7.png'></div>\n\n### __flex-grow__\n定义项目的放大比例，默认为0，就是如果存在剩余空间，也不放大。\n```css\n.item{\nflex-grow:<数字>\n}\n```\n<div align='center'><img src='./img/8.png'></div>\n\n如果所有项目的`flex-grow`属性都为1，则他们将等分剩余空间。如果一个项目的`flex-grow`属性为2，其他项目都为1，则前者占据的剩余空间将比其他项目多一倍\n\n### __flex-shrink__\n`flex-shrink`定义了项目缩小的比例，默认是1即如果空间不足，项目将怎么缩小。\n```css\n.item{\nflex-shrink:<数字>\n}\n```\n<div align='center'><img src='./img/9.png'></div>\n\n如果所有项目的`flex-shrink`属性都为1，当空间不足时，都将等比例缩小，如果一个项目的`flex-shrink`属性为0，其他项目为1，则空间缩小的时候，前者不缩小。\n\n### __flex-basis__\n定义了在分配多余空间之前，项目占据主轴空间，浏览器根据这个属性，计算主轴是否有多余空间，它的默认值为0，即项目的本来大小。\n\n### __flex__\n`flex`属性是`flex-grow`,`flex-shrink`和`flex-basis`的缩写\n\n### __align-self__\n`align-self`属性允许单个项目与其他项目不一样的对齐方式，可以覆盖`align-items`属性\n<div align='center'><img src='./img/10.png'></div>\n\n\n资料参考：\n阮一峰flex布局教程：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\n饥人谷\n\n\n","slug":"CSS布局","published":1,"updated":"2020-09-30T18:26:42.070Z","_id":"ckfoav38z00007yfqbht7hr7v","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"布局是什么\"><a href=\"#布局是什么\" class=\"headerlink\" title=\"布局是什么\"></a><strong>布局是什么</strong></h2><ul>\n<li>把页面分成一块一块的，按左中右，上中下排列</li>\n</ul>\n<h2 id=\"布局分类\"><a href=\"#布局分类\" class=\"headerlink\" title=\"布局分类\"></a><strong>布局分类</strong></h2><ol>\n<li>固定宽度布局，一般宽度为960px/1000px/1024px</li>\n<li>不固定宽度布局，主要靠文档流的原理来布局</li>\n<li>响应式布局，意思就是pc上固定宽度，手机上不固定宽度。是一种混合型的布局。<a id=\"more\"></a>\n\n</li>\n</ol>\n<h2 id=\"布局思路\"><a href=\"#布局思路\" class=\"headerlink\" title=\"布局思路\"></a><strong>布局思路</strong></h2><div align=\"center\"><img src=\"./img/1.png\"></div>\n\n<h2 id=\"float布局\"><a href=\"#float布局\" class=\"headerlink\" title=\"float布局\"></a><strong>float布局</strong></h2><ul>\n<li>float布局会让元素脱离文档流。</li>\n<li>在子元素上加上<code>float:left/right</code> </li>\n<li>因为float让元素脱离了文档流，父元素就“包不住”子元素，为了避免异常发生，所以父元素上需要清除浮动。<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.clear</span>&#123;</span><br><span class=\"line\"> <span class=\"attribute\">content</span>:<span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"> <span class=\"attribute\">display</span>:block;</span><br><span class=\"line\"> <span class=\"attribute\">both</span>:clear;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n把<code>clear</code>这个类名加到父元素的类上，就可以清除浮动。</li>\n</ul>\n<h2 id=\"负margin\"><a href=\"#负margin\" class=\"headerlink\" title=\"负margin\"></a><strong>负margin</strong></h2><p>在做平均布局的时候，最后一个元素的margin-right生效，因为空间不够，会把最后一个元素挤到下一排，现在我们可以用一个容器把元素包起来，然后在设置负margin，就可以让最后一个元素不被挤到下一排。因为正数的margin会让元素移动，但是如果margin的值是负数的话，就会让元素让css读取的空间增加。</p>\n<h2 id=\"nth-child-选择器\"><a href=\"#nth-child-选择器\" class=\"headerlink\" title=\":nth-child()选择器\"></a><strong>:nth-child()选择器</strong></h2><p>平均布局除了可以用负margin来解决，也可以用<code>:nth-child()</code>选择器，来解决，可以选择到最后一个元素的margin-right为0，来解决被到下一排的问题</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.parent div:nth-child(5)&#123;</span><br><span class=\"line\">   margin-right:0px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;paretn&#x27;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>4<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>5<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"flex布局\"><a href=\"#flex布局\" class=\"headerlink\" title=\"flex布局\"></a><strong>flex布局</strong></h2><p>Flex是<code>Flexble Box</code>的缩写，意为’弹性盒子’，用来为盒模型提供最大的灵活性。<br>任何一个容器都可以指定为flex布局</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>:flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>行内元素也可以使用flex布局</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>:inline-flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>设置为flex的元素，子元素<code>float</code>、<code>clear</code>、<code>vertical-align</code>属性就会失效。</p>\n<p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p>\n<h3 id=\"容器的属性\"><a href=\"#容器的属性\" class=\"headerlink\" title=\"容器的属性\"></a><strong>容器的属性</strong></h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flex-direction  //决定项目的排列方向</span><br><span class=\"line\">flex-wrap  // 怎么样换行,默认情况下，元素都会在一行，不会换行</span><br><span class=\"line\">flex-flow  // flex-direction和flex-wrap的缩写</span><br><span class=\"line\">justify-content // 主轴的对齐方式</span><br><span class=\"line\">align-items // 定义项目在交叉轴(垂直)上如何对齐</span><br><span class=\"line\">align-content // 多行内容，如何排列</span><br></pre></td></tr></table></figure>\n<h3 id=\"flex-direction\"><a href=\"#flex-direction\" class=\"headerlink\" title=\"flex-direction\"></a><strong>flex-direction</strong></h3><p>决定主轴的方向，即项目的排列方向</p>\n<div align=\"center\"><img src=\"./img/2.png\"></div>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\"> <span class=\"attribute\">flex-direction</span>:row | row-reverse | column | column-reverse</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>row</code>(默认值)：主轴为水平方向，起点在左端<br><code>row-reverse</code>: 主轴为水平方向，起点在右端<br><code>column</code>:主轴垂直方向，起点在上沿<br><code>column-reverse</code>：主轴为垂直方向，起点在下沿</p>\n<h3 id=\"flex-wrap\"><a href=\"#flex-wrap\" class=\"headerlink\" title=\"flex-wrap\"></a><strong>flex-wrap</strong></h3><p>默认情况下，项目都会排在一条线上，<code>flex-wrap</code>定义，如果一条线上排不下，是否换行。</p>\n<div align='center'><img src='./img/3.png'></div>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>nowrap</code> 默认属性，默认情况不管多少元素都是排在一行<br><code>wrap</code> 换行，空间不够就换行<br><code>wrap-reverse</code> 也是换行，不过是反过来的</p>\n<h3 id=\"flex-flow\"><a href=\"#flex-flow\" class=\"headerlink\" title=\"flex-flow\"></a><strong>flex-flow</strong></h3><p><code>flex-flow</code>属性是<code>flex-direction</code>和<code>flex-wrap</code>属性的缩写形式，默认值为<code>row  nowrap</code>。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"justify-content\"><a href=\"#justify-content\" class=\"headerlink\" title=\"justify-content\"></a><strong>justify-content</strong></h3><p><code>justify-content</code>定义项目在主轴上的对齐方式。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">justify-content</span>: flex-start | flex-end | center | space-between | space-around|</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div align='center'><img src='./img/4.png'></div>\n\n<p><code>flex-start</code> 默认值，左对齐<br><code>flex-end</code> 右对齐<br><code>center</code> 居中<br><code>space-between</code> 两端对齐，项目之间的空间都相等<br><code>space-around</code> 每个项目两侧间隔都相等。<br><code>space-evenly</code> 每个项目之间的距离都是相等的.</p>\n<h3 id=\"align-items\"><a href=\"#align-items\" class=\"headerlink\" title=\"align-items\"></a><strong>align-items</strong></h3><p><code>align-items</code>属性定义项目在垂直方向上如何对齐。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">align-items</span>: flex-start | flex-end | ceneten | baseline | stretch；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div align='center'><img src='./img/5.png'></div>\n\n<p><code>flex-start</code> 垂直的起点对齐<br><code>flex-end</code>垂直方向的重点对齐<br><code>center</code>垂直方向的中点对齐<br><code>baseline</code>项目的第一行文字的基线对齐<br><code>stretch</code>默认值，如果项目没有设置高度，将占满容器的高度</p>\n<h3 id=\"align-content\"><a href=\"#align-content\" class=\"headerlink\" title=\"align-content\"></a><strong>align-content</strong></h3><p><code>align-content</code>属性定义多跟轴线对齐方式，如果只有一跟轴线改属性不起作用。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch |</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<div align='center'><img src='./img/6.png'></div>\n\n<p><code>flex-start</code>与交叉轴的起点对齐<br><code>flex-end</code>与交叉轴的终点对齐<br><code>center</code>与交叉的中点对齐<br><code>space-between</code>    与交叉轴两端对齐，轴线之间的间隔平均分布<br><code>space-around</code> 每跟轴线两侧间隔都相等<br><code>stretch</code>轴线占满整个交叉轴，默认值</p>\n<h3 id=\"项目属性\"><a href=\"#项目属性\" class=\"headerlink\" title=\"项目属性\"></a><strong>项目属性</strong></h3><h3 id=\"order\"><a href=\"#order\" class=\"headerlink\" title=\"order\"></a><strong>order</strong></h3><p>定义项目的排列顺序，数值越大，排列越靠前，默认为0</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">order</span>:&lt;整数&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div align='center'><img src='./img/7.png'></div>\n\n<h3 id=\"flex-grow\"><a href=\"#flex-grow\" class=\"headerlink\" title=\"flex-grow\"></a><strong>flex-grow</strong></h3><p>定义项目的放大比例，默认为0，就是如果存在剩余空间，也不放大。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">flex-grow</span>:&lt;数字&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div align='center'><img src='./img/8.png'></div>\n\n<p>如果所有项目的<code>flex-grow</code>属性都为1，则他们将等分剩余空间。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项目多一倍</p>\n<h3 id=\"flex-shrink\"><a href=\"#flex-shrink\" class=\"headerlink\" title=\"flex-shrink\"></a><strong>flex-shrink</strong></h3><p><code>flex-shrink</code>定义了项目缩小的比例，默认是1即如果空间不足，项目将怎么缩小。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">flex-shrink</span>:&lt;数字&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div align='center'><img src='./img/9.png'></div>\n\n<p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小，如果一个项目的<code>flex-shrink</code>属性为0，其他项目为1，则空间缩小的时候，前者不缩小。</p>\n<h3 id=\"flex-basis\"><a href=\"#flex-basis\" class=\"headerlink\" title=\"flex-basis\"></a><strong>flex-basis</strong></h3><p>定义了在分配多余空间之前，项目占据主轴空间，浏览器根据这个属性，计算主轴是否有多余空间，它的默认值为0，即项目的本来大小。</p>\n<h3 id=\"flex\"><a href=\"#flex\" class=\"headerlink\" title=\"flex\"></a><strong>flex</strong></h3><p><code>flex</code>属性是<code>flex-grow</code>,<code>flex-shrink</code>和<code>flex-basis</code>的缩写</p>\n<h3 id=\"align-self\"><a href=\"#align-self\" class=\"headerlink\" title=\"align-self\"></a><strong>align-self</strong></h3><p><code>align-self</code>属性允许单个项目与其他项目不一样的对齐方式，可以覆盖<code>align-items</code>属性</p>\n<div align='center'><img src='./img/10.png'></div>\n\n\n<p>资料参考：<br>阮一峰flex布局教程：<a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a><br>饥人谷</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"布局是什么\"><a href=\"#布局是什么\" class=\"headerlink\" title=\"布局是什么\"></a><strong>布局是什么</strong></h2><ul>\n<li>把页面分成一块一块的，按左中右，上中下排列</li>\n</ul>\n<h2 id=\"布局分类\"><a href=\"#布局分类\" class=\"headerlink\" title=\"布局分类\"></a><strong>布局分类</strong></h2><ol>\n<li>固定宽度布局，一般宽度为960px/1000px/1024px</li>\n<li>不固定宽度布局，主要靠文档流的原理来布局</li>\n<li>响应式布局，意思就是pc上固定宽度，手机上不固定宽度。是一种混合型的布局。","more":"</li>\n</ol>\n<h2 id=\"布局思路\"><a href=\"#布局思路\" class=\"headerlink\" title=\"布局思路\"></a><strong>布局思路</strong></h2><div align=\"center\"><img src=\"./img/1.png\"></div>\n\n<h2 id=\"float布局\"><a href=\"#float布局\" class=\"headerlink\" title=\"float布局\"></a><strong>float布局</strong></h2><ul>\n<li>float布局会让元素脱离文档流。</li>\n<li>在子元素上加上<code>float:left/right</code> </li>\n<li>因为float让元素脱离了文档流，父元素就“包不住”子元素，为了避免异常发生，所以父元素上需要清除浮动。<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.clear</span>&#123;</span><br><span class=\"line\"> <span class=\"attribute\">content</span>:<span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"> <span class=\"attribute\">display</span>:block;</span><br><span class=\"line\"> <span class=\"attribute\">both</span>:clear;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n把<code>clear</code>这个类名加到父元素的类上，就可以清除浮动。</li>\n</ul>\n<h2 id=\"负margin\"><a href=\"#负margin\" class=\"headerlink\" title=\"负margin\"></a><strong>负margin</strong></h2><p>在做平均布局的时候，最后一个元素的margin-right生效，因为空间不够，会把最后一个元素挤到下一排，现在我们可以用一个容器把元素包起来，然后在设置负margin，就可以让最后一个元素不被挤到下一排。因为正数的margin会让元素移动，但是如果margin的值是负数的话，就会让元素让css读取的空间增加。</p>\n<h2 id=\"nth-child-选择器\"><a href=\"#nth-child-选择器\" class=\"headerlink\" title=\":nth-child()选择器\"></a><strong>:nth-child()选择器</strong></h2><p>平均布局除了可以用负margin来解决，也可以用<code>:nth-child()</code>选择器，来解决，可以选择到最后一个元素的margin-right为0，来解决被到下一排的问题</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.parent div:nth-child(5)&#123;</span><br><span class=\"line\">   margin-right:0px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;paretn&#x27;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>4<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>5<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"flex布局\"><a href=\"#flex布局\" class=\"headerlink\" title=\"flex布局\"></a><strong>flex布局</strong></h2><p>Flex是<code>Flexble Box</code>的缩写，意为’弹性盒子’，用来为盒模型提供最大的灵活性。<br>任何一个容器都可以指定为flex布局</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>:flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>行内元素也可以使用flex布局</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>:inline-flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>设置为flex的元素，子元素<code>float</code>、<code>clear</code>、<code>vertical-align</code>属性就会失效。</p>\n<p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p>\n<h3 id=\"容器的属性\"><a href=\"#容器的属性\" class=\"headerlink\" title=\"容器的属性\"></a><strong>容器的属性</strong></h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flex-direction  //决定项目的排列方向</span><br><span class=\"line\">flex-wrap  // 怎么样换行,默认情况下，元素都会在一行，不会换行</span><br><span class=\"line\">flex-flow  // flex-direction和flex-wrap的缩写</span><br><span class=\"line\">justify-content // 主轴的对齐方式</span><br><span class=\"line\">align-items // 定义项目在交叉轴(垂直)上如何对齐</span><br><span class=\"line\">align-content // 多行内容，如何排列</span><br></pre></td></tr></table></figure>\n<h3 id=\"flex-direction\"><a href=\"#flex-direction\" class=\"headerlink\" title=\"flex-direction\"></a><strong>flex-direction</strong></h3><p>决定主轴的方向，即项目的排列方向</p>\n<div align=\"center\"><img src=\"./img/2.png\"></div>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\"> <span class=\"attribute\">flex-direction</span>:row | row-reverse | column | column-reverse</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>row</code>(默认值)：主轴为水平方向，起点在左端<br><code>row-reverse</code>: 主轴为水平方向，起点在右端<br><code>column</code>:主轴垂直方向，起点在上沿<br><code>column-reverse</code>：主轴为垂直方向，起点在下沿</p>\n<h3 id=\"flex-wrap\"><a href=\"#flex-wrap\" class=\"headerlink\" title=\"flex-wrap\"></a><strong>flex-wrap</strong></h3><p>默认情况下，项目都会排在一条线上，<code>flex-wrap</code>定义，如果一条线上排不下，是否换行。</p>\n<div align='center'><img src='./img/3.png'></div>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>nowrap</code> 默认属性，默认情况不管多少元素都是排在一行<br><code>wrap</code> 换行，空间不够就换行<br><code>wrap-reverse</code> 也是换行，不过是反过来的</p>\n<h3 id=\"flex-flow\"><a href=\"#flex-flow\" class=\"headerlink\" title=\"flex-flow\"></a><strong>flex-flow</strong></h3><p><code>flex-flow</code>属性是<code>flex-direction</code>和<code>flex-wrap</code>属性的缩写形式，默认值为<code>row  nowrap</code>。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"justify-content\"><a href=\"#justify-content\" class=\"headerlink\" title=\"justify-content\"></a><strong>justify-content</strong></h3><p><code>justify-content</code>定义项目在主轴上的对齐方式。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">justify-content</span>: flex-start | flex-end | center | space-between | space-around|</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div align='center'><img src='./img/4.png'></div>\n\n<p><code>flex-start</code> 默认值，左对齐<br><code>flex-end</code> 右对齐<br><code>center</code> 居中<br><code>space-between</code> 两端对齐，项目之间的空间都相等<br><code>space-around</code> 每个项目两侧间隔都相等。<br><code>space-evenly</code> 每个项目之间的距离都是相等的.</p>\n<h3 id=\"align-items\"><a href=\"#align-items\" class=\"headerlink\" title=\"align-items\"></a><strong>align-items</strong></h3><p><code>align-items</code>属性定义项目在垂直方向上如何对齐。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">align-items</span>: flex-start | flex-end | ceneten | baseline | stretch；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div align='center'><img src='./img/5.png'></div>\n\n<p><code>flex-start</code> 垂直的起点对齐<br><code>flex-end</code>垂直方向的重点对齐<br><code>center</code>垂直方向的中点对齐<br><code>baseline</code>项目的第一行文字的基线对齐<br><code>stretch</code>默认值，如果项目没有设置高度，将占满容器的高度</p>\n<h3 id=\"align-content\"><a href=\"#align-content\" class=\"headerlink\" title=\"align-content\"></a><strong>align-content</strong></h3><p><code>align-content</code>属性定义多跟轴线对齐方式，如果只有一跟轴线改属性不起作用。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch |</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<div align='center'><img src='./img/6.png'></div>\n\n<p><code>flex-start</code>与交叉轴的起点对齐<br><code>flex-end</code>与交叉轴的终点对齐<br><code>center</code>与交叉的中点对齐<br><code>space-between</code>    与交叉轴两端对齐，轴线之间的间隔平均分布<br><code>space-around</code> 每跟轴线两侧间隔都相等<br><code>stretch</code>轴线占满整个交叉轴，默认值</p>\n<h3 id=\"项目属性\"><a href=\"#项目属性\" class=\"headerlink\" title=\"项目属性\"></a><strong>项目属性</strong></h3><h3 id=\"order\"><a href=\"#order\" class=\"headerlink\" title=\"order\"></a><strong>order</strong></h3><p>定义项目的排列顺序，数值越大，排列越靠前，默认为0</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">order</span>:&lt;整数&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div align='center'><img src='./img/7.png'></div>\n\n<h3 id=\"flex-grow\"><a href=\"#flex-grow\" class=\"headerlink\" title=\"flex-grow\"></a><strong>flex-grow</strong></h3><p>定义项目的放大比例，默认为0，就是如果存在剩余空间，也不放大。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">flex-grow</span>:&lt;数字&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div align='center'><img src='./img/8.png'></div>\n\n<p>如果所有项目的<code>flex-grow</code>属性都为1，则他们将等分剩余空间。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项目多一倍</p>\n<h3 id=\"flex-shrink\"><a href=\"#flex-shrink\" class=\"headerlink\" title=\"flex-shrink\"></a><strong>flex-shrink</strong></h3><p><code>flex-shrink</code>定义了项目缩小的比例，默认是1即如果空间不足，项目将怎么缩小。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">flex-shrink</span>:&lt;数字&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div align='center'><img src='./img/9.png'></div>\n\n<p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小，如果一个项目的<code>flex-shrink</code>属性为0，其他项目为1，则空间缩小的时候，前者不缩小。</p>\n<h3 id=\"flex-basis\"><a href=\"#flex-basis\" class=\"headerlink\" title=\"flex-basis\"></a><strong>flex-basis</strong></h3><p>定义了在分配多余空间之前，项目占据主轴空间，浏览器根据这个属性，计算主轴是否有多余空间，它的默认值为0，即项目的本来大小。</p>\n<h3 id=\"flex\"><a href=\"#flex\" class=\"headerlink\" title=\"flex\"></a><strong>flex</strong></h3><p><code>flex</code>属性是<code>flex-grow</code>,<code>flex-shrink</code>和<code>flex-basis</code>的缩写</p>\n<h3 id=\"align-self\"><a href=\"#align-self\" class=\"headerlink\" title=\"align-self\"></a><strong>align-self</strong></h3><p><code>align-self</code>属性允许单个项目与其他项目不一样的对齐方式，可以覆盖<code>align-items</code>属性</p>\n<div align='center'><img src='./img/10.png'></div>\n\n\n<p>资料参考：<br>阮一峰flex布局教程：<a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a><br>饥人谷</p>"},{"title":"CSS定位","date":"2020-10-02T03:11:02.000Z","toc":true,"cover":"./img/cssposition.jpg","_content":"\n## __position的五个取值__\n`position`属性用来指定一个元素在网页上的位置。有以下五个属性值。\n* `static`\n* `relative`\n* `absolute`\n* `fixed`\n* `sticky`\n<!--more-->\n\n<font class=\"ff6666\">测速</font>\n\n### __static属性值__\n`static`静态的意思，是`position`的默认取值，如果省略`position`属性，浏览器就认为该元素是`static`定位。\n\n### __relative,absolute,fixed属性值__\n`relative` 、`absolute`、` fixed`这三个属性值有一个共同点，都是相对于某个<font color=#FF3333><b>基点</b></font>定位。不同之处仅仅在于<font color=#FF3333><b>基点</b></font>的不同。\n\n*  `relative`相对的意思，表示相对于默认的位置,即<font color=#FF6666><b>定位基点</b></font>就是元素默认的位置。不会脱离文档流。只是浮起来，原先的位置所占的空间还在文档流中。用于做位移和给`absolute`元素做父元素。\n\n\n* `absolute`绝对的意思，表示相对于离它最近的定位元素定位（必须是非static属性),即<font color=#FF6666><b>定位基点</b></font>是离它做最近的非定位元素。会脱离文档流，另起一层。`absolute`定位<font color=#FF3333><b>必须</b></font>就搭配`top`、`bottom`、`left`、`right`这四个属性里面的两个使用，不然有些浏览器会出现异常，用于做对话框的关闭按钮和鼠标提示。\n\n* `fixed`固定的意思,表达相对于视口(viewport，浏览器窗口)进行偏移，<font color=#FF6666><b>定位基点</b></font>是浏览器窗口，这会导致元素的位置不会随着页面滚动而变化，好像是固定在网页上某个位置一样。他如果搭配`top`、`bottom`、`left`、`right`这四个属性一起使用，表示元素的初始位置是基于视口计算的，否则初始位置就是元素的默认位置。\n\n### __sticky属性值__\n* `sticky`粘滞的意思。可以理解成`relative`和`fixed`的结合。正常时候是relative的属性，待在自己该在的位置。当页面滚动到设置了`sticky`的元素的时候，他就会根据设置top、bottom、left、right来进行定位，属性有点像`flex`。\n\n```css\nwhite-wrap:nowrap //让文章不换行\n```\n### __opacity与rgba的区别__\n`opactiy`会创建层叠上下文，而且会让整个元素包括子元素都变成透明。\n`rgba`不会创建层叠上下文，只会作用在该元素上，不会影响其他元素。\n\n\n\n\n资料参考：\n阮一峰CSS详解：http://www.ruanyifeng.com/blog/2019/11/css-position.html\n饥人谷\n\n\n(完)\n","source":"_posts/CSS定位.md","raw":"---\ntitle: CSS定位\ndate: 2020-10-02 03:11:02\ntags: CSS\ntoc: true\ncover: ./img/cssposition.jpg\n---\n\n## __position的五个取值__\n`position`属性用来指定一个元素在网页上的位置。有以下五个属性值。\n* `static`\n* `relative`\n* `absolute`\n* `fixed`\n* `sticky`\n<!--more-->\n\n<font class=\"ff6666\">测速</font>\n\n### __static属性值__\n`static`静态的意思，是`position`的默认取值，如果省略`position`属性，浏览器就认为该元素是`static`定位。\n\n### __relative,absolute,fixed属性值__\n`relative` 、`absolute`、` fixed`这三个属性值有一个共同点，都是相对于某个<font color=#FF3333><b>基点</b></font>定位。不同之处仅仅在于<font color=#FF3333><b>基点</b></font>的不同。\n\n*  `relative`相对的意思，表示相对于默认的位置,即<font color=#FF6666><b>定位基点</b></font>就是元素默认的位置。不会脱离文档流。只是浮起来，原先的位置所占的空间还在文档流中。用于做位移和给`absolute`元素做父元素。\n\n\n* `absolute`绝对的意思，表示相对于离它最近的定位元素定位（必须是非static属性),即<font color=#FF6666><b>定位基点</b></font>是离它做最近的非定位元素。会脱离文档流，另起一层。`absolute`定位<font color=#FF3333><b>必须</b></font>就搭配`top`、`bottom`、`left`、`right`这四个属性里面的两个使用，不然有些浏览器会出现异常，用于做对话框的关闭按钮和鼠标提示。\n\n* `fixed`固定的意思,表达相对于视口(viewport，浏览器窗口)进行偏移，<font color=#FF6666><b>定位基点</b></font>是浏览器窗口，这会导致元素的位置不会随着页面滚动而变化，好像是固定在网页上某个位置一样。他如果搭配`top`、`bottom`、`left`、`right`这四个属性一起使用，表示元素的初始位置是基于视口计算的，否则初始位置就是元素的默认位置。\n\n### __sticky属性值__\n* `sticky`粘滞的意思。可以理解成`relative`和`fixed`的结合。正常时候是relative的属性，待在自己该在的位置。当页面滚动到设置了`sticky`的元素的时候，他就会根据设置top、bottom、left、right来进行定位，属性有点像`flex`。\n\n```css\nwhite-wrap:nowrap //让文章不换行\n```\n### __opacity与rgba的区别__\n`opactiy`会创建层叠上下文，而且会让整个元素包括子元素都变成透明。\n`rgba`不会创建层叠上下文，只会作用在该元素上，不会影响其他元素。\n\n\n\n\n资料参考：\n阮一峰CSS详解：http://www.ruanyifeng.com/blog/2019/11/css-position.html\n饥人谷\n\n\n(完)\n","slug":"CSS定位","published":1,"updated":"2020-10-02T08:29:52.599Z","_id":"ckfrodsoe0000aufqc2pt3043","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"position的五个取值\"><a href=\"#position的五个取值\" class=\"headerlink\" title=\"position的五个取值\"></a><strong>position的五个取值</strong></h2><p><code>position</code>属性用来指定一个元素在网页上的位置。有以下五个属性值。</p>\n<ul>\n<li><code>static</code></li>\n<li><code>relative</code></li>\n<li><code>absolute</code></li>\n<li><code>fixed</code></li>\n<li><code>sticky</code><a id=\"more\"></a>\n\n</li>\n</ul>\n<p><font class=\"ff6666\">测速</font></p>\n<h3 id=\"static属性值\"><a href=\"#static属性值\" class=\"headerlink\" title=\"static属性值\"></a><strong>static属性值</strong></h3><p><code>static</code>静态的意思，是<code>position</code>的默认取值，如果省略<code>position</code>属性，浏览器就认为该元素是<code>static</code>定位。</p>\n<h3 id=\"relative-absolute-fixed属性值\"><a href=\"#relative-absolute-fixed属性值\" class=\"headerlink\" title=\"relative,absolute,fixed属性值\"></a><strong>relative,absolute,fixed属性值</strong></h3><p><code>relative</code> 、<code>absolute</code>、<code> fixed</code>这三个属性值有一个共同点，都是相对于某个<font color=#FF3333><b>基点</b></font>定位。不同之处仅仅在于<font color=#FF3333><b>基点</b></font>的不同。</p>\n<ul>\n<li><code>relative</code>相对的意思，表示相对于默认的位置,即<font color=#FF6666><b>定位基点</b></font>就是元素默认的位置。不会脱离文档流。只是浮起来，原先的位置所占的空间还在文档流中。用于做位移和给<code>absolute</code>元素做父元素。</li>\n</ul>\n<ul>\n<li><p><code>absolute</code>绝对的意思，表示相对于离它最近的定位元素定位（必须是非static属性),即<font color=#FF6666><b>定位基点</b></font>是离它做最近的非定位元素。会脱离文档流，另起一层。<code>absolute</code>定位<font color=#FF3333><b>必须</b></font>就搭配<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>这四个属性里面的两个使用，不然有些浏览器会出现异常，用于做对话框的关闭按钮和鼠标提示。</p>\n</li>\n<li><p><code>fixed</code>固定的意思,表达相对于视口(viewport，浏览器窗口)进行偏移，<font color=#FF6666><b>定位基点</b></font>是浏览器窗口，这会导致元素的位置不会随着页面滚动而变化，好像是固定在网页上某个位置一样。他如果搭配<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>这四个属性一起使用，表示元素的初始位置是基于视口计算的，否则初始位置就是元素的默认位置。</p>\n</li>\n</ul>\n<h3 id=\"sticky属性值\"><a href=\"#sticky属性值\" class=\"headerlink\" title=\"sticky属性值\"></a><strong>sticky属性值</strong></h3><ul>\n<li><code>sticky</code>粘滞的意思。可以理解成<code>relative</code>和<code>fixed</code>的结合。正常时候是relative的属性，待在自己该在的位置。当页面滚动到设置了<code>sticky</code>的元素的时候，他就会根据设置top、bottom、left、right来进行定位，属性有点像<code>flex</code>。</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">white-wrap:nowrap //让文章不换行</span><br></pre></td></tr></table></figure>\n<h3 id=\"opacity与rgba的区别\"><a href=\"#opacity与rgba的区别\" class=\"headerlink\" title=\"opacity与rgba的区别\"></a><strong>opacity与rgba的区别</strong></h3><p><code>opactiy</code>会创建层叠上下文，而且会让整个元素包括子元素都变成透明。<br><code>rgba</code>不会创建层叠上下文，只会作用在该元素上，不会影响其他元素。</p>\n<p>资料参考：<br>阮一峰CSS详解：<a href=\"http://www.ruanyifeng.com/blog/2019/11/css-position.html\">http://www.ruanyifeng.com/blog/2019/11/css-position.html</a><br>饥人谷</p>\n<p>(完)</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"position的五个取值\"><a href=\"#position的五个取值\" class=\"headerlink\" title=\"position的五个取值\"></a><strong>position的五个取值</strong></h2><p><code>position</code>属性用来指定一个元素在网页上的位置。有以下五个属性值。</p>\n<ul>\n<li><code>static</code></li>\n<li><code>relative</code></li>\n<li><code>absolute</code></li>\n<li><code>fixed</code></li>\n<li><code>sticky</code>","more":"</li>\n</ul>\n<p><font class=\"ff6666\">测速</font></p>\n<h3 id=\"static属性值\"><a href=\"#static属性值\" class=\"headerlink\" title=\"static属性值\"></a><strong>static属性值</strong></h3><p><code>static</code>静态的意思，是<code>position</code>的默认取值，如果省略<code>position</code>属性，浏览器就认为该元素是<code>static</code>定位。</p>\n<h3 id=\"relative-absolute-fixed属性值\"><a href=\"#relative-absolute-fixed属性值\" class=\"headerlink\" title=\"relative,absolute,fixed属性值\"></a><strong>relative,absolute,fixed属性值</strong></h3><p><code>relative</code> 、<code>absolute</code>、<code> fixed</code>这三个属性值有一个共同点，都是相对于某个<font color=#FF3333><b>基点</b></font>定位。不同之处仅仅在于<font color=#FF3333><b>基点</b></font>的不同。</p>\n<ul>\n<li><code>relative</code>相对的意思，表示相对于默认的位置,即<font color=#FF6666><b>定位基点</b></font>就是元素默认的位置。不会脱离文档流。只是浮起来，原先的位置所占的空间还在文档流中。用于做位移和给<code>absolute</code>元素做父元素。</li>\n</ul>\n<ul>\n<li><p><code>absolute</code>绝对的意思，表示相对于离它最近的定位元素定位（必须是非static属性),即<font color=#FF6666><b>定位基点</b></font>是离它做最近的非定位元素。会脱离文档流，另起一层。<code>absolute</code>定位<font color=#FF3333><b>必须</b></font>就搭配<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>这四个属性里面的两个使用，不然有些浏览器会出现异常，用于做对话框的关闭按钮和鼠标提示。</p>\n</li>\n<li><p><code>fixed</code>固定的意思,表达相对于视口(viewport，浏览器窗口)进行偏移，<font color=#FF6666><b>定位基点</b></font>是浏览器窗口，这会导致元素的位置不会随着页面滚动而变化，好像是固定在网页上某个位置一样。他如果搭配<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>这四个属性一起使用，表示元素的初始位置是基于视口计算的，否则初始位置就是元素的默认位置。</p>\n</li>\n</ul>\n<h3 id=\"sticky属性值\"><a href=\"#sticky属性值\" class=\"headerlink\" title=\"sticky属性值\"></a><strong>sticky属性值</strong></h3><ul>\n<li><code>sticky</code>粘滞的意思。可以理解成<code>relative</code>和<code>fixed</code>的结合。正常时候是relative的属性，待在自己该在的位置。当页面滚动到设置了<code>sticky</code>的元素的时候，他就会根据设置top、bottom、left、right来进行定位，属性有点像<code>flex</code>。</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">white-wrap:nowrap //让文章不换行</span><br></pre></td></tr></table></figure>\n<h3 id=\"opacity与rgba的区别\"><a href=\"#opacity与rgba的区别\" class=\"headerlink\" title=\"opacity与rgba的区别\"></a><strong>opacity与rgba的区别</strong></h3><p><code>opactiy</code>会创建层叠上下文，而且会让整个元素包括子元素都变成透明。<br><code>rgba</code>不会创建层叠上下文，只会作用在该元素上，不会影响其他元素。</p>\n<p>资料参考：<br>阮一峰CSS详解：<a href=\"http://www.ruanyifeng.com/blog/2019/11/css-position.html\">http://www.ruanyifeng.com/blog/2019/11/css-position.html</a><br>饥人谷</p>\n<p>(完)</p>"},{"title":"z-index与层叠上下文","date":"2020-10-02T06:51:37.000Z","toc":true,"cover":"./img/zindex.jpg","_content":"## __层叠上下文__\n* 层叠上下文，英文_stacking context_，是HTML中的一个三维概念，如果一个元素含有层叠上下文，我们就可以理解为这个元素在<font color=#ff6666><b>Z轴</b></font>上就\"高人一等\"。\n<!--more-->\n* 显示器的宽可以理解成<font color=#ff6666><b>X轴</b></font>，高理解成<font color=#ff6666><b>Y轴</b></font>，<font color=#ff6666><b>Z轴</b></font>就是我们眼睛看向显示器的那条线，如下图所示。 \n <div align=\"center\"><img src=\"./img/z.jpg\" width=500></div>\n\n## __层叠顺序__\n* 表示元素发生层叠时候有着特定的垂直顺序\n<div align==\"center\"><img src=\"./img/order.jpg\"></div>\n\n* 当发生层叠的时候，覆盖关系遵循下面2个准则\n\t1. __谁大谁上__ : 当具有明显的层叠水平标识的时候，在 __同一个层叠__ 上下文领域，层叠水平值大的那个覆盖小的那一个。\n\t2. __后来居上__ : 当元素的层叠水平一直，层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。\n\n* 比喻\n\t1. 每个层叠上下文就是一个新的小世界(作用域)\n\t2. 这个小世界里面的z-index跟外界无关。\n\t3. 处在同一小世界的z-index才能做比较。\n\n## __层叠上下文的创建__\n很多属性都会创建层叠上下文,具体可以在[MDN](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context)\n记住关键几个：`z-index`、`flex`、`opacity`,`transform`\n\n参考资料：\n饥人谷\n张鑫旭深入里面层叠上下文：https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index\n","source":"_posts/z-index与层叠上下文.md","raw":"---\ntitle: z-index与层叠上下文\ndate: 2020-10-02 06:51:37\ntags: CSS\ntoc: true\ncover: ./img/zindex.jpg\n---\n## __层叠上下文__\n* 层叠上下文，英文_stacking context_，是HTML中的一个三维概念，如果一个元素含有层叠上下文，我们就可以理解为这个元素在<font color=#ff6666><b>Z轴</b></font>上就\"高人一等\"。\n<!--more-->\n* 显示器的宽可以理解成<font color=#ff6666><b>X轴</b></font>，高理解成<font color=#ff6666><b>Y轴</b></font>，<font color=#ff6666><b>Z轴</b></font>就是我们眼睛看向显示器的那条线，如下图所示。 \n <div align=\"center\"><img src=\"./img/z.jpg\" width=500></div>\n\n## __层叠顺序__\n* 表示元素发生层叠时候有着特定的垂直顺序\n<div align==\"center\"><img src=\"./img/order.jpg\"></div>\n\n* 当发生层叠的时候，覆盖关系遵循下面2个准则\n\t1. __谁大谁上__ : 当具有明显的层叠水平标识的时候，在 __同一个层叠__ 上下文领域，层叠水平值大的那个覆盖小的那一个。\n\t2. __后来居上__ : 当元素的层叠水平一直，层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。\n\n* 比喻\n\t1. 每个层叠上下文就是一个新的小世界(作用域)\n\t2. 这个小世界里面的z-index跟外界无关。\n\t3. 处在同一小世界的z-index才能做比较。\n\n## __层叠上下文的创建__\n很多属性都会创建层叠上下文,具体可以在[MDN](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context)\n记住关键几个：`z-index`、`flex`、`opacity`,`transform`\n\n参考资料：\n饥人谷\n张鑫旭深入里面层叠上下文：https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index\n","slug":"z-index与层叠上下文","published":1,"updated":"2020-10-02T08:23:51.294Z","_id":"ckfrw4q2r00001ofq4gtp5uqz","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"层叠上下文\"><a href=\"#层叠上下文\" class=\"headerlink\" title=\"层叠上下文\"></a><strong>层叠上下文</strong></h2><ul>\n<li>层叠上下文，英文_stacking context_，是HTML中的一个三维概念，如果一个元素含有层叠上下文，我们就可以理解为这个元素在<font color=#ff6666><b>Z轴</b></font>上就”高人一等”。<a id=\"more\"></a></li>\n<li>显示器的宽可以理解成<font color=#ff6666><b>X轴</b></font>，高理解成<font color=#ff6666><b>Y轴</b></font>，<font color=#ff6666><b>Z轴</b></font>就是我们眼睛看向显示器的那条线，如下图所示。 <div align=\"center\"><img src=\"./img/z.jpg\" width=500></div>\n\n</li>\n</ul>\n<h2 id=\"层叠顺序\"><a href=\"#层叠顺序\" class=\"headerlink\" title=\"层叠顺序\"></a><strong>层叠顺序</strong></h2><ul>\n<li><p>表示元素发生层叠时候有着特定的垂直顺序</p>\n<div align==\"center\"><img src=\"./img/order.jpg\"></div>\n</li>\n<li><p>当发生层叠的时候，覆盖关系遵循下面2个准则</p>\n<ol>\n<li><strong>谁大谁上</strong> : 当具有明显的层叠水平标识的时候，在 <strong>同一个层叠</strong> 上下文领域，层叠水平值大的那个覆盖小的那一个。</li>\n<li><strong>后来居上</strong> : 当元素的层叠水平一直，层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。</li>\n</ol>\n</li>\n<li><p>比喻</p>\n<ol>\n<li>每个层叠上下文就是一个新的小世界(作用域)</li>\n<li>这个小世界里面的z-index跟外界无关。</li>\n<li>处在同一小世界的z-index才能做比较。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"层叠上下文的创建\"><a href=\"#层叠上下文的创建\" class=\"headerlink\" title=\"层叠上下文的创建\"></a><strong>层叠上下文的创建</strong></h2><p>很多属性都会创建层叠上下文,具体可以在<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context\">MDN</a><br>记住关键几个：<code>z-index</code>、<code>flex</code>、<code>opacity</code>,<code>transform</code></p>\n<p>参考资料：<br>饥人谷<br>张鑫旭深入里面层叠上下文：<a href=\"https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index\">https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"层叠上下文\"><a href=\"#层叠上下文\" class=\"headerlink\" title=\"层叠上下文\"></a><strong>层叠上下文</strong></h2><ul>\n<li>层叠上下文，英文_stacking context_，是HTML中的一个三维概念，如果一个元素含有层叠上下文，我们就可以理解为这个元素在<font color=#ff6666><b>Z轴</b></font>上就”高人一等”。","more":"</li>\n<li>显示器的宽可以理解成<font color=#ff6666><b>X轴</b></font>，高理解成<font color=#ff6666><b>Y轴</b></font>，<font color=#ff6666><b>Z轴</b></font>就是我们眼睛看向显示器的那条线，如下图所示。 <div align=\"center\"><img src=\"./img/z.jpg\" width=500></div>\n\n</li>\n</ul>\n<h2 id=\"层叠顺序\"><a href=\"#层叠顺序\" class=\"headerlink\" title=\"层叠顺序\"></a><strong>层叠顺序</strong></h2><ul>\n<li><p>表示元素发生层叠时候有着特定的垂直顺序</p>\n<div align==\"center\"><img src=\"./img/order.jpg\"></div>\n</li>\n<li><p>当发生层叠的时候，覆盖关系遵循下面2个准则</p>\n<ol>\n<li><strong>谁大谁上</strong> : 当具有明显的层叠水平标识的时候，在 <strong>同一个层叠</strong> 上下文领域，层叠水平值大的那个覆盖小的那一个。</li>\n<li><strong>后来居上</strong> : 当元素的层叠水平一直，层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。</li>\n</ol>\n</li>\n<li><p>比喻</p>\n<ol>\n<li>每个层叠上下文就是一个新的小世界(作用域)</li>\n<li>这个小世界里面的z-index跟外界无关。</li>\n<li>处在同一小世界的z-index才能做比较。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"层叠上下文的创建\"><a href=\"#层叠上下文的创建\" class=\"headerlink\" title=\"层叠上下文的创建\"></a><strong>层叠上下文的创建</strong></h2><p>很多属性都会创建层叠上下文,具体可以在<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context\">MDN</a><br>记住关键几个：<code>z-index</code>、<code>flex</code>、<code>opacity</code>,<code>transform</code></p>\n<p>参考资料：<br>饥人谷<br>张鑫旭深入里面层叠上下文：<a href=\"https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index\">https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index</a></p>"},{"title":"CSS动画","date":"2020-10-03T11:59:44.000Z","toc":true,"cover":"./img/cssdonghua.jpg","_content":"### __动画的概念__\n* __定义__\n由许多的静止画面（帧），以一定的速度（每秒30张），连续播放，内眼因视觉残象产生的错觉，以为是活动的画面。大部分影视24帧/s就可以正常播放，游戏需要30帧/s。\n\n<!--more-->\n\n### __浏览器的渲染原理__\n* __步骤__\n\t1. 根据HTML构建HTML树（DOM）\n\t2. 根据CSS构建CSS树（CSSOM）\n\t3. 将两棵树合并成一颗渲染树（render tree）\n\t4. Layout布局（文档流、盒模型、计算大小、位置）\n\t5. Paint绘制（把边框颜色、文字颜色、阴影等画出来）\n\t6. Compose合成(根据层叠关系展示画面)\n\n\n* __DOM、CSSOM、render tree__\n<div align=\"center\"><img src=\"./img/threetree.jpg\"></div>\n\n\n* __三种更改样式的方法__\n<div align=\"center\"><img src=\"./img/changestyle.jpg\"></div>\n\t\n\t1. 全走\n\t`div.remove()`会删除DOM里面的元素，其他元素relayout。要走全部过程，重新布局，重新绘制，重新合成。\n\n\t2. 跳过Layout\n\t  改变背景颜色，因为只是改变背景颜色，布局没有发生变化，所以就跳过了布局\n\n\t3. 跳过layout和paint\n\t  改变transform，只需要composite\n\n* __查看更改哪些属性,CSS怎么绘制__ [csstriggers](https://csstriggers.com/)\n\n* __chrome里查看绘制过程__\n<div align=\"center\"><img src=./img/viewrender.jpg></div>\n\n### __transform__\ntransform的[MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform)\n__经验:__\n1. 一般需要配合`transition`过度\n2. inline元素不支持transform，需要先变成block\n\n`transform`属性允许你旋转、缩放、倾斜、平移给定元素，具体有以下四个属性：\n1. __translate__\n`translate`是控制元素平移的\n```css\ntransform:translateX(200px) \n// X轴水平移动200px \ntransform:translateY(200px) \n// Y轴垂直移动200px\ntransform:translateZ(1000px)\n// Z轴是我们视线的那根轴，要看出变化，要给父元素加上perspective:1000px //我们眼睛离视点1000px\n```\n\n* 利用translate做绝对居中\n```css\n.box{\npositon:absolute;\ntop:50%;\nleft:50%;\ntransform:translate(-50%,-50%);\n}\n```\n\n2. __scale__\n`scale`是控制元素缩放的\n```css\ntransform:scaleX(1)\n//让元素在X方向上放大1倍\ntransform:scaleY(1)\n//让元素在Y方向上放大1倍\ntransform:scale(1,1)\n//以上两个的缩写形式\n```\n\n3. __rotate__\n`rotate`是控制元素旋转的\n```css\ntransform:rotateX(45deg)\n//围绕元素的X轴，旋转45度\ntransform:rotateY(45deg)\n//围绕元素Y轴，旋<F5>转45度\ntransform:rotateZ(45deg)\n//围绕元素Z轴，旋转45度\n```\n__用途__:一般用于360度旋转制作loading\n\n4. __skew__\n`skew`控制元素的倾斜的\n```css\ntransform:skewX(45deg)\n//x轴歪斜45度\ntransform:skewY(45deg)\n//y轴歪斜45度\ntransform(45deg,45deg)\n//以上两者的缩写\n```\n* __transform的组合写法__\n```css\ntransform:scale(0.5)translate(-100%,-100%)\n```\n\n### __transiton__\n可以为一个元素在不同状态之间切换的时候定义不同的过渡效果。\n* __语法:__\n\t* transiton:`属性名` | `时长` | `过渡方式` | `延迟` |\n\t```css\n\ttransiton:left 200ms linear 3s\n\t//left的变化，过渡时间200ms 过渡方式为linear 延迟3秒过渡\n\t```\n\t* 可以用逗号分隔两个不同属性\n\t```css\n\ttransition:left 200ms,top 400ms\n\t```\n\t* 也可以用all代表所有的属性\n\t```\n\ttransition:all 200ms\n\t```\n\t* 过渡方式：linear匀速 | ease-in淡入 | ease-out淡出 | ease-in-out淡入淡出|\n\n* __注意__\n<font color=\"ff6666\"><b>并不是所有属性都能过渡</b></font>\ndisplay:none => blcok 就是没办法过渡的。一边改成visibility:hidden => visible\n\n\n### __animation__\n* __animation语法__\n```css\nanimation: 时长|过渡方式|延迟|次数|方向|填充模式|是否暂停|动画名|\n时长：总共的动画时间\n过渡方式：跟ransiton取值一样\n次数：动画完成几次，infinite重复做\n方向：reverse | alternate | alternate-reverse|\n填充模式：none | forwards | backwards | both |\n是否暂停：paused | running |\n```\n* __keyframes语法__\n`animation`描述动画怎么样变化，`@keyframes`就是描述动画每个时间段要做什么\n```\n@keyframes 动画名{\nfrom{\n}\n//最初的状态\nto{\n}\n//最后的状态\n}\n```\n例子：[JSbin](https://jsbin.com/mexerad/edit?html,css,output)\n\n\n资料参考：饥人谷\n\n<div class=\"ff6666\">(完)</div>\n\n\n\n\n\n\n\n\n","source":"_posts/CSS动画.md","raw":"---\ntitle: CSS动画\ndate: 2020-10-03 11:59:44\ntags: CSS\ntoc: true\ncover: ./img/cssdonghua.jpg\n---\n### __动画的概念__\n* __定义__\n由许多的静止画面（帧），以一定的速度（每秒30张），连续播放，内眼因视觉残象产生的错觉，以为是活动的画面。大部分影视24帧/s就可以正常播放，游戏需要30帧/s。\n\n<!--more-->\n\n### __浏览器的渲染原理__\n* __步骤__\n\t1. 根据HTML构建HTML树（DOM）\n\t2. 根据CSS构建CSS树（CSSOM）\n\t3. 将两棵树合并成一颗渲染树（render tree）\n\t4. Layout布局（文档流、盒模型、计算大小、位置）\n\t5. Paint绘制（把边框颜色、文字颜色、阴影等画出来）\n\t6. Compose合成(根据层叠关系展示画面)\n\n\n* __DOM、CSSOM、render tree__\n<div align=\"center\"><img src=\"./img/threetree.jpg\"></div>\n\n\n* __三种更改样式的方法__\n<div align=\"center\"><img src=\"./img/changestyle.jpg\"></div>\n\t\n\t1. 全走\n\t`div.remove()`会删除DOM里面的元素，其他元素relayout。要走全部过程，重新布局，重新绘制，重新合成。\n\n\t2. 跳过Layout\n\t  改变背景颜色，因为只是改变背景颜色，布局没有发生变化，所以就跳过了布局\n\n\t3. 跳过layout和paint\n\t  改变transform，只需要composite\n\n* __查看更改哪些属性,CSS怎么绘制__ [csstriggers](https://csstriggers.com/)\n\n* __chrome里查看绘制过程__\n<div align=\"center\"><img src=./img/viewrender.jpg></div>\n\n### __transform__\ntransform的[MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform)\n__经验:__\n1. 一般需要配合`transition`过度\n2. inline元素不支持transform，需要先变成block\n\n`transform`属性允许你旋转、缩放、倾斜、平移给定元素，具体有以下四个属性：\n1. __translate__\n`translate`是控制元素平移的\n```css\ntransform:translateX(200px) \n// X轴水平移动200px \ntransform:translateY(200px) \n// Y轴垂直移动200px\ntransform:translateZ(1000px)\n// Z轴是我们视线的那根轴，要看出变化，要给父元素加上perspective:1000px //我们眼睛离视点1000px\n```\n\n* 利用translate做绝对居中\n```css\n.box{\npositon:absolute;\ntop:50%;\nleft:50%;\ntransform:translate(-50%,-50%);\n}\n```\n\n2. __scale__\n`scale`是控制元素缩放的\n```css\ntransform:scaleX(1)\n//让元素在X方向上放大1倍\ntransform:scaleY(1)\n//让元素在Y方向上放大1倍\ntransform:scale(1,1)\n//以上两个的缩写形式\n```\n\n3. __rotate__\n`rotate`是控制元素旋转的\n```css\ntransform:rotateX(45deg)\n//围绕元素的X轴，旋转45度\ntransform:rotateY(45deg)\n//围绕元素Y轴，旋<F5>转45度\ntransform:rotateZ(45deg)\n//围绕元素Z轴，旋转45度\n```\n__用途__:一般用于360度旋转制作loading\n\n4. __skew__\n`skew`控制元素的倾斜的\n```css\ntransform:skewX(45deg)\n//x轴歪斜45度\ntransform:skewY(45deg)\n//y轴歪斜45度\ntransform(45deg,45deg)\n//以上两者的缩写\n```\n* __transform的组合写法__\n```css\ntransform:scale(0.5)translate(-100%,-100%)\n```\n\n### __transiton__\n可以为一个元素在不同状态之间切换的时候定义不同的过渡效果。\n* __语法:__\n\t* transiton:`属性名` | `时长` | `过渡方式` | `延迟` |\n\t```css\n\ttransiton:left 200ms linear 3s\n\t//left的变化，过渡时间200ms 过渡方式为linear 延迟3秒过渡\n\t```\n\t* 可以用逗号分隔两个不同属性\n\t```css\n\ttransition:left 200ms,top 400ms\n\t```\n\t* 也可以用all代表所有的属性\n\t```\n\ttransition:all 200ms\n\t```\n\t* 过渡方式：linear匀速 | ease-in淡入 | ease-out淡出 | ease-in-out淡入淡出|\n\n* __注意__\n<font color=\"ff6666\"><b>并不是所有属性都能过渡</b></font>\ndisplay:none => blcok 就是没办法过渡的。一边改成visibility:hidden => visible\n\n\n### __animation__\n* __animation语法__\n```css\nanimation: 时长|过渡方式|延迟|次数|方向|填充模式|是否暂停|动画名|\n时长：总共的动画时间\n过渡方式：跟ransiton取值一样\n次数：动画完成几次，infinite重复做\n方向：reverse | alternate | alternate-reverse|\n填充模式：none | forwards | backwards | both |\n是否暂停：paused | running |\n```\n* __keyframes语法__\n`animation`描述动画怎么样变化，`@keyframes`就是描述动画每个时间段要做什么\n```\n@keyframes 动画名{\nfrom{\n}\n//最初的状态\nto{\n}\n//最后的状态\n}\n```\n例子：[JSbin](https://jsbin.com/mexerad/edit?html,css,output)\n\n\n资料参考：饥人谷\n\n<div class=\"ff6666\">(完)</div>\n\n\n\n\n\n\n\n\n","slug":"CSS动画","published":1,"updated":"2020-10-03T16:38:07.615Z","_id":"ckftmkspu0000j5fq443aht62","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"动画的概念\"><a href=\"#动画的概念\" class=\"headerlink\" title=\"动画的概念\"></a><strong>动画的概念</strong></h3><ul>\n<li><strong>定义</strong><br>由许多的静止画面（帧），以一定的速度（每秒30张），连续播放，内眼因视觉残象产生的错觉，以为是活动的画面。大部分影视24帧/s就可以正常播放，游戏需要30帧/s。</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"浏览器的渲染原理\"><a href=\"#浏览器的渲染原理\" class=\"headerlink\" title=\"浏览器的渲染原理\"></a><strong>浏览器的渲染原理</strong></h3><ul>\n<li><strong>步骤</strong><ol>\n<li>根据HTML构建HTML树（DOM）</li>\n<li>根据CSS构建CSS树（CSSOM）</li>\n<li>将两棵树合并成一颗渲染树（render tree）</li>\n<li>Layout布局（文档流、盒模型、计算大小、位置）</li>\n<li>Paint绘制（把边框颜色、文字颜色、阴影等画出来）</li>\n<li>Compose合成(根据层叠关系展示画面)</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><strong>DOM、CSSOM、render tree</strong><div align=\"center\"><img src=\"./img/threetree.jpg\"></div>\n\n\n</li>\n</ul>\n<ul>\n<li><p><strong>三种更改样式的方法</strong></p>\n<div align=\"center\"><img src=\"./img/changestyle.jpg\"></div>\n\n<ol>\n<li><p>全走<br><code>div.remove()</code>会删除DOM里面的元素，其他元素relayout。要走全部过程，重新布局，重新绘制，重新合成。</p>\n</li>\n<li><p>跳过Layout<br>改变背景颜色，因为只是改变背景颜色，布局没有发生变化，所以就跳过了布局</p>\n</li>\n<li><p>跳过layout和paint<br>改变transform，只需要composite</p>\n</li>\n</ol>\n</li>\n<li><p><strong>查看更改哪些属性,CSS怎么绘制</strong> <a href=\"https://csstriggers.com/\">csstriggers</a></p>\n</li>\n<li><p><strong>chrome里查看绘制过程</strong></p>\n<div align=\"center\"><img src=./img/viewrender.jpg></div>\n\n</li>\n</ul>\n<h3 id=\"transform\"><a href=\"#transform\" class=\"headerlink\" title=\"transform\"></a><strong>transform</strong></h3><p>transform的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform\">MDN</a><br><strong>经验:</strong></p>\n<ol>\n<li>一般需要配合<code>transition</code>过度</li>\n<li>inline元素不支持transform，需要先变成block</li>\n</ol>\n<p><code>transform</code>属性允许你旋转、缩放、倾斜、平移给定元素，具体有以下四个属性：</p>\n<ol>\n<li><strong>translate</strong><br><code>translate</code>是控制元素平移的<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">transform</span><span class=\"selector-pseudo\">:translateX(200px)</span> </span><br><span class=\"line\">// X轴水平移动200px </span><br><span class=\"line\"><span class=\"selector-tag\">transform</span><span class=\"selector-pseudo\">:translateY(200px)</span> </span><br><span class=\"line\">// Y轴垂直移动200px</span><br><span class=\"line\"><span class=\"selector-tag\">transform</span><span class=\"selector-pseudo\">:translateZ(1000px)</span></span><br><span class=\"line\">// Z轴是我们视线的那根轴，要看出变化，要给父元素加上perspective:1000px //我们眼睛离视点1000px</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>利用translate做绝对居中<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">positon</span>:absolute;</span><br><span class=\"line\"><span class=\"attribute\">top</span>:<span class=\"number\">50%</span>;</span><br><span class=\"line\"><span class=\"attribute\">left</span>:<span class=\"number\">50%</span>;</span><br><span class=\"line\"><span class=\"attribute\">transform</span>:<span class=\"built_in\">translate</span>(-<span class=\"number\">50%</span>,-<span class=\"number\">50%</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"2\">\n<li><p><strong>scale</strong><br><code>scale</code>是控制元素缩放的</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">transform</span><span class=\"selector-pseudo\">:scaleX(1)</span></span><br><span class=\"line\">//让元素在X方向上放大1倍</span><br><span class=\"line\"><span class=\"selector-tag\">transform</span><span class=\"selector-pseudo\">:scaleY(1)</span></span><br><span class=\"line\">//让元素在Y方向上放大1倍</span><br><span class=\"line\"><span class=\"selector-tag\">transform</span><span class=\"selector-pseudo\">:scale(1</span>,1)</span><br><span class=\"line\">//以上两个的缩写形式</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>rotate</strong><br><code>rotate</code>是控制元素旋转的</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">transform</span><span class=\"selector-pseudo\">:rotateX(45deg)</span></span><br><span class=\"line\">//围绕元素的X轴，旋转45度</span><br><span class=\"line\"><span class=\"selector-tag\">transform</span><span class=\"selector-pseudo\">:rotateY(45deg)</span></span><br><span class=\"line\">//围绕元素Y轴，旋&lt;F5&gt;转45度</span><br><span class=\"line\"><span class=\"selector-tag\">transform</span><span class=\"selector-pseudo\">:rotateZ(45deg)</span></span><br><span class=\"line\">//围绕元素Z轴，旋转45度</span><br></pre></td></tr></table></figure>\n<p><strong>用途</strong>:一般用于360度旋转制作loading</p>\n</li>\n<li><p><strong>skew</strong><br><code>skew</code>控制元素的倾斜的</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">transform</span><span class=\"selector-pseudo\">:skewX(45deg)</span></span><br><span class=\"line\">//x轴歪斜45度</span><br><span class=\"line\"><span class=\"selector-tag\">transform</span><span class=\"selector-pseudo\">:skewY(45deg)</span></span><br><span class=\"line\">//y轴歪斜45度</span><br><span class=\"line\"><span class=\"selector-tag\">transform</span>(45<span class=\"selector-tag\">deg</span>,45<span class=\"selector-tag\">deg</span>)</span><br><span class=\"line\">//以上两者的缩写</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li><strong>transform的组合写法</strong><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">transform</span><span class=\"selector-pseudo\">:scale(0.5)translate(-100</span>%,<span class=\"selector-tag\">-100</span>%)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"transiton\"><a href=\"#transiton\" class=\"headerlink\" title=\"transiton\"></a><strong>transiton</strong></h3><p>可以为一个元素在不同状态之间切换的时候定义不同的过渡效果。</p>\n<ul>\n<li><p><strong>语法:</strong></p>\n<ul>\n<li>transiton:<code>属性名</code> | <code>时长</code> | <code>过渡方式</code> | <code>延迟</code> |<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">transiton</span><span class=\"selector-pseudo\">:left</span> 200<span class=\"selector-tag\">ms</span> <span class=\"selector-tag\">linear</span> 3<span class=\"selector-tag\">s</span></span><br><span class=\"line\">//left的变化，过渡时间200ms 过渡方式为linear 延迟3秒过渡</span><br></pre></td></tr></table></figure></li>\n<li>可以用逗号分隔两个不同属性<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">transition</span><span class=\"selector-pseudo\">:left</span> 200<span class=\"selector-tag\">ms</span>,<span class=\"selector-tag\">top</span> 400<span class=\"selector-tag\">ms</span></span><br></pre></td></tr></table></figure></li>\n<li>也可以用all代表所有的属性<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transition:all 200ms</span><br></pre></td></tr></table></figure></li>\n<li>过渡方式：linear匀速 | ease-in淡入 | ease-out淡出 | ease-in-out淡入淡出|</li>\n</ul>\n</li>\n<li><p><strong>注意</strong><br><font color=\"ff6666\"><b>并不是所有属性都能过渡</b></font><br>display:none =&gt; blcok 就是没办法过渡的。一边改成visibility:hidden =&gt; visible</p>\n</li>\n</ul>\n<h3 id=\"animation\"><a href=\"#animation\" class=\"headerlink\" title=\"animation\"></a><strong>animation</strong></h3><ul>\n<li><strong>animation语法</strong><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">animation: 时长|过渡方式|延迟|次数|方向|填充模式|是否暂停|动画名|</span><br><span class=\"line\">时长：总共的动画时间</span><br><span class=\"line\">过渡方式：跟<span class=\"selector-tag\">ransiton</span>取值一样</span><br><span class=\"line\">次数：动画完成几次，<span class=\"selector-tag\">infinite</span>重复做</span><br><span class=\"line\">方向：reverse | alternate | alternate-reverse|</span><br><span class=\"line\">填充模式：none | forwards | backwards | both |</span><br><span class=\"line\">是否暂停：paused | running |</span><br></pre></td></tr></table></figure></li>\n<li><strong>keyframes语法</strong><br><code>animation</code>描述动画怎么样变化，<code>@keyframes</code>就是描述动画每个时间段要做什么<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@keyframes 动画名&#123;</span><br><span class=\"line\">from&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;最初的状态</span><br><span class=\"line\">to&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;最后的状态</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n例子：<a href=\"https://jsbin.com/mexerad/edit?html,css,output\">JSbin</a></li>\n</ul>\n<p>资料参考：饥人谷</p>\n<div class=\"ff6666\">(完)</div>\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<h3 id=\"动画的概念\"><a href=\"#动画的概念\" class=\"headerlink\" title=\"动画的概念\"></a><strong>动画的概念</strong></h3><ul>\n<li><strong>定义</strong><br>由许多的静止画面（帧），以一定的速度（每秒30张），连续播放，内眼因视觉残象产生的错觉，以为是活动的画面。大部分影视24帧/s就可以正常播放，游戏需要30帧/s。</li>\n</ul>","more":"<h3 id=\"浏览器的渲染原理\"><a href=\"#浏览器的渲染原理\" class=\"headerlink\" title=\"浏览器的渲染原理\"></a><strong>浏览器的渲染原理</strong></h3><ul>\n<li><strong>步骤</strong><ol>\n<li>根据HTML构建HTML树（DOM）</li>\n<li>根据CSS构建CSS树（CSSOM）</li>\n<li>将两棵树合并成一颗渲染树（render tree）</li>\n<li>Layout布局（文档流、盒模型、计算大小、位置）</li>\n<li>Paint绘制（把边框颜色、文字颜色、阴影等画出来）</li>\n<li>Compose合成(根据层叠关系展示画面)</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><strong>DOM、CSSOM、render tree</strong><div align=\"center\"><img src=\"./img/threetree.jpg\"></div>\n\n\n</li>\n</ul>\n<ul>\n<li><p><strong>三种更改样式的方法</strong></p>\n<div align=\"center\"><img src=\"./img/changestyle.jpg\"></div>\n\n<ol>\n<li><p>全走<br><code>div.remove()</code>会删除DOM里面的元素，其他元素relayout。要走全部过程，重新布局，重新绘制，重新合成。</p>\n</li>\n<li><p>跳过Layout<br>改变背景颜色，因为只是改变背景颜色，布局没有发生变化，所以就跳过了布局</p>\n</li>\n<li><p>跳过layout和paint<br>改变transform，只需要composite</p>\n</li>\n</ol>\n</li>\n<li><p><strong>查看更改哪些属性,CSS怎么绘制</strong> <a href=\"https://csstriggers.com/\">csstriggers</a></p>\n</li>\n<li><p><strong>chrome里查看绘制过程</strong></p>\n<div align=\"center\"><img src=./img/viewrender.jpg></div>\n\n</li>\n</ul>\n<h3 id=\"transform\"><a href=\"#transform\" class=\"headerlink\" title=\"transform\"></a><strong>transform</strong></h3><p>transform的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform\">MDN</a><br><strong>经验:</strong></p>\n<ol>\n<li>一般需要配合<code>transition</code>过度</li>\n<li>inline元素不支持transform，需要先变成block</li>\n</ol>\n<p><code>transform</code>属性允许你旋转、缩放、倾斜、平移给定元素，具体有以下四个属性：</p>\n<ol>\n<li><strong>translate</strong><br><code>translate</code>是控制元素平移的<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">transform</span><span class=\"selector-pseudo\">:translateX(200px)</span> </span><br><span class=\"line\">// X轴水平移动200px </span><br><span class=\"line\"><span class=\"selector-tag\">transform</span><span class=\"selector-pseudo\">:translateY(200px)</span> </span><br><span class=\"line\">// Y轴垂直移动200px</span><br><span class=\"line\"><span class=\"selector-tag\">transform</span><span class=\"selector-pseudo\">:translateZ(1000px)</span></span><br><span class=\"line\">// Z轴是我们视线的那根轴，要看出变化，要给父元素加上perspective:1000px //我们眼睛离视点1000px</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>利用translate做绝对居中<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">positon</span>:absolute;</span><br><span class=\"line\"><span class=\"attribute\">top</span>:<span class=\"number\">50%</span>;</span><br><span class=\"line\"><span class=\"attribute\">left</span>:<span class=\"number\">50%</span>;</span><br><span class=\"line\"><span class=\"attribute\">transform</span>:<span class=\"built_in\">translate</span>(-<span class=\"number\">50%</span>,-<span class=\"number\">50%</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"2\">\n<li><p><strong>scale</strong><br><code>scale</code>是控制元素缩放的</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">transform</span><span class=\"selector-pseudo\">:scaleX(1)</span></span><br><span class=\"line\">//让元素在X方向上放大1倍</span><br><span class=\"line\"><span class=\"selector-tag\">transform</span><span class=\"selector-pseudo\">:scaleY(1)</span></span><br><span class=\"line\">//让元素在Y方向上放大1倍</span><br><span class=\"line\"><span class=\"selector-tag\">transform</span><span class=\"selector-pseudo\">:scale(1</span>,1)</span><br><span class=\"line\">//以上两个的缩写形式</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>rotate</strong><br><code>rotate</code>是控制元素旋转的</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">transform</span><span class=\"selector-pseudo\">:rotateX(45deg)</span></span><br><span class=\"line\">//围绕元素的X轴，旋转45度</span><br><span class=\"line\"><span class=\"selector-tag\">transform</span><span class=\"selector-pseudo\">:rotateY(45deg)</span></span><br><span class=\"line\">//围绕元素Y轴，旋&lt;F5&gt;转45度</span><br><span class=\"line\"><span class=\"selector-tag\">transform</span><span class=\"selector-pseudo\">:rotateZ(45deg)</span></span><br><span class=\"line\">//围绕元素Z轴，旋转45度</span><br></pre></td></tr></table></figure>\n<p><strong>用途</strong>:一般用于360度旋转制作loading</p>\n</li>\n<li><p><strong>skew</strong><br><code>skew</code>控制元素的倾斜的</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">transform</span><span class=\"selector-pseudo\">:skewX(45deg)</span></span><br><span class=\"line\">//x轴歪斜45度</span><br><span class=\"line\"><span class=\"selector-tag\">transform</span><span class=\"selector-pseudo\">:skewY(45deg)</span></span><br><span class=\"line\">//y轴歪斜45度</span><br><span class=\"line\"><span class=\"selector-tag\">transform</span>(45<span class=\"selector-tag\">deg</span>,45<span class=\"selector-tag\">deg</span>)</span><br><span class=\"line\">//以上两者的缩写</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li><strong>transform的组合写法</strong><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">transform</span><span class=\"selector-pseudo\">:scale(0.5)translate(-100</span>%,<span class=\"selector-tag\">-100</span>%)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"transiton\"><a href=\"#transiton\" class=\"headerlink\" title=\"transiton\"></a><strong>transiton</strong></h3><p>可以为一个元素在不同状态之间切换的时候定义不同的过渡效果。</p>\n<ul>\n<li><p><strong>语法:</strong></p>\n<ul>\n<li>transiton:<code>属性名</code> | <code>时长</code> | <code>过渡方式</code> | <code>延迟</code> |<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">transiton</span><span class=\"selector-pseudo\">:left</span> 200<span class=\"selector-tag\">ms</span> <span class=\"selector-tag\">linear</span> 3<span class=\"selector-tag\">s</span></span><br><span class=\"line\">//left的变化，过渡时间200ms 过渡方式为linear 延迟3秒过渡</span><br></pre></td></tr></table></figure></li>\n<li>可以用逗号分隔两个不同属性<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">transition</span><span class=\"selector-pseudo\">:left</span> 200<span class=\"selector-tag\">ms</span>,<span class=\"selector-tag\">top</span> 400<span class=\"selector-tag\">ms</span></span><br></pre></td></tr></table></figure></li>\n<li>也可以用all代表所有的属性<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transition:all 200ms</span><br></pre></td></tr></table></figure></li>\n<li>过渡方式：linear匀速 | ease-in淡入 | ease-out淡出 | ease-in-out淡入淡出|</li>\n</ul>\n</li>\n<li><p><strong>注意</strong><br><font color=\"ff6666\"><b>并不是所有属性都能过渡</b></font><br>display:none =&gt; blcok 就是没办法过渡的。一边改成visibility:hidden =&gt; visible</p>\n</li>\n</ul>\n<h3 id=\"animation\"><a href=\"#animation\" class=\"headerlink\" title=\"animation\"></a><strong>animation</strong></h3><ul>\n<li><strong>animation语法</strong><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">animation: 时长|过渡方式|延迟|次数|方向|填充模式|是否暂停|动画名|</span><br><span class=\"line\">时长：总共的动画时间</span><br><span class=\"line\">过渡方式：跟<span class=\"selector-tag\">ransiton</span>取值一样</span><br><span class=\"line\">次数：动画完成几次，<span class=\"selector-tag\">infinite</span>重复做</span><br><span class=\"line\">方向：reverse | alternate | alternate-reverse|</span><br><span class=\"line\">填充模式：none | forwards | backwards | both |</span><br><span class=\"line\">是否暂停：paused | running |</span><br></pre></td></tr></table></figure></li>\n<li><strong>keyframes语法</strong><br><code>animation</code>描述动画怎么样变化，<code>@keyframes</code>就是描述动画每个时间段要做什么<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@keyframes 动画名&#123;</span><br><span class=\"line\">from&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;最初的状态</span><br><span class=\"line\">to&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;最后的状态</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n例子：<a href=\"https://jsbin.com/mexerad/edit?html,css,output\">JSbin</a></li>\n</ul>\n<p>资料参考：饥人谷</p>\n<div class=\"ff6666\">(完)</div>"},{"title":"grid布局","date":"2020-10-08T10:28:00.000Z","toc":true,"cover":"./img/grid.jpg","_content":"### __概述__\ngrid布局是面前最强大的CSS布局方案。\n它将网页划分成一个个网格，可以任意组合不同的网格，做出各式各样的布局。\n<!--more-->\n\n<div align=\"center\"><img src=./img/1.png></div>\n\n以前完成上图要用很多复杂的CSS，现在Grid布局很快就能实现。\nFlex布局是轴线布局，只能指定`项目`针对轴线的位置，可以看作是一维布局 ,Grid布局则是将容器划分成`行`和`列`，产生单元格，然后指定`项目`在哪个单元格，可以看做二维布局 。\n可以在[caniuse](https://caniuse.com/?search=grid)上查看，各个浏览器对grid布局的支持情况。\n\n### __基本概念__\n采用网格布局的区域称为容器`container`。容器内采用网格定位的子元素称为项目`item`\n\n### __容器属性__\n`display:grid`指定一个容器采用网格布局。\n```css\n.contarner{\ndisplay:grid;\n}\n```\n<div align=\"center\"><img src=\"./img/2.png\"></div>\n\n上图是`display:grid`的效果，默认情况下，容器元素都是块级元素，但是也可以设置成行内元素。\n\n```css\n.container{\ndisplay:inline-grid\n}\n```\n\n<div align=\"center\"><img src=\"./img/3.png\"></div>\n\n上图是`display:inline-grid`的效果\n\n* __grid-template-columns属性/grid-template-rows属性__\n使用空格分隔的值列表，用来定义网格的行和列，这些值表示网格轨道的大小。他们之间的空格表示网格线。\n__值:__\n`<track size>`:可以是长度值，百分比，或者等份网格容器中可用空间（使用`fr`单位）\n`<track name>`:可以给网格线取名字。\nCSS代码:\n```css\n.container{\ndisplay:grid;\ngrid-template-columns:40px 50px auto 50px 40px;\ngrid-template-rows:25% 100px auto;\n}\n```\n以上代码可以创建如下图的网格容器。\n<div align=\"center\"><img src=\"./img/4.png\"></div>\n还可以给指定的网格线取名称，注意网格线名称的括号语法\nCSS代码:\n```css\n.container {\ngrid-template-columns: [first] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end];\ngrid-template-rows: [row1-start] 25% [row1-end] 100px [third-line] auto [last-line];\n}\n```\n<div align=\"center\"><img src=\"./img/5.png\"></div>\n\n* __repeat()关键字__\n有时候重复写值非常麻烦，可以使用`repeat()`简化重复的数值\nCSS代码：\n```\n.container{\ngrid-complate-columns:repeat(3,100px);\ngrid-complate-rows:repeat(3.100px);\n}\n```\n以上代码等价于\n```css\ngrid-complate-columns:100px 100px 100px;\ngrid-complate-rows:100px 100px 100px;\n```\n\n* __auto-fill关键字__\n有时候单位格的大小是固定的，但是容器的大小不确定，如果希望每一行或者每一列容纳尽可能多的单元格，这时候就可以使用`auto-fill`\nCSS代码：\n```css\n.container{\ndisplay:grid;\ngrid-template-columns:repeat(auto-fill 100px)\n}\n```\n上面代码表示每列宽度为100px，然后自动填充，知道容器不能放置更多的列。\n\n* __fr关键字__\n为了方便表示比例关系，网格布局提供了`fr`关键字（fraction的缩写，意思片段）。如果两列的宽度分别为`1fr`和`2fr`,就表示后者是前者的两倍。\nCSS代码：\n```css\n.container{\ndisplay:grid;\ngrid-template-columns:1fr 1fr;\n}\n```\n`fr`可以与绝对长度的单位结合使用\n```css\ndisplay:grid;\ngrid-complate-cloumns:20px 1fr 1fr\n```\n以上代码表示，有三列，第一列为20px，剩下的空间由剩下的两列平均分配。\n\n* __grid-row-gap属性/grid-column-gap属性/grid-gap属性__\n`grid-row-gap` 属性设置行与行的间隔。\n`grid-column-gap`属性设置列与列的间隔。\n`grid-gap`以上两者的缩写。\n\n* __grid-template-areas属性__\n网格布局允许区域（areas），一个区域由单个或多个单元格组成。`grid-template-areas`属性用于定义区域。\n__值__:\n \n `grid-complate-areas`由网格项的`grid-area`指定的网格区域名称\n `.` :代表一个空的网格单元\n `none`: 不定义该网格区域\nCSS代码\n```css\n.container{\ndisplay:grid;\ngrid-template-columns:100px 100px 100px;\ngird-template-rows:100px 100px 100px;\ngrid-template-areas:\n\"a b c\"\n\"d e f\"\t\t\t\t\t\t\t\t\t\n\"g h i\";\n}\n```\n上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应九个单元格。\n下面是一个实例\n```css\n.container{\ndisplay:grid;\ngrid-template-columns:50px 50px 50px 50px;\ngird-template-rows:auto;\ngrid-template-areas:\n\"header header header header\"\n\"main main . sidebar\"\n\"footer footer footer footer\";\n}\n```\n<div align=\"center\"><img src=\"./img/6.png\"></div>\n<font class=\"ff6666\">注意:</font>你的声明中的每一行都需要有相同数量的单元格。\n\n* __grid-template属性__\n用来定义`grid-template-rows` `grid-template-columns` `grid-template-areas`的缩写。\n以上代码可以简写为\n```css\n.container{\ndisplay:grid;\ngird-complate:\n\"header header header header\" auto\n\"main main . siderbar\" auto\n\"footer footer foooter footer\" auto\n/50px 50px 50px 50px\n}\n```\n\n### __子元素属性__\n`grid-column`属性是`grid-column-start`和`grid-column-end`的合并简写形式，`grid-row`属性是`grid-row-start`属性和`grid-row-end`的合并简写形式。\n下面是一个例子\n```css\n.item-1{\ngrid-column:1 / 3;\ngrid-rows:1 / 2;\n}\n/*等同于*/\n.item-1{\ngrid-column-start:1;\ngrid-column-end:3;\ngrid-row-start:1;\ngird-row-end:2;\n}\n```\n上面代码中，项目item-1占据第一行，从第一个跟列线到第三根列线。\n这两个属性中，也可以使用`span`关键字，表示跨越多少个网格。\n```css\n.item-1{\ngrid-column:1 span 2;\ngrid-row:1 span 2;\n}\n```\n\n* __grid-area属性__\n`grid-area`属性指定项目放在哪一个区域\n```css\n.container{\ndisplay:grid;\ngrid-template-columns:50px 50px 50px 50px;\ngird-template-rows:auto;\ngrid-template-areas:\n\"header header header header\"\n\"main main . sidebar\"\n\"footer footer footer footer\";\n}\n.item-1{\ngrid-area:header;\n}\n```\n上面代码表示把item-1放在header区域。\n`grid-area`属性还可以当做`grid-row-start`、`grid-column-start`、`grid-row-end`、`grid-column-end`的合并简写形式。\n```css\n.item-1{\ngrid-area:<row-start> | <column-start> | <row-end> | <column-end>;\n}\n```\n\n* __justify-content属性/align-content属性__\n`justify-content`属性定义整个内容区域在容器`container`里面的水平位置。`align-content`属性定义整个内容区域在容器`container`里面的垂直位置。\n```css\n.container {\njustify-content: start | end | center | stretch | space-around | space-between | space-evenly;\nalign-content: start | end | center | stretch | space-around | space-between | space-evenly;  \n}\n```\n跟flex类似，只是多了个`space-evenly`，它是将空间平均分配到每个间隔里面。\n\n* __justify-items属性/align-items属性__\n`justifu-items`属性控制容器内所有网格项水平对齐位置。`align-items`属性控制容器内所有网格项垂直对齐位置。\n```css\n.container{\njustify-items:start|end|center|stretch;\nalign-items:start|end|center|stretch;\n}\n```\n* __justify-self属性/align-self属性__\n`justify-self`属性可以单独控制容器内单个网格项的内容的水平对齐方向\n```css\n.item-1{\njustify-self:start|end|center|stretch;\nalign-self:start|end|center|stretch;\n}\n```\n\n（完）\n\n资料参考：\n* 阮一峰《CSS Grid 网格布局教程》\n* 《CSS Grid 布局完全指南(图解 Grid 详细教程\n","source":"_posts/grid布局.md","raw":"---\ntitle: grid布局\ndate: 2020-10-08 10:28:00\ntags: CSS\ntoc: true\ncover: ./img/grid.jpg\n---\n### __概述__\ngrid布局是面前最强大的CSS布局方案。\n它将网页划分成一个个网格，可以任意组合不同的网格，做出各式各样的布局。\n<!--more-->\n\n<div align=\"center\"><img src=./img/1.png></div>\n\n以前完成上图要用很多复杂的CSS，现在Grid布局很快就能实现。\nFlex布局是轴线布局，只能指定`项目`针对轴线的位置，可以看作是一维布局 ,Grid布局则是将容器划分成`行`和`列`，产生单元格，然后指定`项目`在哪个单元格，可以看做二维布局 。\n可以在[caniuse](https://caniuse.com/?search=grid)上查看，各个浏览器对grid布局的支持情况。\n\n### __基本概念__\n采用网格布局的区域称为容器`container`。容器内采用网格定位的子元素称为项目`item`\n\n### __容器属性__\n`display:grid`指定一个容器采用网格布局。\n```css\n.contarner{\ndisplay:grid;\n}\n```\n<div align=\"center\"><img src=\"./img/2.png\"></div>\n\n上图是`display:grid`的效果，默认情况下，容器元素都是块级元素，但是也可以设置成行内元素。\n\n```css\n.container{\ndisplay:inline-grid\n}\n```\n\n<div align=\"center\"><img src=\"./img/3.png\"></div>\n\n上图是`display:inline-grid`的效果\n\n* __grid-template-columns属性/grid-template-rows属性__\n使用空格分隔的值列表，用来定义网格的行和列，这些值表示网格轨道的大小。他们之间的空格表示网格线。\n__值:__\n`<track size>`:可以是长度值，百分比，或者等份网格容器中可用空间（使用`fr`单位）\n`<track name>`:可以给网格线取名字。\nCSS代码:\n```css\n.container{\ndisplay:grid;\ngrid-template-columns:40px 50px auto 50px 40px;\ngrid-template-rows:25% 100px auto;\n}\n```\n以上代码可以创建如下图的网格容器。\n<div align=\"center\"><img src=\"./img/4.png\"></div>\n还可以给指定的网格线取名称，注意网格线名称的括号语法\nCSS代码:\n```css\n.container {\ngrid-template-columns: [first] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end];\ngrid-template-rows: [row1-start] 25% [row1-end] 100px [third-line] auto [last-line];\n}\n```\n<div align=\"center\"><img src=\"./img/5.png\"></div>\n\n* __repeat()关键字__\n有时候重复写值非常麻烦，可以使用`repeat()`简化重复的数值\nCSS代码：\n```\n.container{\ngrid-complate-columns:repeat(3,100px);\ngrid-complate-rows:repeat(3.100px);\n}\n```\n以上代码等价于\n```css\ngrid-complate-columns:100px 100px 100px;\ngrid-complate-rows:100px 100px 100px;\n```\n\n* __auto-fill关键字__\n有时候单位格的大小是固定的，但是容器的大小不确定，如果希望每一行或者每一列容纳尽可能多的单元格，这时候就可以使用`auto-fill`\nCSS代码：\n```css\n.container{\ndisplay:grid;\ngrid-template-columns:repeat(auto-fill 100px)\n}\n```\n上面代码表示每列宽度为100px，然后自动填充，知道容器不能放置更多的列。\n\n* __fr关键字__\n为了方便表示比例关系，网格布局提供了`fr`关键字（fraction的缩写，意思片段）。如果两列的宽度分别为`1fr`和`2fr`,就表示后者是前者的两倍。\nCSS代码：\n```css\n.container{\ndisplay:grid;\ngrid-template-columns:1fr 1fr;\n}\n```\n`fr`可以与绝对长度的单位结合使用\n```css\ndisplay:grid;\ngrid-complate-cloumns:20px 1fr 1fr\n```\n以上代码表示，有三列，第一列为20px，剩下的空间由剩下的两列平均分配。\n\n* __grid-row-gap属性/grid-column-gap属性/grid-gap属性__\n`grid-row-gap` 属性设置行与行的间隔。\n`grid-column-gap`属性设置列与列的间隔。\n`grid-gap`以上两者的缩写。\n\n* __grid-template-areas属性__\n网格布局允许区域（areas），一个区域由单个或多个单元格组成。`grid-template-areas`属性用于定义区域。\n__值__:\n \n `grid-complate-areas`由网格项的`grid-area`指定的网格区域名称\n `.` :代表一个空的网格单元\n `none`: 不定义该网格区域\nCSS代码\n```css\n.container{\ndisplay:grid;\ngrid-template-columns:100px 100px 100px;\ngird-template-rows:100px 100px 100px;\ngrid-template-areas:\n\"a b c\"\n\"d e f\"\t\t\t\t\t\t\t\t\t\n\"g h i\";\n}\n```\n上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应九个单元格。\n下面是一个实例\n```css\n.container{\ndisplay:grid;\ngrid-template-columns:50px 50px 50px 50px;\ngird-template-rows:auto;\ngrid-template-areas:\n\"header header header header\"\n\"main main . sidebar\"\n\"footer footer footer footer\";\n}\n```\n<div align=\"center\"><img src=\"./img/6.png\"></div>\n<font class=\"ff6666\">注意:</font>你的声明中的每一行都需要有相同数量的单元格。\n\n* __grid-template属性__\n用来定义`grid-template-rows` `grid-template-columns` `grid-template-areas`的缩写。\n以上代码可以简写为\n```css\n.container{\ndisplay:grid;\ngird-complate:\n\"header header header header\" auto\n\"main main . siderbar\" auto\n\"footer footer foooter footer\" auto\n/50px 50px 50px 50px\n}\n```\n\n### __子元素属性__\n`grid-column`属性是`grid-column-start`和`grid-column-end`的合并简写形式，`grid-row`属性是`grid-row-start`属性和`grid-row-end`的合并简写形式。\n下面是一个例子\n```css\n.item-1{\ngrid-column:1 / 3;\ngrid-rows:1 / 2;\n}\n/*等同于*/\n.item-1{\ngrid-column-start:1;\ngrid-column-end:3;\ngrid-row-start:1;\ngird-row-end:2;\n}\n```\n上面代码中，项目item-1占据第一行，从第一个跟列线到第三根列线。\n这两个属性中，也可以使用`span`关键字，表示跨越多少个网格。\n```css\n.item-1{\ngrid-column:1 span 2;\ngrid-row:1 span 2;\n}\n```\n\n* __grid-area属性__\n`grid-area`属性指定项目放在哪一个区域\n```css\n.container{\ndisplay:grid;\ngrid-template-columns:50px 50px 50px 50px;\ngird-template-rows:auto;\ngrid-template-areas:\n\"header header header header\"\n\"main main . sidebar\"\n\"footer footer footer footer\";\n}\n.item-1{\ngrid-area:header;\n}\n```\n上面代码表示把item-1放在header区域。\n`grid-area`属性还可以当做`grid-row-start`、`grid-column-start`、`grid-row-end`、`grid-column-end`的合并简写形式。\n```css\n.item-1{\ngrid-area:<row-start> | <column-start> | <row-end> | <column-end>;\n}\n```\n\n* __justify-content属性/align-content属性__\n`justify-content`属性定义整个内容区域在容器`container`里面的水平位置。`align-content`属性定义整个内容区域在容器`container`里面的垂直位置。\n```css\n.container {\njustify-content: start | end | center | stretch | space-around | space-between | space-evenly;\nalign-content: start | end | center | stretch | space-around | space-between | space-evenly;  \n}\n```\n跟flex类似，只是多了个`space-evenly`，它是将空间平均分配到每个间隔里面。\n\n* __justify-items属性/align-items属性__\n`justifu-items`属性控制容器内所有网格项水平对齐位置。`align-items`属性控制容器内所有网格项垂直对齐位置。\n```css\n.container{\njustify-items:start|end|center|stretch;\nalign-items:start|end|center|stretch;\n}\n```\n* __justify-self属性/align-self属性__\n`justify-self`属性可以单独控制容器内单个网格项的内容的水平对齐方向\n```css\n.item-1{\njustify-self:start|end|center|stretch;\nalign-self:start|end|center|stretch;\n}\n```\n\n（完）\n\n资料参考：\n* 阮一峰《CSS Grid 网格布局教程》\n* 《CSS Grid 布局完全指南(图解 Grid 详细教程\n","slug":"grid布局","published":1,"updated":"2020-10-12T14:41:31.631Z","_id":"ckg0orjxz0000cgfq5p671hbc","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h3><p>grid布局是面前最强大的CSS布局方案。<br>它将网页划分成一个个网格，可以任意组合不同的网格，做出各式各样的布局。</p>\n<a id=\"more\"></a>\n\n<div align=\"center\"><img src=./img/1.png></div>\n\n<p>以前完成上图要用很多复杂的CSS，现在Grid布局很快就能实现。<br>Flex布局是轴线布局，只能指定<code>项目</code>针对轴线的位置，可以看作是一维布局 ,Grid布局则是将容器划分成<code>行</code>和<code>列</code>，产生单元格，然后指定<code>项目</code>在哪个单元格，可以看做二维布局 。<br>可以在<a href=\"https://caniuse.com/?search=grid\">caniuse</a>上查看，各个浏览器对grid布局的支持情况。</p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a><strong>基本概念</strong></h3><p>采用网格布局的区域称为容器<code>container</code>。容器内采用网格定位的子元素称为项目<code>item</code></p>\n<h3 id=\"容器属性\"><a href=\"#容器属性\" class=\"headerlink\" title=\"容器属性\"></a><strong>容器属性</strong></h3><p><code>display:grid</code>指定一个容器采用网格布局。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.contarner</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">display</span>:grid;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"./img/2.png\"></div>\n\n<p>上图是<code>display:grid</code>的效果，默认情况下，容器元素都是块级元素，但是也可以设置成行内元素。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">display</span>:inline-grid</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<div align=\"center\"><img src=\"./img/3.png\"></div>\n\n<p>上图是<code>display:inline-grid</code>的效果</p>\n<ul>\n<li><p><strong>grid-template-columns属性/grid-template-rows属性</strong><br>使用空格分隔的值列表，用来定义网格的行和列，这些值表示网格轨道的大小。他们之间的空格表示网格线。<br><strong>值:</strong><br><code>&lt;track size&gt;</code>:可以是长度值，百分比，或者等份网格容器中可用空间（使用<code>fr</code>单位）<br><code>&lt;track name&gt;</code>:可以给网格线取名字。<br>CSS代码:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">display</span>:grid;</span><br><span class=\"line\"><span class=\"attribute\">grid-template-columns</span>:<span class=\"number\">40px</span> <span class=\"number\">50px</span> auto <span class=\"number\">50px</span> <span class=\"number\">40px</span>;</span><br><span class=\"line\"><span class=\"attribute\">grid-template-rows</span>:<span class=\"number\">25%</span> <span class=\"number\">100px</span> auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码可以创建如下图的网格容器。</p>\n<div align=\"center\"><img src=\"./img/4.png\"></div>\n还可以给指定的网格线取名称，注意网格线名称的括号语法\nCSS代码:\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\"><span class=\"attribute\">grid-template-columns</span>: [first] <span class=\"number\">40px</span> [line2] <span class=\"number\">50px</span> [line3] auto [col4-start] <span class=\"number\">50px</span> [five] <span class=\"number\">40px</span> [end];</span><br><span class=\"line\"><span class=\"attribute\">grid-template-rows</span>: [row1-start] <span class=\"number\">25%</span> [row1-end] <span class=\"number\">100px</span> [third-line] auto [last-line];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"./img/5.png\"></div>\n</li>\n<li><p><strong>repeat()关键字</strong><br>有时候重复写值非常麻烦，可以使用<code>repeat()</code>简化重复的数值<br>CSS代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.container&#123;</span><br><span class=\"line\">grid-complate-columns:repeat(3,100px);</span><br><span class=\"line\">grid-complate-rows:repeat(3.100px);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码等价于</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">grid-complate-columns</span><span class=\"selector-pseudo\">:100px</span> 100<span class=\"selector-tag\">px</span> 100<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">grid-complate-rows</span><span class=\"selector-pseudo\">:100px</span> 100<span class=\"selector-tag\">px</span> 100<span class=\"selector-tag\">px</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>auto-fill关键字</strong><br>有时候单位格的大小是固定的，但是容器的大小不确定，如果希望每一行或者每一列容纳尽可能多的单元格，这时候就可以使用<code>auto-fill</code><br>CSS代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">display</span>:grid;</span><br><span class=\"line\"><span class=\"attribute\">grid-template-columns</span>:<span class=\"built_in\">repeat</span>(auto-fill <span class=\"number\">100px</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码表示每列宽度为100px，然后自动填充，知道容器不能放置更多的列。</p>\n</li>\n<li><p><strong>fr关键字</strong><br>为了方便表示比例关系，网格布局提供了<code>fr</code>关键字（fraction的缩写，意思片段）。如果两列的宽度分别为<code>1fr</code>和<code>2fr</code>,就表示后者是前者的两倍。<br>CSS代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">display</span>:grid;</span><br><span class=\"line\"><span class=\"attribute\">grid-template-columns</span>:<span class=\"number\">1</span>fr <span class=\"number\">1</span>fr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>fr</code>可以与绝对长度的单位结合使用</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">display</span><span class=\"selector-pseudo\">:grid</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">grid-complate-cloumns</span><span class=\"selector-pseudo\">:20px</span> 1<span class=\"selector-tag\">fr</span> 1<span class=\"selector-tag\">fr</span></span><br></pre></td></tr></table></figure>\n<p>以上代码表示，有三列，第一列为20px，剩下的空间由剩下的两列平均分配。</p>\n</li>\n<li><p><strong>grid-row-gap属性/grid-column-gap属性/grid-gap属性</strong><br><code>grid-row-gap</code> 属性设置行与行的间隔。<br><code>grid-column-gap</code>属性设置列与列的间隔。<br><code>grid-gap</code>以上两者的缩写。</p>\n</li>\n<li><p><strong>grid-template-areas属性</strong><br>网格布局允许区域（areas），一个区域由单个或多个单元格组成。<code>grid-template-areas</code>属性用于定义区域。<br><strong>值</strong>:</p>\n<p><code>grid-complate-areas</code>由网格项的<code>grid-area</code>指定的网格区域名称<br><code>.</code> :代表一个空的网格单元<br><code>none</code>: 不定义该网格区域<br>CSS代码</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">display</span>:grid;</span><br><span class=\"line\"><span class=\"attribute\">grid-template-columns</span>:<span class=\"number\">100px</span> <span class=\"number\">100px</span> <span class=\"number\">100px</span>;</span><br><span class=\"line\"><span class=\"attribute\">gird-template-rows</span>:<span class=\"number\">100px</span> <span class=\"number\">100px</span> <span class=\"number\">100px</span>;</span><br><span class=\"line\"><span class=\"attribute\">grid-template-areas</span>:</span><br><span class=\"line\"><span class=\"string\">&quot;a b c&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;d e f&quot;</span>\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\"><span class=\"string\">&quot;g h i&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应九个单元格。<br>下面是一个实例</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">display</span>:grid;</span><br><span class=\"line\"><span class=\"attribute\">grid-template-columns</span>:<span class=\"number\">50px</span> <span class=\"number\">50px</span> <span class=\"number\">50px</span> <span class=\"number\">50px</span>;</span><br><span class=\"line\"><span class=\"attribute\">gird-template-rows</span>:auto;</span><br><span class=\"line\"><span class=\"attribute\">grid-template-areas</span>:</span><br><span class=\"line\"><span class=\"string\">&quot;header header header header&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;main main . sidebar&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;footer footer footer footer&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"./img/6.png\"></div>\n<font class=\"ff6666\">注意:</font>你的声明中的每一行都需要有相同数量的单元格。\n</li>\n<li><p><strong>grid-template属性</strong><br>用来定义<code>grid-template-rows</code> <code>grid-template-columns</code> <code>grid-template-areas</code>的缩写。<br>以上代码可以简写为</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">display</span>:grid;</span><br><span class=\"line\"><span class=\"attribute\">gird-complate</span>:</span><br><span class=\"line\"><span class=\"string\">&quot;header header header header&quot;</span> auto</span><br><span class=\"line\"><span class=\"string\">&quot;main main . siderbar&quot;</span> auto</span><br><span class=\"line\"><span class=\"string\">&quot;footer footer foooter footer&quot;</span> auto</span><br><span class=\"line\">/<span class=\"number\">50px</span> <span class=\"number\">50px</span> <span class=\"number\">50px</span> <span class=\"number\">50px</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"子元素属性\"><a href=\"#子元素属性\" class=\"headerlink\" title=\"子元素属性\"></a><strong>子元素属性</strong></h3><p><code>grid-column</code>属性是<code>grid-column-start</code>和<code>grid-column-end</code>的合并简写形式，<code>grid-row</code>属性是<code>grid-row-start</code>属性和<code>grid-row-end</code>的合并简写形式。<br>下面是一个例子</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item-1</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">grid-column</span>:<span class=\"number\">1</span> / <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"attribute\">grid-rows</span>:<span class=\"number\">1</span> / <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*等同于*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.item-1</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">grid-column-start</span>:<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"attribute\">grid-column-end</span>:<span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"attribute\">grid-row-start</span>:<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"attribute\">gird-row-end</span>:<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，项目item-1占据第一行，从第一个跟列线到第三根列线。<br>这两个属性中，也可以使用<code>span</code>关键字，表示跨越多少个网格。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item-1</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">grid-column</span>:<span class=\"number\">1</span> span <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"attribute\">grid-row</span>:<span class=\"number\">1</span> span <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>grid-area属性</strong><br><code>grid-area</code>属性指定项目放在哪一个区域</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">display</span>:grid;</span><br><span class=\"line\"><span class=\"attribute\">grid-template-columns</span>:<span class=\"number\">50px</span> <span class=\"number\">50px</span> <span class=\"number\">50px</span> <span class=\"number\">50px</span>;</span><br><span class=\"line\"><span class=\"attribute\">gird-template-rows</span>:auto;</span><br><span class=\"line\"><span class=\"attribute\">grid-template-areas</span>:</span><br><span class=\"line\"><span class=\"string\">&quot;header header header header&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;main main . sidebar&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;footer footer footer footer&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.item-1</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">grid-area</span>:header;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码表示把item-1放在header区域。<br><code>grid-area</code>属性还可以当做<code>grid-row-start</code>、<code>grid-column-start</code>、<code>grid-row-end</code>、<code>grid-column-end</code>的合并简写形式。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item-1</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">grid-area</span>:&lt;row-start&gt; | &lt;column-start&gt; | &lt;row-end&gt; | &lt;column-end&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>justify-content属性/align-content属性</strong><br><code>justify-content</code>属性定义整个内容区域在容器<code>container</code>里面的水平位置。<code>align-content</code>属性定义整个内容区域在容器<code>container</code>里面的垂直位置。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\"><span class=\"attribute\">justify-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class=\"line\"><span class=\"attribute\">align-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>跟flex类似，只是多了个<code>space-evenly</code>，它是将空间平均分配到每个间隔里面。</p>\n</li>\n<li><p><strong>justify-items属性/align-items属性</strong><br><code>justifu-items</code>属性控制容器内所有网格项水平对齐位置。<code>align-items</code>属性控制容器内所有网格项垂直对齐位置。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">justify-items</span>:start|end|center|stretch;</span><br><span class=\"line\"><span class=\"attribute\">align-items</span>:start|end|center|stretch;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>justify-self属性/align-self属性</strong><br><code>justify-self</code>属性可以单独控制容器内单个网格项的内容的水平对齐方向</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item-1</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">justify-self</span>:start|end|center|stretch;</span><br><span class=\"line\"><span class=\"attribute\">align-self</span>:start|end|center|stretch;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>（完）</p>\n<p>资料参考：</p>\n<ul>\n<li>阮一峰《CSS Grid 网格布局教程》</li>\n<li>《CSS Grid 布局完全指南(图解 Grid 详细教程</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a><strong>概述</strong></h3><p>grid布局是面前最强大的CSS布局方案。<br>它将网页划分成一个个网格，可以任意组合不同的网格，做出各式各样的布局。</p>","more":"<div align=\"center\"><img src=./img/1.png></div>\n\n<p>以前完成上图要用很多复杂的CSS，现在Grid布局很快就能实现。<br>Flex布局是轴线布局，只能指定<code>项目</code>针对轴线的位置，可以看作是一维布局 ,Grid布局则是将容器划分成<code>行</code>和<code>列</code>，产生单元格，然后指定<code>项目</code>在哪个单元格，可以看做二维布局 。<br>可以在<a href=\"https://caniuse.com/?search=grid\">caniuse</a>上查看，各个浏览器对grid布局的支持情况。</p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a><strong>基本概念</strong></h3><p>采用网格布局的区域称为容器<code>container</code>。容器内采用网格定位的子元素称为项目<code>item</code></p>\n<h3 id=\"容器属性\"><a href=\"#容器属性\" class=\"headerlink\" title=\"容器属性\"></a><strong>容器属性</strong></h3><p><code>display:grid</code>指定一个容器采用网格布局。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.contarner</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">display</span>:grid;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"./img/2.png\"></div>\n\n<p>上图是<code>display:grid</code>的效果，默认情况下，容器元素都是块级元素，但是也可以设置成行内元素。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">display</span>:inline-grid</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<div align=\"center\"><img src=\"./img/3.png\"></div>\n\n<p>上图是<code>display:inline-grid</code>的效果</p>\n<ul>\n<li><p><strong>grid-template-columns属性/grid-template-rows属性</strong><br>使用空格分隔的值列表，用来定义网格的行和列，这些值表示网格轨道的大小。他们之间的空格表示网格线。<br><strong>值:</strong><br><code>&lt;track size&gt;</code>:可以是长度值，百分比，或者等份网格容器中可用空间（使用<code>fr</code>单位）<br><code>&lt;track name&gt;</code>:可以给网格线取名字。<br>CSS代码:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">display</span>:grid;</span><br><span class=\"line\"><span class=\"attribute\">grid-template-columns</span>:<span class=\"number\">40px</span> <span class=\"number\">50px</span> auto <span class=\"number\">50px</span> <span class=\"number\">40px</span>;</span><br><span class=\"line\"><span class=\"attribute\">grid-template-rows</span>:<span class=\"number\">25%</span> <span class=\"number\">100px</span> auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码可以创建如下图的网格容器。</p>\n<div align=\"center\"><img src=\"./img/4.png\"></div>\n还可以给指定的网格线取名称，注意网格线名称的括号语法\nCSS代码:\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\"><span class=\"attribute\">grid-template-columns</span>: [first] <span class=\"number\">40px</span> [line2] <span class=\"number\">50px</span> [line3] auto [col4-start] <span class=\"number\">50px</span> [five] <span class=\"number\">40px</span> [end];</span><br><span class=\"line\"><span class=\"attribute\">grid-template-rows</span>: [row1-start] <span class=\"number\">25%</span> [row1-end] <span class=\"number\">100px</span> [third-line] auto [last-line];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"./img/5.png\"></div>\n</li>\n<li><p><strong>repeat()关键字</strong><br>有时候重复写值非常麻烦，可以使用<code>repeat()</code>简化重复的数值<br>CSS代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.container&#123;</span><br><span class=\"line\">grid-complate-columns:repeat(3,100px);</span><br><span class=\"line\">grid-complate-rows:repeat(3.100px);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码等价于</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">grid-complate-columns</span><span class=\"selector-pseudo\">:100px</span> 100<span class=\"selector-tag\">px</span> 100<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">grid-complate-rows</span><span class=\"selector-pseudo\">:100px</span> 100<span class=\"selector-tag\">px</span> 100<span class=\"selector-tag\">px</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>auto-fill关键字</strong><br>有时候单位格的大小是固定的，但是容器的大小不确定，如果希望每一行或者每一列容纳尽可能多的单元格，这时候就可以使用<code>auto-fill</code><br>CSS代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">display</span>:grid;</span><br><span class=\"line\"><span class=\"attribute\">grid-template-columns</span>:<span class=\"built_in\">repeat</span>(auto-fill <span class=\"number\">100px</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码表示每列宽度为100px，然后自动填充，知道容器不能放置更多的列。</p>\n</li>\n<li><p><strong>fr关键字</strong><br>为了方便表示比例关系，网格布局提供了<code>fr</code>关键字（fraction的缩写，意思片段）。如果两列的宽度分别为<code>1fr</code>和<code>2fr</code>,就表示后者是前者的两倍。<br>CSS代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">display</span>:grid;</span><br><span class=\"line\"><span class=\"attribute\">grid-template-columns</span>:<span class=\"number\">1</span>fr <span class=\"number\">1</span>fr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>fr</code>可以与绝对长度的单位结合使用</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">display</span><span class=\"selector-pseudo\">:grid</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">grid-complate-cloumns</span><span class=\"selector-pseudo\">:20px</span> 1<span class=\"selector-tag\">fr</span> 1<span class=\"selector-tag\">fr</span></span><br></pre></td></tr></table></figure>\n<p>以上代码表示，有三列，第一列为20px，剩下的空间由剩下的两列平均分配。</p>\n</li>\n<li><p><strong>grid-row-gap属性/grid-column-gap属性/grid-gap属性</strong><br><code>grid-row-gap</code> 属性设置行与行的间隔。<br><code>grid-column-gap</code>属性设置列与列的间隔。<br><code>grid-gap</code>以上两者的缩写。</p>\n</li>\n<li><p><strong>grid-template-areas属性</strong><br>网格布局允许区域（areas），一个区域由单个或多个单元格组成。<code>grid-template-areas</code>属性用于定义区域。<br><strong>值</strong>:</p>\n<p><code>grid-complate-areas</code>由网格项的<code>grid-area</code>指定的网格区域名称<br><code>.</code> :代表一个空的网格单元<br><code>none</code>: 不定义该网格区域<br>CSS代码</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">display</span>:grid;</span><br><span class=\"line\"><span class=\"attribute\">grid-template-columns</span>:<span class=\"number\">100px</span> <span class=\"number\">100px</span> <span class=\"number\">100px</span>;</span><br><span class=\"line\"><span class=\"attribute\">gird-template-rows</span>:<span class=\"number\">100px</span> <span class=\"number\">100px</span> <span class=\"number\">100px</span>;</span><br><span class=\"line\"><span class=\"attribute\">grid-template-areas</span>:</span><br><span class=\"line\"><span class=\"string\">&quot;a b c&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;d e f&quot;</span>\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\"><span class=\"string\">&quot;g h i&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应九个单元格。<br>下面是一个实例</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">display</span>:grid;</span><br><span class=\"line\"><span class=\"attribute\">grid-template-columns</span>:<span class=\"number\">50px</span> <span class=\"number\">50px</span> <span class=\"number\">50px</span> <span class=\"number\">50px</span>;</span><br><span class=\"line\"><span class=\"attribute\">gird-template-rows</span>:auto;</span><br><span class=\"line\"><span class=\"attribute\">grid-template-areas</span>:</span><br><span class=\"line\"><span class=\"string\">&quot;header header header header&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;main main . sidebar&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;footer footer footer footer&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div align=\"center\"><img src=\"./img/6.png\"></div>\n<font class=\"ff6666\">注意:</font>你的声明中的每一行都需要有相同数量的单元格。\n</li>\n<li><p><strong>grid-template属性</strong><br>用来定义<code>grid-template-rows</code> <code>grid-template-columns</code> <code>grid-template-areas</code>的缩写。<br>以上代码可以简写为</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">display</span>:grid;</span><br><span class=\"line\"><span class=\"attribute\">gird-complate</span>:</span><br><span class=\"line\"><span class=\"string\">&quot;header header header header&quot;</span> auto</span><br><span class=\"line\"><span class=\"string\">&quot;main main . siderbar&quot;</span> auto</span><br><span class=\"line\"><span class=\"string\">&quot;footer footer foooter footer&quot;</span> auto</span><br><span class=\"line\">/<span class=\"number\">50px</span> <span class=\"number\">50px</span> <span class=\"number\">50px</span> <span class=\"number\">50px</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"子元素属性\"><a href=\"#子元素属性\" class=\"headerlink\" title=\"子元素属性\"></a><strong>子元素属性</strong></h3><p><code>grid-column</code>属性是<code>grid-column-start</code>和<code>grid-column-end</code>的合并简写形式，<code>grid-row</code>属性是<code>grid-row-start</code>属性和<code>grid-row-end</code>的合并简写形式。<br>下面是一个例子</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item-1</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">grid-column</span>:<span class=\"number\">1</span> / <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"attribute\">grid-rows</span>:<span class=\"number\">1</span> / <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*等同于*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.item-1</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">grid-column-start</span>:<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"attribute\">grid-column-end</span>:<span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"attribute\">grid-row-start</span>:<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"attribute\">gird-row-end</span>:<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，项目item-1占据第一行，从第一个跟列线到第三根列线。<br>这两个属性中，也可以使用<code>span</code>关键字，表示跨越多少个网格。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item-1</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">grid-column</span>:<span class=\"number\">1</span> span <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"attribute\">grid-row</span>:<span class=\"number\">1</span> span <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>grid-area属性</strong><br><code>grid-area</code>属性指定项目放在哪一个区域</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">display</span>:grid;</span><br><span class=\"line\"><span class=\"attribute\">grid-template-columns</span>:<span class=\"number\">50px</span> <span class=\"number\">50px</span> <span class=\"number\">50px</span> <span class=\"number\">50px</span>;</span><br><span class=\"line\"><span class=\"attribute\">gird-template-rows</span>:auto;</span><br><span class=\"line\"><span class=\"attribute\">grid-template-areas</span>:</span><br><span class=\"line\"><span class=\"string\">&quot;header header header header&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;main main . sidebar&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;footer footer footer footer&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.item-1</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">grid-area</span>:header;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码表示把item-1放在header区域。<br><code>grid-area</code>属性还可以当做<code>grid-row-start</code>、<code>grid-column-start</code>、<code>grid-row-end</code>、<code>grid-column-end</code>的合并简写形式。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item-1</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">grid-area</span>:&lt;row-start&gt; | &lt;column-start&gt; | &lt;row-end&gt; | &lt;column-end&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>justify-content属性/align-content属性</strong><br><code>justify-content</code>属性定义整个内容区域在容器<code>container</code>里面的水平位置。<code>align-content</code>属性定义整个内容区域在容器<code>container</code>里面的垂直位置。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\"><span class=\"attribute\">justify-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class=\"line\"><span class=\"attribute\">align-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>跟flex类似，只是多了个<code>space-evenly</code>，它是将空间平均分配到每个间隔里面。</p>\n</li>\n<li><p><strong>justify-items属性/align-items属性</strong><br><code>justifu-items</code>属性控制容器内所有网格项水平对齐位置。<code>align-items</code>属性控制容器内所有网格项垂直对齐位置。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">justify-items</span>:start|end|center|stretch;</span><br><span class=\"line\"><span class=\"attribute\">align-items</span>:start|end|center|stretch;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>justify-self属性/align-self属性</strong><br><code>justify-self</code>属性可以单独控制容器内单个网格项的内容的水平对齐方向</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item-1</span>&#123;</span><br><span class=\"line\"><span class=\"attribute\">justify-self</span>:start|end|center|stretch;</span><br><span class=\"line\"><span class=\"attribute\">align-self</span>:start|end|center|stretch;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>（完）</p>\n<p>资料参考：</p>\n<ul>\n<li>阮一峰《CSS Grid 网格布局教程》</li>\n<li>《CSS Grid 布局完全指南(图解 Grid 详细教程</li>\n</ul>"},{"title":"HTTP入门","date":"2020-10-14T13:15:41.000Z","toc":true,"cover":"./img/http.jpg","_content":"\n### __什么是WWW__\nWWW是李爵士在1990年左右发明的，他由三部分组成，分别是`HTML`、`URL`、`HTTP`\n### __URL__\n`URL`全称统一资源定位符(Uniform Resource Locator),是`WWW`的一个核心概念，它是浏览器用来检索Web上公布的任何资源的机制。\n<!--more-->\n<div align=\"center\"><img src=\"./img/url.jpg\"></div>\n\n`URL`由以上几个部分组成，端口默认是不写的，但是要记住HTTP的端口是80，HTTPS的端口是443.\n另外需要注意的一点是，锚点`#`不会被上传到服务器，锚点只是浏览器里面的功能。\n\n### __HTTP__\n`HTTP`全称超文本传输协议，从字面上就可以知道，它是为了传输`HTML`而生的.`HTTP`是建立在TCP/IP协议上的。\n* __TCP/IP协议__\n\t五层软件模型，分别是物理层、数据链路层、网络层、传输控制层、应用层。如下图所示\n\n<div align=\"center\"><img src=\"./img/tcpip.png\"></div>\n\n<div align=\"center\" style=\"font-weight:600;color:#ff3333\"> 越靠下离物理硬件越近，越靠上离用户就越近。</div>\n\n * `物理层`:通过光电信号，传输数据\n * `数据链路层`:通过ARP协议获取访问主机的MAC地址。\n *\t`网络层`:通过子网掩码判断要访问主机的ip是否处于同一子网，如果是同一个子网内，就进行`广播`,如果不处于同一个子网，就获取下一跳的ip，把数据包丢给下一条的ip，这里的下一条ip，可以理解成网关\n * `传输控制层`:有两个协议，`TCP协议`和`UDP协议`，经常被使用的是`TCP/协议`,因为它是面向连接，可靠的传输协议。\n  1. 三次握手\n\t\t ```\n\t\t\t客户端 ----我要建立连接了----> 服务端\n\t\t\t客户端 <----好的我知道了---- 服务端\n\t\t\t客户端 ----好的我也知道了----> 服务端\n\t\t\t完成三次握手后，客户端和服务端 都会为对方开辟一个资源\n\t\t ```\n  2. 四次分手\n\t\t ```\n\t\t 客户端 ----我要断开连接了----> 服务端\n\t\t 客户端 <----好的--- 服务端\n\t\t 客户端  <----我也断开连接了---- 服务端\n\t\t 客户端 ----好的----> 服务端\n\t\t ```\n * `应用层`:应用层上运行着很多协议，是离客户最近的层，上面运行着`HTTP协议`、`SSH协议`、`HTTPS协议`、`FTP协议`等等\n \t以上是从下到上说了每一层的功能，现在有个例子，能更好的理解`TCP/IP`协议，当我们在浏览器输入一个url后，点击回车后发生了什么。\n 1.  `应用层`通过DNS服务，得到需要访问rul所对应的IP，告诉下一层`传输控制层`，我要访问这个IP。\n 2. `数据传输层`在本地开了一个`随机`端口，并且告诉`网络层`我要进行\"三次握手\"了，赶紧帮我找到对方主机的位置。\n 3. `网络层`拿到对方主机ip，先确定主机的ip是否属于子网内，不属于，就把数据丢给下一跳网关的IP。\n 4. `数据链路层` 通过ARP协议，确定对方主机的MAC地址，把对方主机的IP地址和MAC地址封装好，丢给`物理层`\n 5. `物理层`通过光信号，把数据传给对方主机。\n 6. 对方主机拿到数据，又通过网络层、数据链路层、网络层、把之前封装的数据进行拆解，最后到达`传输控制层`，双方`传输控制层`进行完三次握手后，服务器把客户端请求的东西，发给客户端。\n 7. 传输完成后，通过\"四次分手\"断开连接。\n\n* __端口的规则__\n\t1. 0-1023端口是留给系统用的，已经被占用，如果我们自己要使用，要从1024开始。\n\t2. 只有管理员才有权使用留个系统的1024个端口。\n\t3. 一个端口被占用，就只能使用另外一个端口，总的端口数有0~65535\n\n* __关于域名__\n 1. `.com`、`.org`、`.cn` 这些属于顶级域名\n 2. baidu.com 、smartisan.com 这些属于二级域名\n 3. www.baidu.com 、 www.smartisan.com 这些三级域名。\n 4. 其实`www`是多余的，其实是早期为了让用户知道他们在使用的这个东西是`www`才加上的。\n\n\n* __HTTP请求__\n格式：\n```\n请求动词 路径加查询参数 协议名/版本\nHost:访问主机的域名或者/IP \nAccept:text/html   我接受的接受\nContent-type:请求体的格式\nUser-Agent: 用户用什么方式发送的请求\n回车\n请求体\n```\n__注意:__\n 1. 请求动词有`GET`、`POST`、`PUT`、`PATCH`、`DELETE`等\n 2. 请求体在`GET`的时候，一般为空\n\n\n* __HTTP响应__\n```\n协议名/版本 状态码 状态字符串\nContent-type：响应体的格式\n回车\n响应体(下载内容)\n```\n__注意:__ 常见的状态码是考点。[状态码](https://zhuanlan.zhihu.com/p/121168258)\n\n（完）\n\n资料参考：\n1.饥人谷\n2.阮一峰TCP/IP协议\n","source":"_posts/HTTP入门.md","raw":"---\ntitle: HTTP入门\ndate: 2020-10-14 13:15:41\ntags: HTTP\ntoc: true\ncover: ./img/http.jpg\n---\n\n### __什么是WWW__\nWWW是李爵士在1990年左右发明的，他由三部分组成，分别是`HTML`、`URL`、`HTTP`\n### __URL__\n`URL`全称统一资源定位符(Uniform Resource Locator),是`WWW`的一个核心概念，它是浏览器用来检索Web上公布的任何资源的机制。\n<!--more-->\n<div align=\"center\"><img src=\"./img/url.jpg\"></div>\n\n`URL`由以上几个部分组成，端口默认是不写的，但是要记住HTTP的端口是80，HTTPS的端口是443.\n另外需要注意的一点是，锚点`#`不会被上传到服务器，锚点只是浏览器里面的功能。\n\n### __HTTP__\n`HTTP`全称超文本传输协议，从字面上就可以知道，它是为了传输`HTML`而生的.`HTTP`是建立在TCP/IP协议上的。\n* __TCP/IP协议__\n\t五层软件模型，分别是物理层、数据链路层、网络层、传输控制层、应用层。如下图所示\n\n<div align=\"center\"><img src=\"./img/tcpip.png\"></div>\n\n<div align=\"center\" style=\"font-weight:600;color:#ff3333\"> 越靠下离物理硬件越近，越靠上离用户就越近。</div>\n\n * `物理层`:通过光电信号，传输数据\n * `数据链路层`:通过ARP协议获取访问主机的MAC地址。\n *\t`网络层`:通过子网掩码判断要访问主机的ip是否处于同一子网，如果是同一个子网内，就进行`广播`,如果不处于同一个子网，就获取下一跳的ip，把数据包丢给下一条的ip，这里的下一条ip，可以理解成网关\n * `传输控制层`:有两个协议，`TCP协议`和`UDP协议`，经常被使用的是`TCP/协议`,因为它是面向连接，可靠的传输协议。\n  1. 三次握手\n\t\t ```\n\t\t\t客户端 ----我要建立连接了----> 服务端\n\t\t\t客户端 <----好的我知道了---- 服务端\n\t\t\t客户端 ----好的我也知道了----> 服务端\n\t\t\t完成三次握手后，客户端和服务端 都会为对方开辟一个资源\n\t\t ```\n  2. 四次分手\n\t\t ```\n\t\t 客户端 ----我要断开连接了----> 服务端\n\t\t 客户端 <----好的--- 服务端\n\t\t 客户端  <----我也断开连接了---- 服务端\n\t\t 客户端 ----好的----> 服务端\n\t\t ```\n * `应用层`:应用层上运行着很多协议，是离客户最近的层，上面运行着`HTTP协议`、`SSH协议`、`HTTPS协议`、`FTP协议`等等\n \t以上是从下到上说了每一层的功能，现在有个例子，能更好的理解`TCP/IP`协议，当我们在浏览器输入一个url后，点击回车后发生了什么。\n 1.  `应用层`通过DNS服务，得到需要访问rul所对应的IP，告诉下一层`传输控制层`，我要访问这个IP。\n 2. `数据传输层`在本地开了一个`随机`端口，并且告诉`网络层`我要进行\"三次握手\"了，赶紧帮我找到对方主机的位置。\n 3. `网络层`拿到对方主机ip，先确定主机的ip是否属于子网内，不属于，就把数据丢给下一跳网关的IP。\n 4. `数据链路层` 通过ARP协议，确定对方主机的MAC地址，把对方主机的IP地址和MAC地址封装好，丢给`物理层`\n 5. `物理层`通过光信号，把数据传给对方主机。\n 6. 对方主机拿到数据，又通过网络层、数据链路层、网络层、把之前封装的数据进行拆解，最后到达`传输控制层`，双方`传输控制层`进行完三次握手后，服务器把客户端请求的东西，发给客户端。\n 7. 传输完成后，通过\"四次分手\"断开连接。\n\n* __端口的规则__\n\t1. 0-1023端口是留给系统用的，已经被占用，如果我们自己要使用，要从1024开始。\n\t2. 只有管理员才有权使用留个系统的1024个端口。\n\t3. 一个端口被占用，就只能使用另外一个端口，总的端口数有0~65535\n\n* __关于域名__\n 1. `.com`、`.org`、`.cn` 这些属于顶级域名\n 2. baidu.com 、smartisan.com 这些属于二级域名\n 3. www.baidu.com 、 www.smartisan.com 这些三级域名。\n 4. 其实`www`是多余的，其实是早期为了让用户知道他们在使用的这个东西是`www`才加上的。\n\n\n* __HTTP请求__\n格式：\n```\n请求动词 路径加查询参数 协议名/版本\nHost:访问主机的域名或者/IP \nAccept:text/html   我接受的接受\nContent-type:请求体的格式\nUser-Agent: 用户用什么方式发送的请求\n回车\n请求体\n```\n__注意:__\n 1. 请求动词有`GET`、`POST`、`PUT`、`PATCH`、`DELETE`等\n 2. 请求体在`GET`的时候，一般为空\n\n\n* __HTTP响应__\n```\n协议名/版本 状态码 状态字符串\nContent-type：响应体的格式\n回车\n响应体(下载内容)\n```\n__注意:__ 常见的状态码是考点。[状态码](https://zhuanlan.zhihu.com/p/121168258)\n\n（完）\n\n资料参考：\n1.饥人谷\n2.阮一峰TCP/IP协议\n","slug":"HTTP入门","published":1,"updated":"2020-10-14T16:39:15.691Z","_id":"ckg9f85f30000ejfqedzdd7ix","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"什么是WWW\"><a href=\"#什么是WWW\" class=\"headerlink\" title=\"什么是WWW\"></a><strong>什么是WWW</strong></h3><p>WWW是李爵士在1990年左右发明的，他由三部分组成，分别是<code>HTML</code>、<code>URL</code>、<code>HTTP</code></p>\n<h3 id=\"URL\"><a href=\"#URL\" class=\"headerlink\" title=\"URL\"></a><strong>URL</strong></h3><p><code>URL</code>全称统一资源定位符(Uniform Resource Locator),是<code>WWW</code>的一个核心概念，它是浏览器用来检索Web上公布的任何资源的机制。</p>\n<a id=\"more\"></a>\n<div align=\"center\"><img src=\"./img/url.jpg\"></div>\n\n<p><code>URL</code>由以上几个部分组成，端口默认是不写的，但是要记住HTTP的端口是80，HTTPS的端口是443.<br>另外需要注意的一点是，锚点<code>#</code>不会被上传到服务器，锚点只是浏览器里面的功能。</p>\n<h3 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a><strong>HTTP</strong></h3><p><code>HTTP</code>全称超文本传输协议，从字面上就可以知道，它是为了传输<code>HTML</code>而生的.<code>HTTP</code>是建立在TCP/IP协议上的。</p>\n<ul>\n<li><strong>TCP/IP协议</strong><br>  五层软件模型，分别是物理层、数据链路层、网络层、传输控制层、应用层。如下图所示</li>\n</ul>\n<div align=\"center\"><img src=\"./img/tcpip.png\"></div>\n\n<div align=\"center\" style=\"font-weight:600;color:#ff3333\"> 越靠下离物理硬件越近，越靠上离用户就越近。</div>\n\n<ul>\n<li><code>物理层</code>:通过光电信号，传输数据</li>\n<li><code>数据链路层</code>:通过ARP协议获取访问主机的MAC地址。</li>\n<li><code>网络层</code>:通过子网掩码判断要访问主机的ip是否处于同一子网，如果是同一个子网内，就进行<code>广播</code>,如果不处于同一个子网，就获取下一跳的ip，把数据包丢给下一条的ip，这里的下一条ip，可以理解成网关</li>\n<li><code>传输控制层</code>:有两个协议，<code>TCP协议</code>和<code>UDP协议</code>，经常被使用的是<code>TCP/协议</code>,因为它是面向连接，可靠的传输协议。<ol>\n<li>三次握手   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端 ----我要建立连接了----&gt; 服务端</span><br><span class=\"line\">客户端 &lt;----好的我知道了---- 服务端</span><br><span class=\"line\">客户端 ----好的我也知道了----&gt; 服务端</span><br><span class=\"line\">完成三次握手后，客户端和服务端 都会为对方开辟一个资源</span><br></pre></td></tr></table></figure></li>\n<li>四次分手   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端 ----我要断开连接了----&gt; 服务端</span><br><span class=\"line\">客户端 &lt;----好的--- 服务端</span><br><span class=\"line\">客户端  &lt;----我也断开连接了---- 服务端</span><br><span class=\"line\">客户端 ----好的----&gt; 服务端</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><code>应用层</code>:应用层上运行着很多协议，是离客户最近的层，上面运行着<code>HTTP协议</code>、<code>SSH协议</code>、<code>HTTPS协议</code>、<code>FTP协议</code>等等<br>  以上是从下到上说了每一层的功能，现在有个例子，能更好的理解<code>TCP/IP</code>协议，当我们在浏览器输入一个url后，点击回车后发生了什么。</li>\n</ul>\n<ol>\n<li><code>应用层</code>通过DNS服务，得到需要访问rul所对应的IP，告诉下一层<code>传输控制层</code>，我要访问这个IP。</li>\n<li><code>数据传输层</code>在本地开了一个<code>随机</code>端口，并且告诉<code>网络层</code>我要进行”三次握手”了，赶紧帮我找到对方主机的位置。</li>\n<li><code>网络层</code>拿到对方主机ip，先确定主机的ip是否属于子网内，不属于，就把数据丢给下一跳网关的IP。</li>\n<li><code>数据链路层</code> 通过ARP协议，确定对方主机的MAC地址，把对方主机的IP地址和MAC地址封装好，丢给<code>物理层</code></li>\n<li><code>物理层</code>通过光信号，把数据传给对方主机。</li>\n<li>对方主机拿到数据，又通过网络层、数据链路层、网络层、把之前封装的数据进行拆解，最后到达<code>传输控制层</code>，双方<code>传输控制层</code>进行完三次握手后，服务器把客户端请求的东西，发给客户端。</li>\n<li>传输完成后，通过”四次分手”断开连接。</li>\n</ol>\n<ul>\n<li><p><strong>端口的规则</strong></p>\n<ol>\n<li>0-1023端口是留给系统用的，已经被占用，如果我们自己要使用，要从1024开始。</li>\n<li>只有管理员才有权使用留个系统的1024个端口。</li>\n<li>一个端口被占用，就只能使用另外一个端口，总的端口数有0~65535</li>\n</ol>\n</li>\n<li><p><strong>关于域名</strong></p>\n<ol>\n<li><code>.com</code>、<code>.org</code>、<code>.cn</code> 这些属于顶级域名</li>\n<li>baidu.com 、smartisan.com 这些属于二级域名</li>\n<li><a href=\"http://www.baidu.com/\">www.baidu.com</a> 、 <a href=\"http://www.smartisan.com/\">www.smartisan.com</a> 这些三级域名。</li>\n<li>其实<code>www</code>是多余的，其实是早期为了让用户知道他们在使用的这个东西是<code>www</code>才加上的。</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><strong>HTTP请求</strong><br>格式：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请求动词 路径加查询参数 协议名&#x2F;版本</span><br><span class=\"line\">Host:访问主机的域名或者&#x2F;IP </span><br><span class=\"line\">Accept:text&#x2F;html   我接受的接受</span><br><span class=\"line\">Content-type:请求体的格式</span><br><span class=\"line\">User-Agent: 用户用什么方式发送的请求</span><br><span class=\"line\">回车</span><br><span class=\"line\">请求体</span><br></pre></td></tr></table></figure>\n<strong>注意:</strong><ol>\n<li>请求动词有<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>PATCH</code>、<code>DELETE</code>等</li>\n<li>请求体在<code>GET</code>的时候，一般为空</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><strong>HTTP响应</strong><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">协议名&#x2F;版本 状态码 状态字符串</span><br><span class=\"line\">Content-type：响应体的格式</span><br><span class=\"line\">回车</span><br><span class=\"line\">响应体(下载内容)</span><br></pre></td></tr></table></figure>\n<strong>注意:</strong> 常见的状态码是考点。<a href=\"https://zhuanlan.zhihu.com/p/121168258\">状态码</a></li>\n</ul>\n<p>（完）</p>\n<p>资料参考：<br>1.饥人谷<br>2.阮一峰TCP/IP协议</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是WWW\"><a href=\"#什么是WWW\" class=\"headerlink\" title=\"什么是WWW\"></a><strong>什么是WWW</strong></h3><p>WWW是李爵士在1990年左右发明的，他由三部分组成，分别是<code>HTML</code>、<code>URL</code>、<code>HTTP</code></p>\n<h3 id=\"URL\"><a href=\"#URL\" class=\"headerlink\" title=\"URL\"></a><strong>URL</strong></h3><p><code>URL</code>全称统一资源定位符(Uniform Resource Locator),是<code>WWW</code>的一个核心概念，它是浏览器用来检索Web上公布的任何资源的机制。</p>","more":"<div align=\"center\"><img src=\"./img/url.jpg\"></div>\n\n<p><code>URL</code>由以上几个部分组成，端口默认是不写的，但是要记住HTTP的端口是80，HTTPS的端口是443.<br>另外需要注意的一点是，锚点<code>#</code>不会被上传到服务器，锚点只是浏览器里面的功能。</p>\n<h3 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a><strong>HTTP</strong></h3><p><code>HTTP</code>全称超文本传输协议，从字面上就可以知道，它是为了传输<code>HTML</code>而生的.<code>HTTP</code>是建立在TCP/IP协议上的。</p>\n<ul>\n<li><strong>TCP/IP协议</strong><br>  五层软件模型，分别是物理层、数据链路层、网络层、传输控制层、应用层。如下图所示</li>\n</ul>\n<div align=\"center\"><img src=\"./img/tcpip.png\"></div>\n\n<div align=\"center\" style=\"font-weight:600;color:#ff3333\"> 越靠下离物理硬件越近，越靠上离用户就越近。</div>\n\n<ul>\n<li><code>物理层</code>:通过光电信号，传输数据</li>\n<li><code>数据链路层</code>:通过ARP协议获取访问主机的MAC地址。</li>\n<li><code>网络层</code>:通过子网掩码判断要访问主机的ip是否处于同一子网，如果是同一个子网内，就进行<code>广播</code>,如果不处于同一个子网，就获取下一跳的ip，把数据包丢给下一条的ip，这里的下一条ip，可以理解成网关</li>\n<li><code>传输控制层</code>:有两个协议，<code>TCP协议</code>和<code>UDP协议</code>，经常被使用的是<code>TCP/协议</code>,因为它是面向连接，可靠的传输协议。<ol>\n<li>三次握手   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端 ----我要建立连接了----&gt; 服务端</span><br><span class=\"line\">客户端 &lt;----好的我知道了---- 服务端</span><br><span class=\"line\">客户端 ----好的我也知道了----&gt; 服务端</span><br><span class=\"line\">完成三次握手后，客户端和服务端 都会为对方开辟一个资源</span><br></pre></td></tr></table></figure></li>\n<li>四次分手   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端 ----我要断开连接了----&gt; 服务端</span><br><span class=\"line\">客户端 &lt;----好的--- 服务端</span><br><span class=\"line\">客户端  &lt;----我也断开连接了---- 服务端</span><br><span class=\"line\">客户端 ----好的----&gt; 服务端</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><code>应用层</code>:应用层上运行着很多协议，是离客户最近的层，上面运行着<code>HTTP协议</code>、<code>SSH协议</code>、<code>HTTPS协议</code>、<code>FTP协议</code>等等<br>  以上是从下到上说了每一层的功能，现在有个例子，能更好的理解<code>TCP/IP</code>协议，当我们在浏览器输入一个url后，点击回车后发生了什么。</li>\n</ul>\n<ol>\n<li><code>应用层</code>通过DNS服务，得到需要访问rul所对应的IP，告诉下一层<code>传输控制层</code>，我要访问这个IP。</li>\n<li><code>数据传输层</code>在本地开了一个<code>随机</code>端口，并且告诉<code>网络层</code>我要进行”三次握手”了，赶紧帮我找到对方主机的位置。</li>\n<li><code>网络层</code>拿到对方主机ip，先确定主机的ip是否属于子网内，不属于，就把数据丢给下一跳网关的IP。</li>\n<li><code>数据链路层</code> 通过ARP协议，确定对方主机的MAC地址，把对方主机的IP地址和MAC地址封装好，丢给<code>物理层</code></li>\n<li><code>物理层</code>通过光信号，把数据传给对方主机。</li>\n<li>对方主机拿到数据，又通过网络层、数据链路层、网络层、把之前封装的数据进行拆解，最后到达<code>传输控制层</code>，双方<code>传输控制层</code>进行完三次握手后，服务器把客户端请求的东西，发给客户端。</li>\n<li>传输完成后，通过”四次分手”断开连接。</li>\n</ol>\n<ul>\n<li><p><strong>端口的规则</strong></p>\n<ol>\n<li>0-1023端口是留给系统用的，已经被占用，如果我们自己要使用，要从1024开始。</li>\n<li>只有管理员才有权使用留个系统的1024个端口。</li>\n<li>一个端口被占用，就只能使用另外一个端口，总的端口数有0~65535</li>\n</ol>\n</li>\n<li><p><strong>关于域名</strong></p>\n<ol>\n<li><code>.com</code>、<code>.org</code>、<code>.cn</code> 这些属于顶级域名</li>\n<li>baidu.com 、smartisan.com 这些属于二级域名</li>\n<li><a href=\"http://www.baidu.com/\">www.baidu.com</a> 、 <a href=\"http://www.smartisan.com/\">www.smartisan.com</a> 这些三级域名。</li>\n<li>其实<code>www</code>是多余的，其实是早期为了让用户知道他们在使用的这个东西是<code>www</code>才加上的。</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><strong>HTTP请求</strong><br>格式：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请求动词 路径加查询参数 协议名&#x2F;版本</span><br><span class=\"line\">Host:访问主机的域名或者&#x2F;IP </span><br><span class=\"line\">Accept:text&#x2F;html   我接受的接受</span><br><span class=\"line\">Content-type:请求体的格式</span><br><span class=\"line\">User-Agent: 用户用什么方式发送的请求</span><br><span class=\"line\">回车</span><br><span class=\"line\">请求体</span><br></pre></td></tr></table></figure>\n<strong>注意:</strong><ol>\n<li>请求动词有<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>PATCH</code>、<code>DELETE</code>等</li>\n<li>请求体在<code>GET</code>的时候，一般为空</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><strong>HTTP响应</strong><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">协议名&#x2F;版本 状态码 状态字符串</span><br><span class=\"line\">Content-type：响应体的格式</span><br><span class=\"line\">回车</span><br><span class=\"line\">响应体(下载内容)</span><br></pre></td></tr></table></figure>\n<strong>注意:</strong> 常见的状态码是考点。<a href=\"https://zhuanlan.zhihu.com/p/121168258\">状态码</a></li>\n</ul>\n<p>（完）</p>\n<p>资料参考：<br>1.饥人谷<br>2.阮一峰TCP/IP协议</p>"},{"title":"内存图和JS世界","date":"2020-10-21T13:23:31.000Z","toc":true,"cover":"./img/javascript.jpg","_content":"### __英语小课堂__\n|英语|翻译|英语|翻译|\n|:----:|:----:|:----:|:----:|\n|Operating System|操作系统简称OS|kernel|内核|\n|runtime|运行时（需要的东西）|compile|编译|\n|environment|环境简称env|memory|记忆|\n|person|一个人|people|一群人|\n<!--more-->\n### __内存__\n* 一切都运行在内存里\n\t1. __当我们点下开机键的时候__:主板就会通电，开始读取固件，这里个固件可以理解成硬盘，硬盘里面写着开机程序，硬盘就会把操作系统加载到内存中运行，这样我们开机就可以看到我们安装的操作系统。\n\t2. __当我们打开chrome的时候__:硬盘就会运行`chrome.exe`，然后放到内存里面加载，并且开启chrome的进程，作为主进程。主进程又会开启很多一些辅助进程，比如`网络服务`、`GPU加速`等等。\n\n### __浏览器的功能__\n*  发起请求，下载`HTML`，解析`HTML`，当遇到CSS连接，又请求下载`CSS`，解析`CSS`并且渲染界面，下载`JS`，解析`JS`、执行`JS`等等。我的理解是当浏览器在解析`HTML`的时候，遇到链接就请求和下载链接，可以是`CSS`也可以是`JS`。先到谁就会先下载谁并且解析。\n*  功能模块:用户界面、渲染引擎、JS引擎、储存等等,这些功能模块一般各处于不同的线程上，线程是比进程还要小的单位。如果进程是车间，那么线程就是车间里面的流水线。\n\n### __JS引擎__\n* chrome用的是V8引擎，V8是用C++编写的，速度特别快，Ryan基于V8引擎开发出了`node.js`，有了`node.js`JS代码就可以不单单只是在浏览器上运行了，还可以在脱离浏览器之外的地方运行。\n* JS引擎的主要功能\n\t1. 编译：把JS代码编译为机器能执行的字节或机器码\n\t2. 优化：改写代码，使其更高效\n\t3. 执行: 执行上面的字节码或者机器码\n\t4. 把JS用完的内存回收，方便之后再次使用\n\n### __内存图__\n<div align=\"center\"><img src=\"./img/neicuntu.png\"></div>\n\n上图红色区域是用来存放数据的，红色区域并不存变量名，变量名是存在`不知道什么区`，因为每个浏览器存变量名的区域的分配规则并不一样，所以就叫`不知道上面区`。\n注意：红色区域分为`stack栈`和`Heap堆`他们的特点是`Stack区`是顺序存放的。`Heap区`是随机存放的.\n* 规律\n\t1. 数据分两种：对象和非对象\n\t2. 非对象都在存在`Stack区` 比如数字、字符串\n\t3. 对象都存在`Heap区`\n  如果存的是一个对象，在`Heap区`里面就随机开辟一个地址，把对象存好，然后把位置的编号，存到`Stack区`.这样以后要在对象里面加东西或者删除东西，就会变得很高效。如果把对象存在`Stack区`,因为`Stack区`是顺序存放的，如果要在对象里面加一个东西，就会把该对象后面的所有东西，都“挪位置”。这样就会变的很低效.\n\n* 对象被篡改\n```javascript\nvar person = {name:'frank'}\nvar person2 = person\nperson2.name = ‘ryan’\nconsole.log（person.name）// ‘ryan’\n```\n因为person和person2都指`Heap区`里面的同一个位置，现在person2改变了name的值，`penson.name`的值也会跟着一起改变，因为他们指向同一个对象位置\n\n* 当我们打开浏览器的时候，浏览器的内存图是这样的\n<div align=\"center\"><img src=\"./img/neicuntu2.png\"></div>\n\n 当我们打开浏览器的时候，浏览器就为我们准备好了window，他们上面很多属性比如`console``Object``Array`等等，是的`console.log`并不是JS里面的属性，而是浏览器提供给我们的。\n 上图里面的console和console对象并没有多大的关系，console是存在window上的一个名字,它指向一个地址，这个地址才是console对象\n\n* 原型\n> 以下只是以我现在的知识理解的原型，不知道理解对对了没有。\n\n`万物皆对象`不管是数组、函数都可以理解成是对象。挂载window上的`Object`和`Array`他们都有一个属性叫做`prototype`里面存着对象和数组的共有属性。当我们生成一个空对象的时候，其实里面并没有任何属性，但是我们却可以使用`toStrong`这个属性，是因为每个对象和数组都有一个属性`proto`，里面存着他们各自的共有属性。而且我们还不能串改共有属性，因为串改只能改到本身，而改不到`proto`。但是我们读的话，就可以读到`proto`里面的属性。万物皆对象，当数组读取一个对象的属性时候，其实他的`proto`里面是没有这个属性的，他的`proto`只存着数组的共有属性，但是数组的`prototype`里面也有`proto`它里面的指向，是指向对象的共有属性。对象也有`proto`，但是他是所有人的祖先，所以对象里面的`proto`什么都没有。\n根据下面两张图理解JS里的原型\n<div align=\"center\"><img src=\"./img/yuanxing1.png\"></div>\n<div align=\"center\"><img src=\"./img/yuanxing2.png\"></div>\n\n资料参考：饥人谷\n（完）\n\n","source":"_posts/内存图和JS世界.md","raw":"---\ntitle: 内存图和JS世界\ndate: 2020-10-21 13:23:31\ntags: javascript\ntoc: true\ncover: ./img/javascript.jpg\n---\n### __英语小课堂__\n|英语|翻译|英语|翻译|\n|:----:|:----:|:----:|:----:|\n|Operating System|操作系统简称OS|kernel|内核|\n|runtime|运行时（需要的东西）|compile|编译|\n|environment|环境简称env|memory|记忆|\n|person|一个人|people|一群人|\n<!--more-->\n### __内存__\n* 一切都运行在内存里\n\t1. __当我们点下开机键的时候__:主板就会通电，开始读取固件，这里个固件可以理解成硬盘，硬盘里面写着开机程序，硬盘就会把操作系统加载到内存中运行，这样我们开机就可以看到我们安装的操作系统。\n\t2. __当我们打开chrome的时候__:硬盘就会运行`chrome.exe`，然后放到内存里面加载，并且开启chrome的进程，作为主进程。主进程又会开启很多一些辅助进程，比如`网络服务`、`GPU加速`等等。\n\n### __浏览器的功能__\n*  发起请求，下载`HTML`，解析`HTML`，当遇到CSS连接，又请求下载`CSS`，解析`CSS`并且渲染界面，下载`JS`，解析`JS`、执行`JS`等等。我的理解是当浏览器在解析`HTML`的时候，遇到链接就请求和下载链接，可以是`CSS`也可以是`JS`。先到谁就会先下载谁并且解析。\n*  功能模块:用户界面、渲染引擎、JS引擎、储存等等,这些功能模块一般各处于不同的线程上，线程是比进程还要小的单位。如果进程是车间，那么线程就是车间里面的流水线。\n\n### __JS引擎__\n* chrome用的是V8引擎，V8是用C++编写的，速度特别快，Ryan基于V8引擎开发出了`node.js`，有了`node.js`JS代码就可以不单单只是在浏览器上运行了，还可以在脱离浏览器之外的地方运行。\n* JS引擎的主要功能\n\t1. 编译：把JS代码编译为机器能执行的字节或机器码\n\t2. 优化：改写代码，使其更高效\n\t3. 执行: 执行上面的字节码或者机器码\n\t4. 把JS用完的内存回收，方便之后再次使用\n\n### __内存图__\n<div align=\"center\"><img src=\"./img/neicuntu.png\"></div>\n\n上图红色区域是用来存放数据的，红色区域并不存变量名，变量名是存在`不知道什么区`，因为每个浏览器存变量名的区域的分配规则并不一样，所以就叫`不知道上面区`。\n注意：红色区域分为`stack栈`和`Heap堆`他们的特点是`Stack区`是顺序存放的。`Heap区`是随机存放的.\n* 规律\n\t1. 数据分两种：对象和非对象\n\t2. 非对象都在存在`Stack区` 比如数字、字符串\n\t3. 对象都存在`Heap区`\n  如果存的是一个对象，在`Heap区`里面就随机开辟一个地址，把对象存好，然后把位置的编号，存到`Stack区`.这样以后要在对象里面加东西或者删除东西，就会变得很高效。如果把对象存在`Stack区`,因为`Stack区`是顺序存放的，如果要在对象里面加一个东西，就会把该对象后面的所有东西，都“挪位置”。这样就会变的很低效.\n\n* 对象被篡改\n```javascript\nvar person = {name:'frank'}\nvar person2 = person\nperson2.name = ‘ryan’\nconsole.log（person.name）// ‘ryan’\n```\n因为person和person2都指`Heap区`里面的同一个位置，现在person2改变了name的值，`penson.name`的值也会跟着一起改变，因为他们指向同一个对象位置\n\n* 当我们打开浏览器的时候，浏览器的内存图是这样的\n<div align=\"center\"><img src=\"./img/neicuntu2.png\"></div>\n\n 当我们打开浏览器的时候，浏览器就为我们准备好了window，他们上面很多属性比如`console``Object``Array`等等，是的`console.log`并不是JS里面的属性，而是浏览器提供给我们的。\n 上图里面的console和console对象并没有多大的关系，console是存在window上的一个名字,它指向一个地址，这个地址才是console对象\n\n* 原型\n> 以下只是以我现在的知识理解的原型，不知道理解对对了没有。\n\n`万物皆对象`不管是数组、函数都可以理解成是对象。挂载window上的`Object`和`Array`他们都有一个属性叫做`prototype`里面存着对象和数组的共有属性。当我们生成一个空对象的时候，其实里面并没有任何属性，但是我们却可以使用`toStrong`这个属性，是因为每个对象和数组都有一个属性`proto`，里面存着他们各自的共有属性。而且我们还不能串改共有属性，因为串改只能改到本身，而改不到`proto`。但是我们读的话，就可以读到`proto`里面的属性。万物皆对象，当数组读取一个对象的属性时候，其实他的`proto`里面是没有这个属性的，他的`proto`只存着数组的共有属性，但是数组的`prototype`里面也有`proto`它里面的指向，是指向对象的共有属性。对象也有`proto`，但是他是所有人的祖先，所以对象里面的`proto`什么都没有。\n根据下面两张图理解JS里的原型\n<div align=\"center\"><img src=\"./img/yuanxing1.png\"></div>\n<div align=\"center\"><img src=\"./img/yuanxing2.png\"></div>\n\n资料参考：饥人谷\n（完）\n\n","slug":"内存图和JS世界","published":1,"updated":"2020-10-21T17:26:44.964Z","_id":"ckgjfjrtt000066fqh9z8611q","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"英语小课堂\"><a href=\"#英语小课堂\" class=\"headerlink\" title=\"英语小课堂\"></a><strong>英语小课堂</strong></h3><table>\n<thead>\n<tr>\n<th align=\"center\">英语</th>\n<th align=\"center\">翻译</th>\n<th align=\"center\">英语</th>\n<th align=\"center\">翻译</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Operating System</td>\n<td align=\"center\">操作系统简称OS</td>\n<td align=\"center\">kernel</td>\n<td align=\"center\">内核</td>\n</tr>\n<tr>\n<td align=\"center\">runtime</td>\n<td align=\"center\">运行时（需要的东西）</td>\n<td align=\"center\">compile</td>\n<td align=\"center\">编译</td>\n</tr>\n<tr>\n<td align=\"center\">environment</td>\n<td align=\"center\">环境简称env</td>\n<td align=\"center\">memory</td>\n<td align=\"center\">记忆</td>\n</tr>\n<tr>\n<td align=\"center\">person</td>\n<td align=\"center\">一个人</td>\n<td align=\"center\">people</td>\n<td align=\"center\">一群人</td>\n</tr>\n</tbody></table>\n<a id=\"more\"></a>\n<h3 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a><strong>内存</strong></h3><ul>\n<li>一切都运行在内存里<ol>\n<li><strong>当我们点下开机键的时候</strong>:主板就会通电，开始读取固件，这里个固件可以理解成硬盘，硬盘里面写着开机程序，硬盘就会把操作系统加载到内存中运行，这样我们开机就可以看到我们安装的操作系统。</li>\n<li><strong>当我们打开chrome的时候</strong>:硬盘就会运行<code>chrome.exe</code>，然后放到内存里面加载，并且开启chrome的进程，作为主进程。主进程又会开启很多一些辅助进程，比如<code>网络服务</code>、<code>GPU加速</code>等等。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"浏览器的功能\"><a href=\"#浏览器的功能\" class=\"headerlink\" title=\"浏览器的功能\"></a><strong>浏览器的功能</strong></h3><ul>\n<li>发起请求，下载<code>HTML</code>，解析<code>HTML</code>，当遇到CSS连接，又请求下载<code>CSS</code>，解析<code>CSS</code>并且渲染界面，下载<code>JS</code>，解析<code>JS</code>、执行<code>JS</code>等等。我的理解是当浏览器在解析<code>HTML</code>的时候，遇到链接就请求和下载链接，可以是<code>CSS</code>也可以是<code>JS</code>。先到谁就会先下载谁并且解析。</li>\n<li>功能模块:用户界面、渲染引擎、JS引擎、储存等等,这些功能模块一般各处于不同的线程上，线程是比进程还要小的单位。如果进程是车间，那么线程就是车间里面的流水线。</li>\n</ul>\n<h3 id=\"JS引擎\"><a href=\"#JS引擎\" class=\"headerlink\" title=\"JS引擎\"></a><strong>JS引擎</strong></h3><ul>\n<li>chrome用的是V8引擎，V8是用C++编写的，速度特别快，Ryan基于V8引擎开发出了<code>node.js</code>，有了<code>node.js</code>JS代码就可以不单单只是在浏览器上运行了，还可以在脱离浏览器之外的地方运行。</li>\n<li>JS引擎的主要功能<ol>\n<li>编译：把JS代码编译为机器能执行的字节或机器码</li>\n<li>优化：改写代码，使其更高效</li>\n<li>执行: 执行上面的字节码或者机器码</li>\n<li>把JS用完的内存回收，方便之后再次使用</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"内存图\"><a href=\"#内存图\" class=\"headerlink\" title=\"内存图\"></a><strong>内存图</strong></h3><div align=\"center\"><img src=\"./img/neicuntu.png\"></div>\n\n<p>上图红色区域是用来存放数据的，红色区域并不存变量名，变量名是存在<code>不知道什么区</code>，因为每个浏览器存变量名的区域的分配规则并不一样，所以就叫<code>不知道上面区</code>。<br>注意：红色区域分为<code>stack栈</code>和<code>Heap堆</code>他们的特点是<code>Stack区</code>是顺序存放的。<code>Heap区</code>是随机存放的.</p>\n<ul>\n<li><p>规律</p>\n<ol>\n<li>数据分两种：对象和非对象</li>\n<li>非对象都在存在<code>Stack区</code> 比如数字、字符串</li>\n<li>对象都存在<code>Heap区</code><br>如果存的是一个对象，在<code>Heap区</code>里面就随机开辟一个地址，把对象存好，然后把位置的编号，存到<code>Stack区</code>.这样以后要在对象里面加东西或者删除东西，就会变得很高效。如果把对象存在<code>Stack区</code>,因为<code>Stack区</code>是顺序存放的，如果要在对象里面加一个东西，就会把该对象后面的所有东西，都“挪位置”。这样就会变的很低效.</li>\n</ol>\n</li>\n<li><p>对象被篡改</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;<span class=\"attr\">name</span>:<span class=\"string\">&#x27;frank&#x27;</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = person</span><br><span class=\"line\">person2.name = ‘ryan’</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log（person.name）<span class=\"comment\">// ‘ryan’</span></span><br></pre></td></tr></table></figure>\n<p>因为person和person2都指<code>Heap区</code>里面的同一个位置，现在person2改变了name的值，<code>penson.name</code>的值也会跟着一起改变，因为他们指向同一个对象位置</p>\n</li>\n<li><p>当我们打开浏览器的时候，浏览器的内存图是这样的</p>\n<div align=\"center\"><img src=\"./img/neicuntu2.png\"></div>\n\n<p>当我们打开浏览器的时候，浏览器就为我们准备好了window，他们上面很多属性比如<code>console``Object``Array</code>等等，是的<code>console.log</code>并不是JS里面的属性，而是浏览器提供给我们的。<br>上图里面的console和console对象并没有多大的关系，console是存在window上的一个名字,它指向一个地址，这个地址才是console对象</p>\n</li>\n<li><p>原型</p>\n<blockquote>\n<p>以下只是以我现在的知识理解的原型，不知道理解对对了没有。</p>\n</blockquote>\n</li>\n</ul>\n<p><code>万物皆对象</code>不管是数组、函数都可以理解成是对象。挂载window上的<code>Object</code>和<code>Array</code>他们都有一个属性叫做<code>prototype</code>里面存着对象和数组的共有属性。当我们生成一个空对象的时候，其实里面并没有任何属性，但是我们却可以使用<code>toStrong</code>这个属性，是因为每个对象和数组都有一个属性<code>proto</code>，里面存着他们各自的共有属性。而且我们还不能串改共有属性，因为串改只能改到本身，而改不到<code>proto</code>。但是我们读的话，就可以读到<code>proto</code>里面的属性。万物皆对象，当数组读取一个对象的属性时候，其实他的<code>proto</code>里面是没有这个属性的，他的<code>proto</code>只存着数组的共有属性，但是数组的<code>prototype</code>里面也有<code>proto</code>它里面的指向，是指向对象的共有属性。对象也有<code>proto</code>，但是他是所有人的祖先，所以对象里面的<code>proto</code>什么都没有。<br>根据下面两张图理解JS里的原型</p>\n<div align=\"center\"><img src=\"./img/yuanxing1.png\"></div>\n<div align=\"center\"><img src=\"./img/yuanxing2.png\"></div>\n\n<p>资料参考：饥人谷<br>（完）</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"英语小课堂\"><a href=\"#英语小课堂\" class=\"headerlink\" title=\"英语小课堂\"></a><strong>英语小课堂</strong></h3><table>\n<thead>\n<tr>\n<th align=\"center\">英语</th>\n<th align=\"center\">翻译</th>\n<th align=\"center\">英语</th>\n<th align=\"center\">翻译</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Operating System</td>\n<td align=\"center\">操作系统简称OS</td>\n<td align=\"center\">kernel</td>\n<td align=\"center\">内核</td>\n</tr>\n<tr>\n<td align=\"center\">runtime</td>\n<td align=\"center\">运行时（需要的东西）</td>\n<td align=\"center\">compile</td>\n<td align=\"center\">编译</td>\n</tr>\n<tr>\n<td align=\"center\">environment</td>\n<td align=\"center\">环境简称env</td>\n<td align=\"center\">memory</td>\n<td align=\"center\">记忆</td>\n</tr>\n<tr>\n<td align=\"center\">person</td>\n<td align=\"center\">一个人</td>\n<td align=\"center\">people</td>\n<td align=\"center\">一群人</td>\n</tr>\n</tbody></table>","more":"<h3 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a><strong>内存</strong></h3><ul>\n<li>一切都运行在内存里<ol>\n<li><strong>当我们点下开机键的时候</strong>:主板就会通电，开始读取固件，这里个固件可以理解成硬盘，硬盘里面写着开机程序，硬盘就会把操作系统加载到内存中运行，这样我们开机就可以看到我们安装的操作系统。</li>\n<li><strong>当我们打开chrome的时候</strong>:硬盘就会运行<code>chrome.exe</code>，然后放到内存里面加载，并且开启chrome的进程，作为主进程。主进程又会开启很多一些辅助进程，比如<code>网络服务</code>、<code>GPU加速</code>等等。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"浏览器的功能\"><a href=\"#浏览器的功能\" class=\"headerlink\" title=\"浏览器的功能\"></a><strong>浏览器的功能</strong></h3><ul>\n<li>发起请求，下载<code>HTML</code>，解析<code>HTML</code>，当遇到CSS连接，又请求下载<code>CSS</code>，解析<code>CSS</code>并且渲染界面，下载<code>JS</code>，解析<code>JS</code>、执行<code>JS</code>等等。我的理解是当浏览器在解析<code>HTML</code>的时候，遇到链接就请求和下载链接，可以是<code>CSS</code>也可以是<code>JS</code>。先到谁就会先下载谁并且解析。</li>\n<li>功能模块:用户界面、渲染引擎、JS引擎、储存等等,这些功能模块一般各处于不同的线程上，线程是比进程还要小的单位。如果进程是车间，那么线程就是车间里面的流水线。</li>\n</ul>\n<h3 id=\"JS引擎\"><a href=\"#JS引擎\" class=\"headerlink\" title=\"JS引擎\"></a><strong>JS引擎</strong></h3><ul>\n<li>chrome用的是V8引擎，V8是用C++编写的，速度特别快，Ryan基于V8引擎开发出了<code>node.js</code>，有了<code>node.js</code>JS代码就可以不单单只是在浏览器上运行了，还可以在脱离浏览器之外的地方运行。</li>\n<li>JS引擎的主要功能<ol>\n<li>编译：把JS代码编译为机器能执行的字节或机器码</li>\n<li>优化：改写代码，使其更高效</li>\n<li>执行: 执行上面的字节码或者机器码</li>\n<li>把JS用完的内存回收，方便之后再次使用</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"内存图\"><a href=\"#内存图\" class=\"headerlink\" title=\"内存图\"></a><strong>内存图</strong></h3><div align=\"center\"><img src=\"./img/neicuntu.png\"></div>\n\n<p>上图红色区域是用来存放数据的，红色区域并不存变量名，变量名是存在<code>不知道什么区</code>，因为每个浏览器存变量名的区域的分配规则并不一样，所以就叫<code>不知道上面区</code>。<br>注意：红色区域分为<code>stack栈</code>和<code>Heap堆</code>他们的特点是<code>Stack区</code>是顺序存放的。<code>Heap区</code>是随机存放的.</p>\n<ul>\n<li><p>规律</p>\n<ol>\n<li>数据分两种：对象和非对象</li>\n<li>非对象都在存在<code>Stack区</code> 比如数字、字符串</li>\n<li>对象都存在<code>Heap区</code><br>如果存的是一个对象，在<code>Heap区</code>里面就随机开辟一个地址，把对象存好，然后把位置的编号，存到<code>Stack区</code>.这样以后要在对象里面加东西或者删除东西，就会变得很高效。如果把对象存在<code>Stack区</code>,因为<code>Stack区</code>是顺序存放的，如果要在对象里面加一个东西，就会把该对象后面的所有东西，都“挪位置”。这样就会变的很低效.</li>\n</ol>\n</li>\n<li><p>对象被篡改</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;<span class=\"attr\">name</span>:<span class=\"string\">&#x27;frank&#x27;</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = person</span><br><span class=\"line\">person2.name = ‘ryan’</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log（person.name）<span class=\"comment\">// ‘ryan’</span></span><br></pre></td></tr></table></figure>\n<p>因为person和person2都指<code>Heap区</code>里面的同一个位置，现在person2改变了name的值，<code>penson.name</code>的值也会跟着一起改变，因为他们指向同一个对象位置</p>\n</li>\n<li><p>当我们打开浏览器的时候，浏览器的内存图是这样的</p>\n<div align=\"center\"><img src=\"./img/neicuntu2.png\"></div>\n\n<p>当我们打开浏览器的时候，浏览器就为我们准备好了window，他们上面很多属性比如<code>console``Object``Array</code>等等，是的<code>console.log</code>并不是JS里面的属性，而是浏览器提供给我们的。<br>上图里面的console和console对象并没有多大的关系，console是存在window上的一个名字,它指向一个地址，这个地址才是console对象</p>\n</li>\n<li><p>原型</p>\n<blockquote>\n<p>以下只是以我现在的知识理解的原型，不知道理解对对了没有。</p>\n</blockquote>\n</li>\n</ul>\n<p><code>万物皆对象</code>不管是数组、函数都可以理解成是对象。挂载window上的<code>Object</code>和<code>Array</code>他们都有一个属性叫做<code>prototype</code>里面存着对象和数组的共有属性。当我们生成一个空对象的时候，其实里面并没有任何属性，但是我们却可以使用<code>toStrong</code>这个属性，是因为每个对象和数组都有一个属性<code>proto</code>，里面存着他们各自的共有属性。而且我们还不能串改共有属性，因为串改只能改到本身，而改不到<code>proto</code>。但是我们读的话，就可以读到<code>proto</code>里面的属性。万物皆对象，当数组读取一个对象的属性时候，其实他的<code>proto</code>里面是没有这个属性的，他的<code>proto</code>只存着数组的共有属性，但是数组的<code>prototype</code>里面也有<code>proto</code>它里面的指向，是指向对象的共有属性。对象也有<code>proto</code>，但是他是所有人的祖先，所以对象里面的<code>proto</code>什么都没有。<br>根据下面两张图理解JS里的原型</p>\n<div align=\"center\"><img src=\"./img/yuanxing1.png\"></div>\n<div align=\"center\"><img src=\"./img/yuanxing2.png\"></div>\n\n<p>资料参考：饥人谷<br>（完）</p>"},{"title":"Javascript语法","date":"2020-10-26T13:22:17.000Z","toc":true,"cover":"./img/javascript.jpg","_content":"> 它的优秀之处并非原创，它的原创之处并不优秀。\n\n以上是JS之父对JS的评价，耐人寻味。\n<!--more-->\n## __语句与表达式__\n`表达式`：为了得到一个值的计算式\n```javascript\n1 + 1\n//2\n3*9\n//27\n```\n`语句`：为了可以完成某种任务而进行的操作，改变环境\n```javascript\nvar a = 3;\n```\n__两者的区别__:\n* `语句`是为了完成某项任务，会改变环境。一般情况下是不需要返回值的。\n* `表达式`是为了得到一个值，并且一定会有一个值。\n\n<div class=\"ff6666\">注意</div>\n\n1. 值和返回值是有区别的，值是表达式返回的，而返回值，是函数返回的，而且只有函数有返回值，`return`后面的值就是函数的返回值\n2. 函数`return`的后面不能跟回车，如果跟了回车，函数的返回值就是`undefined`\n3. `console.log(3)` 的返回值是`undefined` ，而控制台上的3，只是控制打印出来的值，而不是返回值。\n\n## __变量__\n变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。\n```javascript\nvar a = 1;\n```\n以上的`=`并不是\"a等于1\"的意思，这个`=`念做\"赋值给\"，以上的代码的意思是把1这个值赋值给`a`这个变量。\n如果只写一个变量名，而不用`var`来声明的话，浏览器就会报错，告诉你这个变量没有被声明.\n```javascript\n a = 1\n```\n以上的方式也可以声明一个变量，但是不利于表达意图，而且容易不知不觉的创建全部变量\n\n## __标识符__\n标识符也就是变量的名字，给变量取个名字，取名要遵循下面的两条的规定。\n1. 第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线。\n2. 第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。\n\n## __区块__\n使用大括号把多个相关语句组合在一起，成为区块。\n```javascript\nvar a = 1;\nconsole.log(a)\n```\n\n## __条件判断语句__\n只有满足相应的条件，才能执行相应的语句\n### __if....else__\nif结构先判断一个表达式的布尔值，根据布尔值的真伪来执行不同的语句。\n```javascript\nif(布尔值)\n语句；\n\n//或者\nif(布尔值) 语句；\n```\n上面的`布尔值`往往是通过一个表达式产生的。必须放在圆括号里面，表示对表达式求值。\n以上的写法，表达式后面只能有一个语句，如果有多个语句要执行，就要用`{}`括起来。建议总在if语句中使用加大括号，这样方便插入语句。而且不会有歧义。\n```javascript\nvar a = 1;\nif(a === 2)\nconsole.log(a)\nconsole.log('a等于2')\n// a等于2\n\n//等同于\nvar a = 1;\nif(a===2){\nconsole.log(a)\n}\nconsole.log(\"a等于2\")\n```\n\n`if`代码块后面，还可以跟一个`else`代码块，表示不满足条件时，所要执行的代码\n```javascript\nif(布尔值){\n\t//满足条件时，执行的语句\n}else{\n\t//不满足条件时，执行的语句\n}\n```\n<div class=\"ff6666\">注意</div> \n\n`else`只会判断离它最近的`if`\n当要进行多次判断的时候，就可以写成以下格式\n```javascript\n\tif(布尔值){\n\t  // ....\n\t}else if{\n\t  //....\n\t}else if{\n\t  // ....\n\t}else{\n\t\t// ....\n\t}\n```\n\n### __switch语句__\n```javascript\nswitch(变量名/表达式){\n\tcase 值：\n\t语句1；\n\tbreak；\n\tcase 值1：\n\t语句2；\n\tbreak；\n\tdefault：\n\t语句3；\n}\n```\n上面代码根据`switch`括号里的值，选择执行相应的case。如果所有case都不符合，则执行最后的default部分。需要注意的是，每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。\n需要注意的是`switch`语句后面的表达式，与`case`语句后面的表达式比较运算结果时，采用的严格运算符`===`\n```javascript\nswitch(1+3){\n\tcase 2+2 :\n\tf()\n\tbreak;\n\tdefault:\n\tconsole.log(\"我执行不到\")\n}\n```\n以上代码`console.log(“我执行不到”)`是不会被执行的。\n\n### __三元运算符__\n```javascript\n(条件)？表达式1:表达式2\n```\n如果条件为true，就执行`表达式1`，如果条件为flase，就执行`表达式2`\n\n### __&&短路逻辑__\n`&&`读作and\n```javascript\nA && B && C && D\n```\n跟且运算很像，必须所有都为A，B，C，D都会真的时候，才为真，只有有一个是假的，就为假\n简单的记忆：遇到第一个假值，就显示第一个假值，如果都为真，就显示最后一个。\n\n### __||短路逻辑__\n`||`读作 or\n```javascript\nA || B || C || D\n```\n跟或运行很想，只要A、B、C、D里面有一个是真，就显示第一个真值，如果A、B、C、D都是假，就显示最后一个\n\n## __循环语句__\n### __while循环__\n```javascript\nvar a = 1\nwhile(a<3){\nconsole.log(a)\na = a + 1\n}\n//\na = 1\na = 2\n```\n\n### __do...while循环__\n```javascript\nvar x = 0\ndo{\n\tconsole.log(x)\n\tx = x + 1\n}while(x<5)\n```\ndo里面的语句不管什么情况都必须执行一遍，然后在判断条件，如果条件满足就继续执行，不满足就跳出循环。\n\n### __for循环__\n```javascript\nfor(语句1；表达式1；语句3){\n\t循环体\n}\n```\n`语句1`只有在循环开始的时候执行一次\n`语句2`每次循环开始的时候，都要执行这个语句，只有值为真，才执行循环体。\n`语句3`每轮循环的最后一个操作，通常是用来递增循环变量。\n执行顺序\n第一次，语句1，语句2，循环体，语句3\n第二次，语句2，循环体，语句3\n\n__扩展__\n```javascript\nfor (var a=1 ;a < 5;a++){\n\tsetTimeout(()=>{console.log(a)})\n\t}\n\t正常的是console.log(a),输出1，2，3，4，但是放在setTimeout里面，setTimeout的意思是过一会在执行，所\n\t以以上代码，执行5次，console.log,并且值都是5.\n```\n\n### __Break和Continue__\n`break`是退出当前这个循环，只会退出离他最近的循环\n`continue`用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。\n以上两个跳出都是配置标签来使用的。\n\n### __标签lable__\n```javascript\nfoo:{\n\tconsole.log(1);\n\tbreak foo;\n\tconsole.log(\"不会被执行\")\n}\nconsole.log(2)\n//1\n//2\n```\n上面代码直接跳出了代码块\n\n```javascript\ntop:{\n\tfor(var i = 0;i<3;i++){\n\t\tfor(var j = 0; j<3;j++){\n\t\t\tif(i===1&&j===1)continue top;\n\t\t\tconsole.log(i+j)\n\t\t}\n\t}\n}\n```\n以上代码，`continue`跳到top执行，而不是跳出内层循环。\n\n<div class=\"ea4335\">（完）</div>\n\n参考\n阮一峰的javascript基础教程\n饥人谷\n","source":"_posts/Javascript语句.md","raw":"---\ntitle: Javascript语法\ndate: 2020-10-26 13:22:17\ntags: javascript\ntoc: true\ncover: ./img/javascript.jpg\n---\n> 它的优秀之处并非原创，它的原创之处并不优秀。\n\n以上是JS之父对JS的评价，耐人寻味。\n<!--more-->\n## __语句与表达式__\n`表达式`：为了得到一个值的计算式\n```javascript\n1 + 1\n//2\n3*9\n//27\n```\n`语句`：为了可以完成某种任务而进行的操作，改变环境\n```javascript\nvar a = 3;\n```\n__两者的区别__:\n* `语句`是为了完成某项任务，会改变环境。一般情况下是不需要返回值的。\n* `表达式`是为了得到一个值，并且一定会有一个值。\n\n<div class=\"ff6666\">注意</div>\n\n1. 值和返回值是有区别的，值是表达式返回的，而返回值，是函数返回的，而且只有函数有返回值，`return`后面的值就是函数的返回值\n2. 函数`return`的后面不能跟回车，如果跟了回车，函数的返回值就是`undefined`\n3. `console.log(3)` 的返回值是`undefined` ，而控制台上的3，只是控制打印出来的值，而不是返回值。\n\n## __变量__\n变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。\n```javascript\nvar a = 1;\n```\n以上的`=`并不是\"a等于1\"的意思，这个`=`念做\"赋值给\"，以上的代码的意思是把1这个值赋值给`a`这个变量。\n如果只写一个变量名，而不用`var`来声明的话，浏览器就会报错，告诉你这个变量没有被声明.\n```javascript\n a = 1\n```\n以上的方式也可以声明一个变量，但是不利于表达意图，而且容易不知不觉的创建全部变量\n\n## __标识符__\n标识符也就是变量的名字，给变量取个名字，取名要遵循下面的两条的规定。\n1. 第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线。\n2. 第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。\n\n## __区块__\n使用大括号把多个相关语句组合在一起，成为区块。\n```javascript\nvar a = 1;\nconsole.log(a)\n```\n\n## __条件判断语句__\n只有满足相应的条件，才能执行相应的语句\n### __if....else__\nif结构先判断一个表达式的布尔值，根据布尔值的真伪来执行不同的语句。\n```javascript\nif(布尔值)\n语句；\n\n//或者\nif(布尔值) 语句；\n```\n上面的`布尔值`往往是通过一个表达式产生的。必须放在圆括号里面，表示对表达式求值。\n以上的写法，表达式后面只能有一个语句，如果有多个语句要执行，就要用`{}`括起来。建议总在if语句中使用加大括号，这样方便插入语句。而且不会有歧义。\n```javascript\nvar a = 1;\nif(a === 2)\nconsole.log(a)\nconsole.log('a等于2')\n// a等于2\n\n//等同于\nvar a = 1;\nif(a===2){\nconsole.log(a)\n}\nconsole.log(\"a等于2\")\n```\n\n`if`代码块后面，还可以跟一个`else`代码块，表示不满足条件时，所要执行的代码\n```javascript\nif(布尔值){\n\t//满足条件时，执行的语句\n}else{\n\t//不满足条件时，执行的语句\n}\n```\n<div class=\"ff6666\">注意</div> \n\n`else`只会判断离它最近的`if`\n当要进行多次判断的时候，就可以写成以下格式\n```javascript\n\tif(布尔值){\n\t  // ....\n\t}else if{\n\t  //....\n\t}else if{\n\t  // ....\n\t}else{\n\t\t// ....\n\t}\n```\n\n### __switch语句__\n```javascript\nswitch(变量名/表达式){\n\tcase 值：\n\t语句1；\n\tbreak；\n\tcase 值1：\n\t语句2；\n\tbreak；\n\tdefault：\n\t语句3；\n}\n```\n上面代码根据`switch`括号里的值，选择执行相应的case。如果所有case都不符合，则执行最后的default部分。需要注意的是，每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。\n需要注意的是`switch`语句后面的表达式，与`case`语句后面的表达式比较运算结果时，采用的严格运算符`===`\n```javascript\nswitch(1+3){\n\tcase 2+2 :\n\tf()\n\tbreak;\n\tdefault:\n\tconsole.log(\"我执行不到\")\n}\n```\n以上代码`console.log(“我执行不到”)`是不会被执行的。\n\n### __三元运算符__\n```javascript\n(条件)？表达式1:表达式2\n```\n如果条件为true，就执行`表达式1`，如果条件为flase，就执行`表达式2`\n\n### __&&短路逻辑__\n`&&`读作and\n```javascript\nA && B && C && D\n```\n跟且运算很像，必须所有都为A，B，C，D都会真的时候，才为真，只有有一个是假的，就为假\n简单的记忆：遇到第一个假值，就显示第一个假值，如果都为真，就显示最后一个。\n\n### __||短路逻辑__\n`||`读作 or\n```javascript\nA || B || C || D\n```\n跟或运行很想，只要A、B、C、D里面有一个是真，就显示第一个真值，如果A、B、C、D都是假，就显示最后一个\n\n## __循环语句__\n### __while循环__\n```javascript\nvar a = 1\nwhile(a<3){\nconsole.log(a)\na = a + 1\n}\n//\na = 1\na = 2\n```\n\n### __do...while循环__\n```javascript\nvar x = 0\ndo{\n\tconsole.log(x)\n\tx = x + 1\n}while(x<5)\n```\ndo里面的语句不管什么情况都必须执行一遍，然后在判断条件，如果条件满足就继续执行，不满足就跳出循环。\n\n### __for循环__\n```javascript\nfor(语句1；表达式1；语句3){\n\t循环体\n}\n```\n`语句1`只有在循环开始的时候执行一次\n`语句2`每次循环开始的时候，都要执行这个语句，只有值为真，才执行循环体。\n`语句3`每轮循环的最后一个操作，通常是用来递增循环变量。\n执行顺序\n第一次，语句1，语句2，循环体，语句3\n第二次，语句2，循环体，语句3\n\n__扩展__\n```javascript\nfor (var a=1 ;a < 5;a++){\n\tsetTimeout(()=>{console.log(a)})\n\t}\n\t正常的是console.log(a),输出1，2，3，4，但是放在setTimeout里面，setTimeout的意思是过一会在执行，所\n\t以以上代码，执行5次，console.log,并且值都是5.\n```\n\n### __Break和Continue__\n`break`是退出当前这个循环，只会退出离他最近的循环\n`continue`用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。\n以上两个跳出都是配置标签来使用的。\n\n### __标签lable__\n```javascript\nfoo:{\n\tconsole.log(1);\n\tbreak foo;\n\tconsole.log(\"不会被执行\")\n}\nconsole.log(2)\n//1\n//2\n```\n上面代码直接跳出了代码块\n\n```javascript\ntop:{\n\tfor(var i = 0;i<3;i++){\n\t\tfor(var j = 0; j<3;j++){\n\t\t\tif(i===1&&j===1)continue top;\n\t\t\tconsole.log(i+j)\n\t\t}\n\t}\n}\n```\n以上代码，`continue`跳到top执行，而不是跳出内层循环。\n\n<div class=\"ea4335\">（完）</div>\n\n参考\n阮一峰的javascript基础教程\n饥人谷\n","slug":"Javascript语句","published":1,"updated":"2020-10-26T16:27:52.076Z","_id":"ckgqko9qw0000mrfq16vf07u2","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>它的优秀之处并非原创，它的原创之处并不优秀。</p>\n</blockquote>\n<p>以上是JS之父对JS的评价，耐人寻味。</p>\n<a id=\"more\"></a>\n<h2 id=\"语句与表达式\"><a href=\"#语句与表达式\" class=\"headerlink\" title=\"语句与表达式\"></a><strong>语句与表达式</strong></h2><p><code>表达式</code>：为了得到一个值的计算式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"number\">3</span>*<span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"comment\">//27</span></span><br></pre></td></tr></table></figure>\n<p><code>语句</code>：为了可以完成某种任务而进行的操作，改变环境</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>两者的区别</strong>:</p>\n<ul>\n<li><code>语句</code>是为了完成某项任务，会改变环境。一般情况下是不需要返回值的。</li>\n<li><code>表达式</code>是为了得到一个值，并且一定会有一个值。</li>\n</ul>\n<div class=\"ff6666\">注意</div>\n\n<ol>\n<li>值和返回值是有区别的，值是表达式返回的，而返回值，是函数返回的，而且只有函数有返回值，<code>return</code>后面的值就是函数的返回值</li>\n<li>函数<code>return</code>的后面不能跟回车，如果跟了回车，函数的返回值就是<code>undefined</code></li>\n<li><code>console.log(3)</code> 的返回值是<code>undefined</code> ，而控制台上的3，只是控制打印出来的值，而不是返回值。</li>\n</ol>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a><strong>变量</strong></h2><p>变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>以上的<code>=</code>并不是”a等于1”的意思，这个<code>=</code>念做”赋值给”，以上的代码的意思是把1这个值赋值给<code>a</code>这个变量。<br>如果只写一个变量名，而不用<code>var</code>来声明的话，浏览器就会报错，告诉你这个变量没有被声明.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>以上的方式也可以声明一个变量，但是不利于表达意图，而且容易不知不觉的创建全部变量</p>\n<h2 id=\"标识符\"><a href=\"#标识符\" class=\"headerlink\" title=\"标识符\"></a><strong>标识符</strong></h2><p>标识符也就是变量的名字，给变量取个名字，取名要遵循下面的两条的规定。</p>\n<ol>\n<li>第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线。</li>\n<li>第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。</li>\n</ol>\n<h2 id=\"区块\"><a href=\"#区块\" class=\"headerlink\" title=\"区块\"></a><strong>区块</strong></h2><p>使用大括号把多个相关语句组合在一起，成为区块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"条件判断语句\"><a href=\"#条件判断语句\" class=\"headerlink\" title=\"条件判断语句\"></a><strong>条件判断语句</strong></h2><p>只有满足相应的条件，才能执行相应的语句</p>\n<h3 id=\"if…-else\"><a href=\"#if…-else\" class=\"headerlink\" title=\"if….else\"></a><strong>if….else</strong></h3><p>if结构先判断一个表达式的布尔值，根据布尔值的真伪来执行不同的语句。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(布尔值)</span><br><span class=\"line\">语句；</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//或者</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(布尔值) 语句；</span><br></pre></td></tr></table></figure>\n<p>上面的<code>布尔值</code>往往是通过一个表达式产生的。必须放在圆括号里面，表示对表达式求值。<br>以上的写法，表达式后面只能有一个语句，如果有多个语句要执行，就要用<code>&#123;&#125;</code>括起来。建议总在if语句中使用加大括号，这样方便插入语句。而且不会有歧义。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(a === <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;a等于2&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">// a等于2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//等同于</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(a===<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;a等于2&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><code>if</code>代码块后面，还可以跟一个<code>else</code>代码块，表示不满足条件时，所要执行的代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(布尔值)&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//满足条件时，执行的语句</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//不满足条件时，执行的语句</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"ff6666\">注意</div> \n\n<p><code>else</code>只会判断离它最近的<code>if</code><br>当要进行多次判断的时候，就可以写成以下格式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(布尔值)&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ....</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//....</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ....</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// ....</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"switch语句\"><a href=\"#switch语句\" class=\"headerlink\" title=\"switch语句\"></a><strong>switch语句</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(变量名/表达式)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> 值：</span><br><span class=\"line\">\t语句<span class=\"number\">1</span>；</span><br><span class=\"line\">\t<span class=\"keyword\">break</span>；</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> 值<span class=\"number\">1</span>：</span><br><span class=\"line\">\t语句<span class=\"number\">2</span>；</span><br><span class=\"line\">\t<span class=\"keyword\">break</span>；</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>：</span><br><span class=\"line\">\t语句<span class=\"number\">3</span>；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码根据<code>switch</code>括号里的值，选择执行相应的case。如果所有case都不符合，则执行最后的default部分。需要注意的是，每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。<br>需要注意的是<code>switch</code>语句后面的表达式，与<code>case</code>语句后面的表达式比较运算结果时，采用的严格运算符<code>===</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(<span class=\"number\">1</span>+<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">2</span>+<span class=\"number\">2</span> :</span><br><span class=\"line\">\tf()</span><br><span class=\"line\">\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;我执行不到&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码<code>console.log(“我执行不到”)</code>是不会被执行的。</p>\n<h3 id=\"三元运算符\"><a href=\"#三元运算符\" class=\"headerlink\" title=\"三元运算符\"></a><strong>三元运算符</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(条件)？表达式<span class=\"number\">1</span>:表达式<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>如果条件为true，就执行<code>表达式1</code>，如果条件为flase，就执行<code>表达式2</code></p>\n<h3 id=\"amp-amp-短路逻辑\"><a href=\"#amp-amp-短路逻辑\" class=\"headerlink\" title=\"&amp;&amp;短路逻辑\"></a><strong>&amp;&amp;短路逻辑</strong></h3><p><code>&amp;&amp;</code>读作and</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A &amp;&amp; B &amp;&amp; C &amp;&amp; D</span><br></pre></td></tr></table></figure>\n<p>跟且运算很像，必须所有都为A，B，C，D都会真的时候，才为真，只有有一个是假的，就为假<br>简单的记忆：遇到第一个假值，就显示第一个假值，如果都为真，就显示最后一个。</p>\n<h3 id=\"短路逻辑\"><a href=\"#短路逻辑\" class=\"headerlink\" title=\"||短路逻辑\"></a><strong>||短路逻辑</strong></h3><p><code>||</code>读作 or</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A || B || C || D</span><br></pre></td></tr></table></figure>\n<p>跟或运行很想，只要A、B、C、D里面有一个是真，就显示第一个真值，如果A、B、C、D都是假，就显示最后一个</p>\n<h2 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a><strong>循环语句</strong></h2><h3 id=\"while循环\"><a href=\"#while循环\" class=\"headerlink\" title=\"while循环\"></a><strong>while循环</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(a&lt;<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a)</span><br><span class=\"line\">a = a + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\">a = <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"do…while循环\"><a href=\"#do…while循环\" class=\"headerlink\" title=\"do…while循环\"></a><strong>do…while循环</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(x)</span><br><span class=\"line\">\tx = x + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">while</span>(x&lt;<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n<p>do里面的语句不管什么情况都必须执行一遍，然后在判断条件，如果条件满足就继续执行，不满足就跳出循环。</p>\n<h3 id=\"for循环\"><a href=\"#for循环\" class=\"headerlink\" title=\"for循环\"></a><strong>for循环</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(语句<span class=\"number\">1</span>；表达式<span class=\"number\">1</span>；语句<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">\t循环体</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>语句1</code>只有在循环开始的时候执行一次<br><code>语句2</code>每次循环开始的时候，都要执行这个语句，只有值为真，才执行循环体。<br><code>语句3</code>每轮循环的最后一个操作，通常是用来递增循环变量。<br>执行顺序<br>第一次，语句1，语句2，循环体，语句3<br>第二次，语句2，循环体，语句3</p>\n<p><strong>扩展</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> a=<span class=\"number\">1</span> ;a &lt; <span class=\"number\">5</span>;a++)&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;<span class=\"built_in\">console</span>.log(a)&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t正常的是<span class=\"built_in\">console</span>.log(a),输出<span class=\"number\">1</span>，<span class=\"number\">2</span>，<span class=\"number\">3</span>，<span class=\"number\">4</span>，但是放在<span class=\"built_in\">setTimeout</span>里面，<span class=\"built_in\">setTimeout</span>的意思是过一会在执行，所</span><br><span class=\"line\">\t以以上代码，执行<span class=\"number\">5</span>次，<span class=\"built_in\">console</span>.log,并且值都是<span class=\"number\">5.</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Break和Continue\"><a href=\"#Break和Continue\" class=\"headerlink\" title=\"Break和Continue\"></a><strong>Break和Continue</strong></h3><p><code>break</code>是退出当前这个循环，只会退出离他最近的循环<br><code>continue</code>用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。<br>以上两个跳出都是配置标签来使用的。</p>\n<h3 id=\"标签lable\"><a href=\"#标签lable\" class=\"headerlink\" title=\"标签lable\"></a><strong>标签lable</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo:&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">break</span> foo;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;不会被执行&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<p>上面代码直接跳出了代码块</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top:&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j&lt;<span class=\"number\">3</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(i===<span class=\"number\">1</span>&amp;&amp;j===<span class=\"number\">1</span>)<span class=\"keyword\">continue</span> top;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(i+j)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码，<code>continue</code>跳到top执行，而不是跳出内层循环。</p>\n<div class=\"ea4335\">（完）</div>\n\n<p>参考<br>阮一峰的javascript基础教程<br>饥人谷</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>它的优秀之处并非原创，它的原创之处并不优秀。</p>\n</blockquote>\n<p>以上是JS之父对JS的评价，耐人寻味。</p>","more":"<h2 id=\"语句与表达式\"><a href=\"#语句与表达式\" class=\"headerlink\" title=\"语句与表达式\"></a><strong>语句与表达式</strong></h2><p><code>表达式</code>：为了得到一个值的计算式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"number\">3</span>*<span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"comment\">//27</span></span><br></pre></td></tr></table></figure>\n<p><code>语句</code>：为了可以完成某种任务而进行的操作，改变环境</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>两者的区别</strong>:</p>\n<ul>\n<li><code>语句</code>是为了完成某项任务，会改变环境。一般情况下是不需要返回值的。</li>\n<li><code>表达式</code>是为了得到一个值，并且一定会有一个值。</li>\n</ul>\n<div class=\"ff6666\">注意</div>\n\n<ol>\n<li>值和返回值是有区别的，值是表达式返回的，而返回值，是函数返回的，而且只有函数有返回值，<code>return</code>后面的值就是函数的返回值</li>\n<li>函数<code>return</code>的后面不能跟回车，如果跟了回车，函数的返回值就是<code>undefined</code></li>\n<li><code>console.log(3)</code> 的返回值是<code>undefined</code> ，而控制台上的3，只是控制打印出来的值，而不是返回值。</li>\n</ol>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a><strong>变量</strong></h2><p>变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>以上的<code>=</code>并不是”a等于1”的意思，这个<code>=</code>念做”赋值给”，以上的代码的意思是把1这个值赋值给<code>a</code>这个变量。<br>如果只写一个变量名，而不用<code>var</code>来声明的话，浏览器就会报错，告诉你这个变量没有被声明.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>以上的方式也可以声明一个变量，但是不利于表达意图，而且容易不知不觉的创建全部变量</p>\n<h2 id=\"标识符\"><a href=\"#标识符\" class=\"headerlink\" title=\"标识符\"></a><strong>标识符</strong></h2><p>标识符也就是变量的名字，给变量取个名字，取名要遵循下面的两条的规定。</p>\n<ol>\n<li>第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线。</li>\n<li>第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。</li>\n</ol>\n<h2 id=\"区块\"><a href=\"#区块\" class=\"headerlink\" title=\"区块\"></a><strong>区块</strong></h2><p>使用大括号把多个相关语句组合在一起，成为区块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"条件判断语句\"><a href=\"#条件判断语句\" class=\"headerlink\" title=\"条件判断语句\"></a><strong>条件判断语句</strong></h2><p>只有满足相应的条件，才能执行相应的语句</p>\n<h3 id=\"if…-else\"><a href=\"#if…-else\" class=\"headerlink\" title=\"if….else\"></a><strong>if….else</strong></h3><p>if结构先判断一个表达式的布尔值，根据布尔值的真伪来执行不同的语句。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(布尔值)</span><br><span class=\"line\">语句；</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//或者</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(布尔值) 语句；</span><br></pre></td></tr></table></figure>\n<p>上面的<code>布尔值</code>往往是通过一个表达式产生的。必须放在圆括号里面，表示对表达式求值。<br>以上的写法，表达式后面只能有一个语句，如果有多个语句要执行，就要用<code>&#123;&#125;</code>括起来。建议总在if语句中使用加大括号，这样方便插入语句。而且不会有歧义。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(a === <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;a等于2&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">// a等于2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//等同于</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(a===<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;a等于2&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><code>if</code>代码块后面，还可以跟一个<code>else</code>代码块，表示不满足条件时，所要执行的代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(布尔值)&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//满足条件时，执行的语句</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//不满足条件时，执行的语句</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"ff6666\">注意</div> \n\n<p><code>else</code>只会判断离它最近的<code>if</code><br>当要进行多次判断的时候，就可以写成以下格式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(布尔值)&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ....</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//....</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ....</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// ....</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"switch语句\"><a href=\"#switch语句\" class=\"headerlink\" title=\"switch语句\"></a><strong>switch语句</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(变量名/表达式)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> 值：</span><br><span class=\"line\">\t语句<span class=\"number\">1</span>；</span><br><span class=\"line\">\t<span class=\"keyword\">break</span>；</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> 值<span class=\"number\">1</span>：</span><br><span class=\"line\">\t语句<span class=\"number\">2</span>；</span><br><span class=\"line\">\t<span class=\"keyword\">break</span>；</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>：</span><br><span class=\"line\">\t语句<span class=\"number\">3</span>；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码根据<code>switch</code>括号里的值，选择执行相应的case。如果所有case都不符合，则执行最后的default部分。需要注意的是，每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。<br>需要注意的是<code>switch</code>语句后面的表达式，与<code>case</code>语句后面的表达式比较运算结果时，采用的严格运算符<code>===</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(<span class=\"number\">1</span>+<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">2</span>+<span class=\"number\">2</span> :</span><br><span class=\"line\">\tf()</span><br><span class=\"line\">\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;我执行不到&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码<code>console.log(“我执行不到”)</code>是不会被执行的。</p>\n<h3 id=\"三元运算符\"><a href=\"#三元运算符\" class=\"headerlink\" title=\"三元运算符\"></a><strong>三元运算符</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(条件)？表达式<span class=\"number\">1</span>:表达式<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>如果条件为true，就执行<code>表达式1</code>，如果条件为flase，就执行<code>表达式2</code></p>\n<h3 id=\"amp-amp-短路逻辑\"><a href=\"#amp-amp-短路逻辑\" class=\"headerlink\" title=\"&amp;&amp;短路逻辑\"></a><strong>&amp;&amp;短路逻辑</strong></h3><p><code>&amp;&amp;</code>读作and</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A &amp;&amp; B &amp;&amp; C &amp;&amp; D</span><br></pre></td></tr></table></figure>\n<p>跟且运算很像，必须所有都为A，B，C，D都会真的时候，才为真，只有有一个是假的，就为假<br>简单的记忆：遇到第一个假值，就显示第一个假值，如果都为真，就显示最后一个。</p>\n<h3 id=\"短路逻辑\"><a href=\"#短路逻辑\" class=\"headerlink\" title=\"||短路逻辑\"></a><strong>||短路逻辑</strong></h3><p><code>||</code>读作 or</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A || B || C || D</span><br></pre></td></tr></table></figure>\n<p>跟或运行很想，只要A、B、C、D里面有一个是真，就显示第一个真值，如果A、B、C、D都是假，就显示最后一个</p>\n<h2 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a><strong>循环语句</strong></h2><h3 id=\"while循环\"><a href=\"#while循环\" class=\"headerlink\" title=\"while循环\"></a><strong>while循环</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(a&lt;<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a)</span><br><span class=\"line\">a = a + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\">a = <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"do…while循环\"><a href=\"#do…while循环\" class=\"headerlink\" title=\"do…while循环\"></a><strong>do…while循环</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(x)</span><br><span class=\"line\">\tx = x + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">while</span>(x&lt;<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n<p>do里面的语句不管什么情况都必须执行一遍，然后在判断条件，如果条件满足就继续执行，不满足就跳出循环。</p>\n<h3 id=\"for循环\"><a href=\"#for循环\" class=\"headerlink\" title=\"for循环\"></a><strong>for循环</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(语句<span class=\"number\">1</span>；表达式<span class=\"number\">1</span>；语句<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">\t循环体</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>语句1</code>只有在循环开始的时候执行一次<br><code>语句2</code>每次循环开始的时候，都要执行这个语句，只有值为真，才执行循环体。<br><code>语句3</code>每轮循环的最后一个操作，通常是用来递增循环变量。<br>执行顺序<br>第一次，语句1，语句2，循环体，语句3<br>第二次，语句2，循环体，语句3</p>\n<p><strong>扩展</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> a=<span class=\"number\">1</span> ;a &lt; <span class=\"number\">5</span>;a++)&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;<span class=\"built_in\">console</span>.log(a)&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t正常的是<span class=\"built_in\">console</span>.log(a),输出<span class=\"number\">1</span>，<span class=\"number\">2</span>，<span class=\"number\">3</span>，<span class=\"number\">4</span>，但是放在<span class=\"built_in\">setTimeout</span>里面，<span class=\"built_in\">setTimeout</span>的意思是过一会在执行，所</span><br><span class=\"line\">\t以以上代码，执行<span class=\"number\">5</span>次，<span class=\"built_in\">console</span>.log,并且值都是<span class=\"number\">5.</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Break和Continue\"><a href=\"#Break和Continue\" class=\"headerlink\" title=\"Break和Continue\"></a><strong>Break和Continue</strong></h3><p><code>break</code>是退出当前这个循环，只会退出离他最近的循环<br><code>continue</code>用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。<br>以上两个跳出都是配置标签来使用的。</p>\n<h3 id=\"标签lable\"><a href=\"#标签lable\" class=\"headerlink\" title=\"标签lable\"></a><strong>标签lable</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo:&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">break</span> foo;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;不会被执行&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<p>上面代码直接跳出了代码块</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top:&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j&lt;<span class=\"number\">3</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(i===<span class=\"number\">1</span>&amp;&amp;j===<span class=\"number\">1</span>)<span class=\"keyword\">continue</span> top;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(i+j)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码，<code>continue</code>跳到top执行，而不是跳出内层循环。</p>\n<div class=\"ea4335\">（完）</div>\n\n<p>参考<br>阮一峰的javascript基础教程<br>饥人谷</p>"},{"title":"JS数据类型（上）","date":"2020-10-30T15:41:16.000Z","toc":true,"cover":"./img/javascript.jpg","_content":"## __如何存字符__\n内存上只能存`0`和`1`所以把10进制数，存成2进制数，就可以把数字存到内存里面。\n存完数字以后，然后要思考怎么存字母，0~127（2的8次方）把所有字母和数字和符号，如下图\n<!--more-->\n<div align=\"center\"><img src=\"./img/img1.png\"></div>\n\n1. 要考虑存汉字，中国国标局来遍号，俗称国标\n2. 用16进制来(1,2,3,4,5,6,7,8,9，A，B，C，D，E，F)存汉字，从0000~FFFF来存汉字，所以汉字是2个字节\n3. 后来出现生僻字和日本，韩语的文字，后来出现了「国标扩」\n4. 继续扩展，把全球所有文字都收录，编号，出现了unicode，俗称万国码\n5. utf-8，是对unicode的一种节约储存方式\n\n## __数据类型__\n为什么数据需要分类型呢？因为数字是数字，字符串是字符串，程序员都需要严谨。举个例子，字符串可以表示电话号码，但是数字不行，因为有些电话号码是`010`开头的，这样的话，如果用数字就会省略前面的`0`,无法正确表示电话号码.\n* 数值\n* 字符串\n* 布尔值\n* undefined\n* null\n* 对象\n* Symbol\n* bigint\n\n`数值` `字符串` `布尔值` 是三个最基本的数据类型，已经不能再细分了。对象是合成型的数据类型。\n\n`typeof`运算符可以确定一个值到底是什么类型\n```\ntypeof 123 //\"number\"\ntypeof \"123\" //\"String\"\ntypeof false //\"boolean\"\n```\n\n## __null,undefined,布尔值__\n`null`和`undefined`都可以表示没有，含义是非常相似。将一个变量赋值为`null`和`undefined`，语法效果几乎没有区别。\n### __细节__\n1. 如果一个变量声明了，但没有赋值，那么默认值是undefined，而不是null\n2. 如果一个函数，没有写return，那么默认return undefined，而不是null\n3. 把非对象的空值写成undefined，把对象的空值写成null\n\n### __为什么JS会有两个空值__\nJavaScript 的设计者 Brendan Eich，觉得这样做还不够。首先，第一版的 JavaScript 里面，`null`就像在Java 里一样，被当成一个对象，Brendan Eich 觉得表示“无”的值最好不是对象。其次，那时的 JavaScript 不包括错误处理机制，Brendan Eich 觉得，如果`null`自动转为0，很不容易发现错误。因此，他又设计了一个`undefined`。区别是这样的：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示\"此处无定义\"的原始值，转为数值时为NaN。\n\n`undefined`表示未定义，下面是返回`undefined`的典型场景\n```javascript\nvar i;\ni //undefined\n//变量声明了，但是没有赋值时\n\nfunction f(x){\nreturn x;\n}\nf() // undefined\n//调用函数时，应该提供的参数没有提供，该参数就等于 undefined\n\nvar o = new Object()\no.p // undefined\n//对象没有赋值的属性\n\nfunction f(){}\nf() //undefined\n//函数没有返回值的时候，默认返回undefined\n```\n\n### __布尔值__\n布尔值代表`真`和`假`，真的关键字是`true`,假的关键字是`flase`,布尔值只有这两个值。\n下面运行符会返回布尔值：\n* 前置逻辑运算符：`!`(Not)\n* 相等运算符：`===` `!==` `==` `!=`\n* 比较运算符：`>` `>=` `<` `<=`\n\n如果JS预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值，转换规则是除了下面六个值被转为`flase`，其他值都是为`true`\n* undefined\n* null\n* flase\n* 0\n* NaN\n* ‘’（空字符串）\n\n## __数值__\njavascript内部,所有数字都是以64位浮点数形式储存，即使整数也是如此。`1`和`1.0`是相同的，是同一个数。这就是说，javascript语言的底层根本没有整数，所有的数字都是小数，由于浮点数不是精确的值\n```javascript\n(0.3 - 0.1) === (0.2 - 0.1)\n// flase\n```\n\n<div align=\"center\"><img src=\"./img/img2.png\"></div>\n\n第1位：符号位，`0`表示整数，`1`表示负数\n第2位到第12位(共11位)：指数部分\n第13位到第64位（共56位）：小数部分（有效部分）\n符号位决定了一个数是正数还是负数，指数部分决定了数值的大小，小数部分决定了数值的精度。\n\n### __NaN__\n含义：NaN是javascript的特殊值，表示非数字(Not a Number)，主要出现在将字符串解析成数字出错的场所。\nNaN可以理解成，无法表示的数字。但是他也是个数字，只是我们现在不知道怎么描述的数字。\n\n### __isNaN()__\n`isNaN()`方法可以用来判断一个值是否为NaN。\n\n## __字符串__\n字符串就是零个或多个排在一起的字符，放在单引号`''`或者双引号`\"\"`之中\n单引号字符串内部，可以使用双引号。双引号字符串的内部，可以使用单引号。\n如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。`\\`\n使用反引号，可以把字符串写成多行。\n\n### __转义__\n用另一种写法表示你想要的的东西\n* \\' 表示`'`\n* \\\" 表示`\"`\n* \\n 表示换行\n* \\r 表示回车\n* \\t 表示tab制表符\n还有很多转义，用的时候Google就行了\n\n### __属性__\n1. `string.length` 可以查看string的长度。\n2. `string[index]` 通过下标读取字符串中的某一个字符，下标都是从0开始的\n\n### __Base64转码__\nwindow.btoa(\"string\")\n正常的字符串转为base64编码字符串\nwindow.atob(\"string\")\nbase64编码的字符串转为原来的字符串\n## __互相转换__\n__number转string__\n1. String(n) \n2. n + '' \n\n__string转number__\n1. Number(s)\n2. s - 0\n3. parsInt(\"123\") \n\n__任何东西转boole__\n1. Boolean(任何东西)\n2. !!任何东西\n\n__任何东西转String__\nString(任何东西)\n任何东西.toString()\n\n## __变量声明__\n`let声明`\n作用块作用域，不能超过`{}`\n不能重复声明\n可以赋值，也可以不赋值\n必须先声明，在使用\n全局声明，不会变成`window`的属性\n\n`const声明`\n跟let一样\n唯一的区别是声明的时候，必须赋值，赋值以后不能更改\n\n__细节__\n变量声明，即给了值，也指定的了类型。\nname和\"name\"的区别\nname是一个变量，“name”是一个字符串\n\n(完)\n\n资料参考\n1.饥人谷\n2.阮一峰网道javascript教程\n\n\n\n","source":"_posts/JS数据类型（上）.md","raw":"---\ntitle: JS数据类型（上）\ndate: 2020-10-30 15:41:16\ntags: javascript\ntoc: true\ncover: ./img/javascript.jpg\n---\n## __如何存字符__\n内存上只能存`0`和`1`所以把10进制数，存成2进制数，就可以把数字存到内存里面。\n存完数字以后，然后要思考怎么存字母，0~127（2的8次方）把所有字母和数字和符号，如下图\n<!--more-->\n<div align=\"center\"><img src=\"./img/img1.png\"></div>\n\n1. 要考虑存汉字，中国国标局来遍号，俗称国标\n2. 用16进制来(1,2,3,4,5,6,7,8,9，A，B，C，D，E，F)存汉字，从0000~FFFF来存汉字，所以汉字是2个字节\n3. 后来出现生僻字和日本，韩语的文字，后来出现了「国标扩」\n4. 继续扩展，把全球所有文字都收录，编号，出现了unicode，俗称万国码\n5. utf-8，是对unicode的一种节约储存方式\n\n## __数据类型__\n为什么数据需要分类型呢？因为数字是数字，字符串是字符串，程序员都需要严谨。举个例子，字符串可以表示电话号码，但是数字不行，因为有些电话号码是`010`开头的，这样的话，如果用数字就会省略前面的`0`,无法正确表示电话号码.\n* 数值\n* 字符串\n* 布尔值\n* undefined\n* null\n* 对象\n* Symbol\n* bigint\n\n`数值` `字符串` `布尔值` 是三个最基本的数据类型，已经不能再细分了。对象是合成型的数据类型。\n\n`typeof`运算符可以确定一个值到底是什么类型\n```\ntypeof 123 //\"number\"\ntypeof \"123\" //\"String\"\ntypeof false //\"boolean\"\n```\n\n## __null,undefined,布尔值__\n`null`和`undefined`都可以表示没有，含义是非常相似。将一个变量赋值为`null`和`undefined`，语法效果几乎没有区别。\n### __细节__\n1. 如果一个变量声明了，但没有赋值，那么默认值是undefined，而不是null\n2. 如果一个函数，没有写return，那么默认return undefined，而不是null\n3. 把非对象的空值写成undefined，把对象的空值写成null\n\n### __为什么JS会有两个空值__\nJavaScript 的设计者 Brendan Eich，觉得这样做还不够。首先，第一版的 JavaScript 里面，`null`就像在Java 里一样，被当成一个对象，Brendan Eich 觉得表示“无”的值最好不是对象。其次，那时的 JavaScript 不包括错误处理机制，Brendan Eich 觉得，如果`null`自动转为0，很不容易发现错误。因此，他又设计了一个`undefined`。区别是这样的：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示\"此处无定义\"的原始值，转为数值时为NaN。\n\n`undefined`表示未定义，下面是返回`undefined`的典型场景\n```javascript\nvar i;\ni //undefined\n//变量声明了，但是没有赋值时\n\nfunction f(x){\nreturn x;\n}\nf() // undefined\n//调用函数时，应该提供的参数没有提供，该参数就等于 undefined\n\nvar o = new Object()\no.p // undefined\n//对象没有赋值的属性\n\nfunction f(){}\nf() //undefined\n//函数没有返回值的时候，默认返回undefined\n```\n\n### __布尔值__\n布尔值代表`真`和`假`，真的关键字是`true`,假的关键字是`flase`,布尔值只有这两个值。\n下面运行符会返回布尔值：\n* 前置逻辑运算符：`!`(Not)\n* 相等运算符：`===` `!==` `==` `!=`\n* 比较运算符：`>` `>=` `<` `<=`\n\n如果JS预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值，转换规则是除了下面六个值被转为`flase`，其他值都是为`true`\n* undefined\n* null\n* flase\n* 0\n* NaN\n* ‘’（空字符串）\n\n## __数值__\njavascript内部,所有数字都是以64位浮点数形式储存，即使整数也是如此。`1`和`1.0`是相同的，是同一个数。这就是说，javascript语言的底层根本没有整数，所有的数字都是小数，由于浮点数不是精确的值\n```javascript\n(0.3 - 0.1) === (0.2 - 0.1)\n// flase\n```\n\n<div align=\"center\"><img src=\"./img/img2.png\"></div>\n\n第1位：符号位，`0`表示整数，`1`表示负数\n第2位到第12位(共11位)：指数部分\n第13位到第64位（共56位）：小数部分（有效部分）\n符号位决定了一个数是正数还是负数，指数部分决定了数值的大小，小数部分决定了数值的精度。\n\n### __NaN__\n含义：NaN是javascript的特殊值，表示非数字(Not a Number)，主要出现在将字符串解析成数字出错的场所。\nNaN可以理解成，无法表示的数字。但是他也是个数字，只是我们现在不知道怎么描述的数字。\n\n### __isNaN()__\n`isNaN()`方法可以用来判断一个值是否为NaN。\n\n## __字符串__\n字符串就是零个或多个排在一起的字符，放在单引号`''`或者双引号`\"\"`之中\n单引号字符串内部，可以使用双引号。双引号字符串的内部，可以使用单引号。\n如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。`\\`\n使用反引号，可以把字符串写成多行。\n\n### __转义__\n用另一种写法表示你想要的的东西\n* \\' 表示`'`\n* \\\" 表示`\"`\n* \\n 表示换行\n* \\r 表示回车\n* \\t 表示tab制表符\n还有很多转义，用的时候Google就行了\n\n### __属性__\n1. `string.length` 可以查看string的长度。\n2. `string[index]` 通过下标读取字符串中的某一个字符，下标都是从0开始的\n\n### __Base64转码__\nwindow.btoa(\"string\")\n正常的字符串转为base64编码字符串\nwindow.atob(\"string\")\nbase64编码的字符串转为原来的字符串\n## __互相转换__\n__number转string__\n1. String(n) \n2. n + '' \n\n__string转number__\n1. Number(s)\n2. s - 0\n3. parsInt(\"123\") \n\n__任何东西转boole__\n1. Boolean(任何东西)\n2. !!任何东西\n\n__任何东西转String__\nString(任何东西)\n任何东西.toString()\n\n## __变量声明__\n`let声明`\n作用块作用域，不能超过`{}`\n不能重复声明\n可以赋值，也可以不赋值\n必须先声明，在使用\n全局声明，不会变成`window`的属性\n\n`const声明`\n跟let一样\n唯一的区别是声明的时候，必须赋值，赋值以后不能更改\n\n__细节__\n变量声明，即给了值，也指定的了类型。\nname和\"name\"的区别\nname是一个变量，“name”是一个字符串\n\n(完)\n\n资料参考\n1.饥人谷\n2.阮一峰网道javascript教程\n\n\n\n","slug":"JS数据类型（上）","published":1,"updated":"2020-10-31T14:02:21.949Z","_id":"ckgwfeojw0000snfqf8fohy1c","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"如何存字符\"><a href=\"#如何存字符\" class=\"headerlink\" title=\"如何存字符\"></a><strong>如何存字符</strong></h2><p>内存上只能存<code>0</code>和<code>1</code>所以把10进制数，存成2进制数，就可以把数字存到内存里面。<br>存完数字以后，然后要思考怎么存字母，0~127（2的8次方）把所有字母和数字和符号，如下图</p>\n<a id=\"more\"></a>\n<div align=\"center\"><img src=\"./img/img1.png\"></div>\n\n<ol>\n<li>要考虑存汉字，中国国标局来遍号，俗称国标</li>\n<li>用16进制来(1,2,3,4,5,6,7,8,9，A，B，C，D，E，F)存汉字，从0000~FFFF来存汉字，所以汉字是2个字节</li>\n<li>后来出现生僻字和日本，韩语的文字，后来出现了「国标扩」</li>\n<li>继续扩展，把全球所有文字都收录，编号，出现了unicode，俗称万国码</li>\n<li>utf-8，是对unicode的一种节约储存方式</li>\n</ol>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a><strong>数据类型</strong></h2><p>为什么数据需要分类型呢？因为数字是数字，字符串是字符串，程序员都需要严谨。举个例子，字符串可以表示电话号码，但是数字不行，因为有些电话号码是<code>010</code>开头的，这样的话，如果用数字就会省略前面的<code>0</code>,无法正确表示电话号码.</p>\n<ul>\n<li>数值</li>\n<li>字符串</li>\n<li>布尔值</li>\n<li>undefined</li>\n<li>null</li>\n<li>对象</li>\n<li>Symbol</li>\n<li>bigint</li>\n</ul>\n<p><code>数值</code> <code>字符串</code> <code>布尔值</code> 是三个最基本的数据类型，已经不能再细分了。对象是合成型的数据类型。</p>\n<p><code>typeof</code>运算符可以确定一个值到底是什么类型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof 123 &#x2F;&#x2F;&quot;number&quot;</span><br><span class=\"line\">typeof &quot;123&quot; &#x2F;&#x2F;&quot;String&quot;</span><br><span class=\"line\">typeof false &#x2F;&#x2F;&quot;boolean&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"null-undefined-布尔值\"><a href=\"#null-undefined-布尔值\" class=\"headerlink\" title=\"null,undefined,布尔值\"></a><strong>null,undefined,布尔值</strong></h2><p><code>null</code>和<code>undefined</code>都可以表示没有，含义是非常相似。将一个变量赋值为<code>null</code>和<code>undefined</code>，语法效果几乎没有区别。</p>\n<h3 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a><strong>细节</strong></h3><ol>\n<li>如果一个变量声明了，但没有赋值，那么默认值是undefined，而不是null</li>\n<li>如果一个函数，没有写return，那么默认return undefined，而不是null</li>\n<li>把非对象的空值写成undefined，把对象的空值写成null</li>\n</ol>\n<h3 id=\"为什么JS会有两个空值\"><a href=\"#为什么JS会有两个空值\" class=\"headerlink\" title=\"为什么JS会有两个空值\"></a><strong>为什么JS会有两个空值</strong></h3><p>JavaScript 的设计者 Brendan Eich，觉得这样做还不够。首先，第一版的 JavaScript 里面，<code>null</code>就像在Java 里一样，被当成一个对象，Brendan Eich 觉得表示“无”的值最好不是对象。其次，那时的 JavaScript 不包括错误处理机制，Brendan Eich 觉得，如果<code>null</code>自动转为0，很不容易发现错误。因此，他又设计了一个<code>undefined</code>。区别是这样的：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。</p>\n<p><code>undefined</code>表示未定义，下面是返回<code>undefined</code>的典型场景</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i;</span><br><span class=\"line\">i <span class=\"comment\">//undefined</span></span><br><span class=\"line\"><span class=\"comment\">//变量声明了，但是没有赋值时</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f() <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"comment\">//调用函数时，应该提供的参数没有提供，该参数就等于 undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>()</span><br><span class=\"line\">o.p <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"comment\">//对象没有赋值的属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">f() <span class=\"comment\">//undefined</span></span><br><span class=\"line\"><span class=\"comment\">//函数没有返回值的时候，默认返回undefined</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a><strong>布尔值</strong></h3><p>布尔值代表<code>真</code>和<code>假</code>，真的关键字是<code>true</code>,假的关键字是<code>flase</code>,布尔值只有这两个值。<br>下面运行符会返回布尔值：</p>\n<ul>\n<li>前置逻辑运算符：<code>!</code>(Not)</li>\n<li>相等运算符：<code>===</code> <code>!==</code> <code>==</code> <code>!=</code></li>\n<li>比较运算符：<code>&gt;</code> <code>&gt;=</code> <code>&lt;</code> <code>&lt;=</code></li>\n</ul>\n<p>如果JS预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值，转换规则是除了下面六个值被转为<code>flase</code>，其他值都是为<code>true</code></p>\n<ul>\n<li>undefined</li>\n<li>null</li>\n<li>flase</li>\n<li>0</li>\n<li>NaN</li>\n<li>‘’（空字符串）</li>\n</ul>\n<h2 id=\"数值\"><a href=\"#数值\" class=\"headerlink\" title=\"数值\"></a><strong>数值</strong></h2><p>javascript内部,所有数字都是以64位浮点数形式储存，即使整数也是如此。<code>1</code>和<code>1.0</code>是相同的，是同一个数。这就是说，javascript语言的底层根本没有整数，所有的数字都是小数，由于浮点数不是精确的值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">0.3</span> - <span class=\"number\">0.1</span>) === (<span class=\"number\">0.2</span> - <span class=\"number\">0.1</span>)</span><br><span class=\"line\"><span class=\"comment\">// flase</span></span><br></pre></td></tr></table></figure>\n\n<div align=\"center\"><img src=\"./img/img2.png\"></div>\n\n<p>第1位：符号位，<code>0</code>表示整数，<code>1</code>表示负数<br>第2位到第12位(共11位)：指数部分<br>第13位到第64位（共56位）：小数部分（有效部分）<br>符号位决定了一个数是正数还是负数，指数部分决定了数值的大小，小数部分决定了数值的精度。</p>\n<h3 id=\"NaN\"><a href=\"#NaN\" class=\"headerlink\" title=\"NaN\"></a><strong>NaN</strong></h3><p>含义：NaN是javascript的特殊值，表示非数字(Not a Number)，主要出现在将字符串解析成数字出错的场所。<br>NaN可以理解成，无法表示的数字。但是他也是个数字，只是我们现在不知道怎么描述的数字。</p>\n<h3 id=\"isNaN\"><a href=\"#isNaN\" class=\"headerlink\" title=\"isNaN()\"></a><strong>isNaN()</strong></h3><p><code>isNaN()</code>方法可以用来判断一个值是否为NaN。</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a><strong>字符串</strong></h2><p>字符串就是零个或多个排在一起的字符，放在单引号<code>&#39;&#39;</code>或者双引号<code>&quot;&quot;</code>之中<br>单引号字符串内部，可以使用双引号。双引号字符串的内部，可以使用单引号。<br>如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。<code>\\</code><br>使用反引号，可以把字符串写成多行。</p>\n<h3 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a><strong>转义</strong></h3><p>用另一种写法表示你想要的的东西</p>\n<ul>\n<li>&#39; 表示<code>&#39;</code></li>\n<li>&quot; 表示<code>&quot;</code></li>\n<li>\\n 表示换行</li>\n<li>\\r 表示回车</li>\n<li>\\t 表示tab制表符<br>还有很多转义，用的时候Google就行了</li>\n</ul>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a><strong>属性</strong></h3><ol>\n<li><code>string.length</code> 可以查看string的长度。</li>\n<li><code>string[index]</code> 通过下标读取字符串中的某一个字符，下标都是从0开始的</li>\n</ol>\n<h3 id=\"Base64转码\"><a href=\"#Base64转码\" class=\"headerlink\" title=\"Base64转码\"></a><strong>Base64转码</strong></h3><p>window.btoa(“string”)<br>正常的字符串转为base64编码字符串<br>window.atob(“string”)<br>base64编码的字符串转为原来的字符串</p>\n<h2 id=\"互相转换\"><a href=\"#互相转换\" class=\"headerlink\" title=\"互相转换\"></a><strong>互相转换</strong></h2><p><strong>number转string</strong></p>\n<ol>\n<li>String(n) </li>\n<li>n + ‘’ </li>\n</ol>\n<p><strong>string转number</strong></p>\n<ol>\n<li>Number(s)</li>\n<li>s - 0</li>\n<li>parsInt(“123”) </li>\n</ol>\n<p><strong>任何东西转boole</strong></p>\n<ol>\n<li>Boolean(任何东西)</li>\n<li>!!任何东西</li>\n</ol>\n<p><strong>任何东西转String</strong><br>String(任何东西)<br>任何东西.toString()</p>\n<h2 id=\"变量声明\"><a href=\"#变量声明\" class=\"headerlink\" title=\"变量声明\"></a><strong>变量声明</strong></h2><p><code>let声明</code><br>作用块作用域，不能超过<code>&#123;&#125;</code><br>不能重复声明<br>可以赋值，也可以不赋值<br>必须先声明，在使用<br>全局声明，不会变成<code>window</code>的属性</p>\n<p><code>const声明</code><br>跟let一样<br>唯一的区别是声明的时候，必须赋值，赋值以后不能更改</p>\n<p><strong>细节</strong><br>变量声明，即给了值，也指定的了类型。<br>name和”name”的区别<br>name是一个变量，“name”是一个字符串</p>\n<p>(完)</p>\n<p>资料参考<br>1.饥人谷<br>2.阮一峰网道javascript教程</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"如何存字符\"><a href=\"#如何存字符\" class=\"headerlink\" title=\"如何存字符\"></a><strong>如何存字符</strong></h2><p>内存上只能存<code>0</code>和<code>1</code>所以把10进制数，存成2进制数，就可以把数字存到内存里面。<br>存完数字以后，然后要思考怎么存字母，0~127（2的8次方）把所有字母和数字和符号，如下图</p>","more":"<div align=\"center\"><img src=\"./img/img1.png\"></div>\n\n<ol>\n<li>要考虑存汉字，中国国标局来遍号，俗称国标</li>\n<li>用16进制来(1,2,3,4,5,6,7,8,9，A，B，C，D，E，F)存汉字，从0000~FFFF来存汉字，所以汉字是2个字节</li>\n<li>后来出现生僻字和日本，韩语的文字，后来出现了「国标扩」</li>\n<li>继续扩展，把全球所有文字都收录，编号，出现了unicode，俗称万国码</li>\n<li>utf-8，是对unicode的一种节约储存方式</li>\n</ol>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a><strong>数据类型</strong></h2><p>为什么数据需要分类型呢？因为数字是数字，字符串是字符串，程序员都需要严谨。举个例子，字符串可以表示电话号码，但是数字不行，因为有些电话号码是<code>010</code>开头的，这样的话，如果用数字就会省略前面的<code>0</code>,无法正确表示电话号码.</p>\n<ul>\n<li>数值</li>\n<li>字符串</li>\n<li>布尔值</li>\n<li>undefined</li>\n<li>null</li>\n<li>对象</li>\n<li>Symbol</li>\n<li>bigint</li>\n</ul>\n<p><code>数值</code> <code>字符串</code> <code>布尔值</code> 是三个最基本的数据类型，已经不能再细分了。对象是合成型的数据类型。</p>\n<p><code>typeof</code>运算符可以确定一个值到底是什么类型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof 123 &#x2F;&#x2F;&quot;number&quot;</span><br><span class=\"line\">typeof &quot;123&quot; &#x2F;&#x2F;&quot;String&quot;</span><br><span class=\"line\">typeof false &#x2F;&#x2F;&quot;boolean&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"null-undefined-布尔值\"><a href=\"#null-undefined-布尔值\" class=\"headerlink\" title=\"null,undefined,布尔值\"></a><strong>null,undefined,布尔值</strong></h2><p><code>null</code>和<code>undefined</code>都可以表示没有，含义是非常相似。将一个变量赋值为<code>null</code>和<code>undefined</code>，语法效果几乎没有区别。</p>\n<h3 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a><strong>细节</strong></h3><ol>\n<li>如果一个变量声明了，但没有赋值，那么默认值是undefined，而不是null</li>\n<li>如果一个函数，没有写return，那么默认return undefined，而不是null</li>\n<li>把非对象的空值写成undefined，把对象的空值写成null</li>\n</ol>\n<h3 id=\"为什么JS会有两个空值\"><a href=\"#为什么JS会有两个空值\" class=\"headerlink\" title=\"为什么JS会有两个空值\"></a><strong>为什么JS会有两个空值</strong></h3><p>JavaScript 的设计者 Brendan Eich，觉得这样做还不够。首先，第一版的 JavaScript 里面，<code>null</code>就像在Java 里一样，被当成一个对象，Brendan Eich 觉得表示“无”的值最好不是对象。其次，那时的 JavaScript 不包括错误处理机制，Brendan Eich 觉得，如果<code>null</code>自动转为0，很不容易发现错误。因此，他又设计了一个<code>undefined</code>。区别是这样的：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。</p>\n<p><code>undefined</code>表示未定义，下面是返回<code>undefined</code>的典型场景</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i;</span><br><span class=\"line\">i <span class=\"comment\">//undefined</span></span><br><span class=\"line\"><span class=\"comment\">//变量声明了，但是没有赋值时</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f() <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"comment\">//调用函数时，应该提供的参数没有提供，该参数就等于 undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>()</span><br><span class=\"line\">o.p <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"comment\">//对象没有赋值的属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">f() <span class=\"comment\">//undefined</span></span><br><span class=\"line\"><span class=\"comment\">//函数没有返回值的时候，默认返回undefined</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a><strong>布尔值</strong></h3><p>布尔值代表<code>真</code>和<code>假</code>，真的关键字是<code>true</code>,假的关键字是<code>flase</code>,布尔值只有这两个值。<br>下面运行符会返回布尔值：</p>\n<ul>\n<li>前置逻辑运算符：<code>!</code>(Not)</li>\n<li>相等运算符：<code>===</code> <code>!==</code> <code>==</code> <code>!=</code></li>\n<li>比较运算符：<code>&gt;</code> <code>&gt;=</code> <code>&lt;</code> <code>&lt;=</code></li>\n</ul>\n<p>如果JS预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值，转换规则是除了下面六个值被转为<code>flase</code>，其他值都是为<code>true</code></p>\n<ul>\n<li>undefined</li>\n<li>null</li>\n<li>flase</li>\n<li>0</li>\n<li>NaN</li>\n<li>‘’（空字符串）</li>\n</ul>\n<h2 id=\"数值\"><a href=\"#数值\" class=\"headerlink\" title=\"数值\"></a><strong>数值</strong></h2><p>javascript内部,所有数字都是以64位浮点数形式储存，即使整数也是如此。<code>1</code>和<code>1.0</code>是相同的，是同一个数。这就是说，javascript语言的底层根本没有整数，所有的数字都是小数，由于浮点数不是精确的值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">0.3</span> - <span class=\"number\">0.1</span>) === (<span class=\"number\">0.2</span> - <span class=\"number\">0.1</span>)</span><br><span class=\"line\"><span class=\"comment\">// flase</span></span><br></pre></td></tr></table></figure>\n\n<div align=\"center\"><img src=\"./img/img2.png\"></div>\n\n<p>第1位：符号位，<code>0</code>表示整数，<code>1</code>表示负数<br>第2位到第12位(共11位)：指数部分<br>第13位到第64位（共56位）：小数部分（有效部分）<br>符号位决定了一个数是正数还是负数，指数部分决定了数值的大小，小数部分决定了数值的精度。</p>\n<h3 id=\"NaN\"><a href=\"#NaN\" class=\"headerlink\" title=\"NaN\"></a><strong>NaN</strong></h3><p>含义：NaN是javascript的特殊值，表示非数字(Not a Number)，主要出现在将字符串解析成数字出错的场所。<br>NaN可以理解成，无法表示的数字。但是他也是个数字，只是我们现在不知道怎么描述的数字。</p>\n<h3 id=\"isNaN\"><a href=\"#isNaN\" class=\"headerlink\" title=\"isNaN()\"></a><strong>isNaN()</strong></h3><p><code>isNaN()</code>方法可以用来判断一个值是否为NaN。</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a><strong>字符串</strong></h2><p>字符串就是零个或多个排在一起的字符，放在单引号<code>&#39;&#39;</code>或者双引号<code>&quot;&quot;</code>之中<br>单引号字符串内部，可以使用双引号。双引号字符串的内部，可以使用单引号。<br>如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。<code>\\</code><br>使用反引号，可以把字符串写成多行。</p>\n<h3 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a><strong>转义</strong></h3><p>用另一种写法表示你想要的的东西</p>\n<ul>\n<li>&#39; 表示<code>&#39;</code></li>\n<li>&quot; 表示<code>&quot;</code></li>\n<li>\\n 表示换行</li>\n<li>\\r 表示回车</li>\n<li>\\t 表示tab制表符<br>还有很多转义，用的时候Google就行了</li>\n</ul>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a><strong>属性</strong></h3><ol>\n<li><code>string.length</code> 可以查看string的长度。</li>\n<li><code>string[index]</code> 通过下标读取字符串中的某一个字符，下标都是从0开始的</li>\n</ol>\n<h3 id=\"Base64转码\"><a href=\"#Base64转码\" class=\"headerlink\" title=\"Base64转码\"></a><strong>Base64转码</strong></h3><p>window.btoa(“string”)<br>正常的字符串转为base64编码字符串<br>window.atob(“string”)<br>base64编码的字符串转为原来的字符串</p>\n<h2 id=\"互相转换\"><a href=\"#互相转换\" class=\"headerlink\" title=\"互相转换\"></a><strong>互相转换</strong></h2><p><strong>number转string</strong></p>\n<ol>\n<li>String(n) </li>\n<li>n + ‘’ </li>\n</ol>\n<p><strong>string转number</strong></p>\n<ol>\n<li>Number(s)</li>\n<li>s - 0</li>\n<li>parsInt(“123”) </li>\n</ol>\n<p><strong>任何东西转boole</strong></p>\n<ol>\n<li>Boolean(任何东西)</li>\n<li>!!任何东西</li>\n</ol>\n<p><strong>任何东西转String</strong><br>String(任何东西)<br>任何东西.toString()</p>\n<h2 id=\"变量声明\"><a href=\"#变量声明\" class=\"headerlink\" title=\"变量声明\"></a><strong>变量声明</strong></h2><p><code>let声明</code><br>作用块作用域，不能超过<code>&#123;&#125;</code><br>不能重复声明<br>可以赋值，也可以不赋值<br>必须先声明，在使用<br>全局声明，不会变成<code>window</code>的属性</p>\n<p><code>const声明</code><br>跟let一样<br>唯一的区别是声明的时候，必须赋值，赋值以后不能更改</p>\n<p><strong>细节</strong><br>变量声明，即给了值，也指定的了类型。<br>name和”name”的区别<br>name是一个变量，“name”是一个字符串</p>\n<p>(完)</p>\n<p>资料参考<br>1.饥人谷<br>2.阮一峰网道javascript教程</p>"},{"title":"JS数据类型（下）","date":"2020-10-31T14:23:02.000Z","toc":true,"cover":"./img/javascript.png","_content":"## __对象__\n对象就是一组“键值对”的集合，是一种无序的符合数据集合。是JS里唯一一种复杂类型\n<!--more-->\n## __写法__\n```javascript\n第一种写法\nlet obj = {\"name\":\"frank\",\"age\":18}\n第二种写法\nlet obj = new Object({\"name\":\"frank\",\"age\":18})\n```\n上面的代码，大括号就定义了一个对象，它被赋值给变量`obj`,该对象内部包含了两个键值对，第一个键值对是`\"name\":\"frank\"`,第二个键值对是`\"age\":18`,两个键值对用`,`隔开。`name`叫键名，也叫属性，`frank`叫键值。键名都是是字符串。键值可以是任何数据类型\n```javascript\n{foo:123}\n// 123\n```\n上面的代码，出现了歧义，它即像一个对象里面包含了属性名为`foo`,键值为`123`。又像一个代码块里面包含了标签`foo`指向一个值为`123`,当JS解析到这样的代码时候，一律认为是代码块。以上代码输出为`123`\n如果要让上面的代码，被认为是一个对象，要用()括起来\n```javascript\n({foo:123})\n// Object{foo:123}\n```\n如果一个属性的值为函数，通常把这个属性成为方法，它可以像函数一样被调用。\n```javascript\nlet obj = {\n\"p\":funciton(){\nreturn 2\n}\n}\n//obj.p 2\n```\n<div class = \"ff6666\">细节:</div>\n\n1. 键名都是字符串，不是标识符，可以包含任意字符。\n2. 引号可以省略，省略之后就必须写标识符。\n3. 就算省略了引号，键名也还是字符串。\n\n### __变量作属性名__\n```javascript\nlet p1 = \"name\"\nlet obj = {p1:\"frank\"} \nlet obj = {[p1]:\"frank\"}\n```\n以上代码，`p1`什么都不加的时候，自动转成字符串，键名就是`p1`,如果加了`[]`变成了`[p1]`就变成了一个变量，属性名就变成了`\"name\"`\n总结:不加`[]`的属性名会自动转变成字符串，加了`[]`就会被当做变量求值。\n\n## __对象的隐藏属性__\n1. JS中每一个对象都有一个隐藏属性\n2. 这个隐藏属性存储着其共有属性组成的对象地址\n3. 这个共有属性组成的对象叫做原型\n4. 也就是说，隐藏属性储存着原型的地址\n\n<div align=\"center\"><img src = ./img/img1.png></div>\n\n如上图，`obj`包含了两个自身的属性`age` `name`,也有一个对象的隐藏属性`__proto__`,这个隐藏属性里面存着对象的共有属性，这些共有属性组成的对象叫原型。\n\n## __对象的增删改查__\n### __读取属性__\n读取对象的属性，有两种方法，一种是使用`点运算符`，还有一种是使用`方括号运算符`\n```javascript\nlet obj = {name:\"frank\",age=18}\nobj.name //\"frank\"\nobj[\"age\"] // 18\n```\n<div class=\"ff6666\">注意</div>\n\n1. 使用`方括号运算符`读取对象属性，键名必须放在引号里面，否则会被当做变量处理。\n2. 方括号内可以使用表达式\n```javascript\nobj[\"na\"+\"me\"]\n// \"frank\"\n```\n3. 数字键名在方括号里面可以不用加引号，因为会自动转成字符串。数字键名不能使用`点运算符`因为会被当做是小数点处理。\n\n__Object.keys(obj)__\n```javascript\nlet obj = {name:\"frank\",age=18}\nObject.keys(obj)\n// [name,age]\n```\n`Object.keys(obj)`可以读出，对象里面的所有键名。\n\n__Object.values(obj)__\n```javascript\nlet obj ={name:\"frank\",age:18}\nObject.values(obj)\n// [\"frank\",18]\n```\n`Object.values(obj)`可以读出对象的所有键值\n\n__console.dir(obj)__\n可以打印出obj自身属性+隐藏属性\n\n### __删除属性__\n__delete命令__\n用于删除对象的属性，删除成功后返回`true`，delete命令删除没有的属性，返回值也是`true`，所以不能根据delete命令的返回值来判断，对象里面是否有该属性。\n删除属性有两种写法\n```javascript\nlet obj={name:\"frank\",age:18}\ndelete obj.name \ndelete obj[\"name\"]\n```\n`delete`即删除了对象的属性名也删除了属性值\n```javascript\nobj.name = undefined\n```\n以上代码只是把对象的属性值改成了`undefined`而属性名还在。所以我不能通过`obj.name === undefined`来判断`name`是不是obj的属性。\n\n### __修改和增加属性__\n__直接赋值__\n如果对象里面有该属性，就修改了属性，如果没有就新增了该属性\n__批量赋值__\n```javascript\nlet obj = {}\nObject.assign(obj,{age:18,gender:\"man\"})\n```\n__修改隐藏属性__\n```javascript\nlet obj = {}\nobj.__proto__ = null\n```\n以上代码会把obj的隐藏属性，删除了，但是不推荐这样的写法。\n```javascript\nlet xyz ={name:\"小明\"，age:20}\nlet obj = Object.creat(xyz)\n```\n以上代码意思是，在创建obj这个对象的时候，就把xyz当做它的原型传给obj。\n\n### __属性是否存在:in运算符__\n`in`运算符用于检查对象是否包含某个属性，包含就返回`true`,不包含就返回`flase`.他的坐标是一个字符串，表示属性名，右边是一个对象\n```javascript\nlet obj = {name:\"frank\",age:18}\n\"name\" in obj // true\n\"toString\" in obj // true\n```\n`in`运算符的问题是，它是不能识别哪些属性是自身的，哪些属性是从原型那边继承过来的。\n如果要判自身是否包含某个属性，可以使用`hasOwnproterty`\n```javascript\nlet obj = {name:\"frank\",age:18}\nobj.hasOwnproperty(\"toString\")\n// false\n```\n`in`和`hasOwnproperty`的区别就是，`in`无法识别某个属性是自身的还是从原型那里继承的，而`hasOwnproterty`可以识别属性是否是自身的。\n\n### __属性的遍历：for...in循环__\n用来遍历对象里面的所有属性。\n```javascript\nobj = {name:\"frank\",age:18}\nfor(let key in obj){\nconsole.log(i+\":\"+obj[key])\n}\n//name:frank\n  age:18\n```\n\n__(完)__\n\n资料参考：\n饥人谷\n阮一峰网道javascript教程\n\n","source":"_posts/JS数据类型（下）.md","raw":"---\ntitle: JS数据类型（下）\ndate: 2020-10-31 14:23:02\ntags: javascript\ntoc: true\ncover: ./img/javascript.png\n---\n## __对象__\n对象就是一组“键值对”的集合，是一种无序的符合数据集合。是JS里唯一一种复杂类型\n<!--more-->\n## __写法__\n```javascript\n第一种写法\nlet obj = {\"name\":\"frank\",\"age\":18}\n第二种写法\nlet obj = new Object({\"name\":\"frank\",\"age\":18})\n```\n上面的代码，大括号就定义了一个对象，它被赋值给变量`obj`,该对象内部包含了两个键值对，第一个键值对是`\"name\":\"frank\"`,第二个键值对是`\"age\":18`,两个键值对用`,`隔开。`name`叫键名，也叫属性，`frank`叫键值。键名都是是字符串。键值可以是任何数据类型\n```javascript\n{foo:123}\n// 123\n```\n上面的代码，出现了歧义，它即像一个对象里面包含了属性名为`foo`,键值为`123`。又像一个代码块里面包含了标签`foo`指向一个值为`123`,当JS解析到这样的代码时候，一律认为是代码块。以上代码输出为`123`\n如果要让上面的代码，被认为是一个对象，要用()括起来\n```javascript\n({foo:123})\n// Object{foo:123}\n```\n如果一个属性的值为函数，通常把这个属性成为方法，它可以像函数一样被调用。\n```javascript\nlet obj = {\n\"p\":funciton(){\nreturn 2\n}\n}\n//obj.p 2\n```\n<div class = \"ff6666\">细节:</div>\n\n1. 键名都是字符串，不是标识符，可以包含任意字符。\n2. 引号可以省略，省略之后就必须写标识符。\n3. 就算省略了引号，键名也还是字符串。\n\n### __变量作属性名__\n```javascript\nlet p1 = \"name\"\nlet obj = {p1:\"frank\"} \nlet obj = {[p1]:\"frank\"}\n```\n以上代码，`p1`什么都不加的时候，自动转成字符串，键名就是`p1`,如果加了`[]`变成了`[p1]`就变成了一个变量，属性名就变成了`\"name\"`\n总结:不加`[]`的属性名会自动转变成字符串，加了`[]`就会被当做变量求值。\n\n## __对象的隐藏属性__\n1. JS中每一个对象都有一个隐藏属性\n2. 这个隐藏属性存储着其共有属性组成的对象地址\n3. 这个共有属性组成的对象叫做原型\n4. 也就是说，隐藏属性储存着原型的地址\n\n<div align=\"center\"><img src = ./img/img1.png></div>\n\n如上图，`obj`包含了两个自身的属性`age` `name`,也有一个对象的隐藏属性`__proto__`,这个隐藏属性里面存着对象的共有属性，这些共有属性组成的对象叫原型。\n\n## __对象的增删改查__\n### __读取属性__\n读取对象的属性，有两种方法，一种是使用`点运算符`，还有一种是使用`方括号运算符`\n```javascript\nlet obj = {name:\"frank\",age=18}\nobj.name //\"frank\"\nobj[\"age\"] // 18\n```\n<div class=\"ff6666\">注意</div>\n\n1. 使用`方括号运算符`读取对象属性，键名必须放在引号里面，否则会被当做变量处理。\n2. 方括号内可以使用表达式\n```javascript\nobj[\"na\"+\"me\"]\n// \"frank\"\n```\n3. 数字键名在方括号里面可以不用加引号，因为会自动转成字符串。数字键名不能使用`点运算符`因为会被当做是小数点处理。\n\n__Object.keys(obj)__\n```javascript\nlet obj = {name:\"frank\",age=18}\nObject.keys(obj)\n// [name,age]\n```\n`Object.keys(obj)`可以读出，对象里面的所有键名。\n\n__Object.values(obj)__\n```javascript\nlet obj ={name:\"frank\",age:18}\nObject.values(obj)\n// [\"frank\",18]\n```\n`Object.values(obj)`可以读出对象的所有键值\n\n__console.dir(obj)__\n可以打印出obj自身属性+隐藏属性\n\n### __删除属性__\n__delete命令__\n用于删除对象的属性，删除成功后返回`true`，delete命令删除没有的属性，返回值也是`true`，所以不能根据delete命令的返回值来判断，对象里面是否有该属性。\n删除属性有两种写法\n```javascript\nlet obj={name:\"frank\",age:18}\ndelete obj.name \ndelete obj[\"name\"]\n```\n`delete`即删除了对象的属性名也删除了属性值\n```javascript\nobj.name = undefined\n```\n以上代码只是把对象的属性值改成了`undefined`而属性名还在。所以我不能通过`obj.name === undefined`来判断`name`是不是obj的属性。\n\n### __修改和增加属性__\n__直接赋值__\n如果对象里面有该属性，就修改了属性，如果没有就新增了该属性\n__批量赋值__\n```javascript\nlet obj = {}\nObject.assign(obj,{age:18,gender:\"man\"})\n```\n__修改隐藏属性__\n```javascript\nlet obj = {}\nobj.__proto__ = null\n```\n以上代码会把obj的隐藏属性，删除了，但是不推荐这样的写法。\n```javascript\nlet xyz ={name:\"小明\"，age:20}\nlet obj = Object.creat(xyz)\n```\n以上代码意思是，在创建obj这个对象的时候，就把xyz当做它的原型传给obj。\n\n### __属性是否存在:in运算符__\n`in`运算符用于检查对象是否包含某个属性，包含就返回`true`,不包含就返回`flase`.他的坐标是一个字符串，表示属性名，右边是一个对象\n```javascript\nlet obj = {name:\"frank\",age:18}\n\"name\" in obj // true\n\"toString\" in obj // true\n```\n`in`运算符的问题是，它是不能识别哪些属性是自身的，哪些属性是从原型那边继承过来的。\n如果要判自身是否包含某个属性，可以使用`hasOwnproterty`\n```javascript\nlet obj = {name:\"frank\",age:18}\nobj.hasOwnproperty(\"toString\")\n// false\n```\n`in`和`hasOwnproperty`的区别就是，`in`无法识别某个属性是自身的还是从原型那里继承的，而`hasOwnproterty`可以识别属性是否是自身的。\n\n### __属性的遍历：for...in循环__\n用来遍历对象里面的所有属性。\n```javascript\nobj = {name:\"frank\",age:18}\nfor(let key in obj){\nconsole.log(i+\":\"+obj[key])\n}\n//name:frank\n  age:18\n```\n\n__(完)__\n\n资料参考：\n饥人谷\n阮一峰网道javascript教程\n\n","slug":"JS数据类型（下）","published":1,"updated":"2020-11-01T03:29:52.126Z","_id":"ckgxs10780000mkfqcse85wte","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a><strong>对象</strong></h2><p>对象就是一组“键值对”的集合，是一种无序的符合数据集合。是JS里唯一一种复杂类型</p>\n<a id=\"more\"></a>\n<h2 id=\"写法\"><a href=\"#写法\" class=\"headerlink\" title=\"写法\"></a><strong>写法</strong></h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一种写法</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;frank&quot;</span>,<span class=\"string\">&quot;age&quot;</span>:<span class=\"number\">18</span>&#125;</span><br><span class=\"line\">第二种写法</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>(&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;frank&quot;</span>,<span class=\"string\">&quot;age&quot;</span>:<span class=\"number\">18</span>&#125;)</span><br></pre></td></tr></table></figure>\n<p>上面的代码，大括号就定义了一个对象，它被赋值给变量<code>obj</code>,该对象内部包含了两个键值对，第一个键值对是<code>&quot;name&quot;:&quot;frank&quot;</code>,第二个键值对是<code>&quot;age&quot;:18</code>,两个键值对用<code>,</code>隔开。<code>name</code>叫键名，也叫属性，<code>frank</code>叫键值。键名都是是字符串。键值可以是任何数据类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"attr\">foo</span>:<span class=\"number\">123</span>&#125;</span><br><span class=\"line\"><span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码，出现了歧义，它即像一个对象里面包含了属性名为<code>foo</code>,键值为<code>123</code>。又像一个代码块里面包含了标签<code>foo</code>指向一个值为<code>123</code>,当JS解析到这样的代码时候，一律认为是代码块。以上代码输出为<code>123</code><br>如果要让上面的代码，被认为是一个对象，要用()括起来</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(&#123;<span class=\"attr\">foo</span>:<span class=\"number\">123</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// Object&#123;foo:123&#125;</span></span><br></pre></td></tr></table></figure>\n<p>如果一个属性的值为函数，通常把这个属性成为方法，它可以像函数一样被调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\"><span class=\"string\">&quot;p&quot;</span>:funciton()&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//obj.p 2</span></span><br></pre></td></tr></table></figure>\n<div class = \"ff6666\">细节:</div>\n\n<ol>\n<li>键名都是字符串，不是标识符，可以包含任意字符。</li>\n<li>引号可以省略，省略之后就必须写标识符。</li>\n<li>就算省略了引号，键名也还是字符串。</li>\n</ol>\n<h3 id=\"变量作属性名\"><a href=\"#变量作属性名\" class=\"headerlink\" title=\"变量作属性名\"></a><strong>变量作属性名</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">p1</span>:<span class=\"string\">&quot;frank&quot;</span>&#125; </span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;[p1]:<span class=\"string\">&quot;frank&quot;</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码，<code>p1</code>什么都不加的时候，自动转成字符串，键名就是<code>p1</code>,如果加了<code>[]</code>变成了<code>[p1]</code>就变成了一个变量，属性名就变成了<code>&quot;name&quot;</code><br>总结:不加<code>[]</code>的属性名会自动转变成字符串，加了<code>[]</code>就会被当做变量求值。</p>\n<h2 id=\"对象的隐藏属性\"><a href=\"#对象的隐藏属性\" class=\"headerlink\" title=\"对象的隐藏属性\"></a><strong>对象的隐藏属性</strong></h2><ol>\n<li>JS中每一个对象都有一个隐藏属性</li>\n<li>这个隐藏属性存储着其共有属性组成的对象地址</li>\n<li>这个共有属性组成的对象叫做原型</li>\n<li>也就是说，隐藏属性储存着原型的地址</li>\n</ol>\n<div align=\"center\"><img src = ./img/img1.png></div>\n\n<p>如上图，<code>obj</code>包含了两个自身的属性<code>age</code> <code>name</code>,也有一个对象的隐藏属性<code>__proto__</code>,这个隐藏属性里面存着对象的共有属性，这些共有属性组成的对象叫原型。</p>\n<h2 id=\"对象的增删改查\"><a href=\"#对象的增删改查\" class=\"headerlink\" title=\"对象的增删改查\"></a><strong>对象的增删改查</strong></h2><h3 id=\"读取属性\"><a href=\"#读取属性\" class=\"headerlink\" title=\"读取属性\"></a><strong>读取属性</strong></h3><p>读取对象的属性，有两种方法，一种是使用<code>点运算符</code>，还有一种是使用<code>方括号运算符</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;frank&quot;</span>,age=<span class=\"number\">18</span>&#125;</span><br><span class=\"line\">obj.name <span class=\"comment\">//&quot;frank&quot;</span></span><br><span class=\"line\">obj[<span class=\"string\">&quot;age&quot;</span>] <span class=\"comment\">// 18</span></span><br></pre></td></tr></table></figure>\n<div class=\"ff6666\">注意</div>\n\n<ol>\n<li>使用<code>方括号运算符</code>读取对象属性，键名必须放在引号里面，否则会被当做变量处理。</li>\n<li>方括号内可以使用表达式<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj[<span class=\"string\">&quot;na&quot;</span>+<span class=\"string\">&quot;me&quot;</span>]</span><br><span class=\"line\"><span class=\"comment\">// &quot;frank&quot;</span></span><br></pre></td></tr></table></figure></li>\n<li>数字键名在方括号里面可以不用加引号，因为会自动转成字符串。数字键名不能使用<code>点运算符</code>因为会被当做是小数点处理。</li>\n</ol>\n<p><strong>Object.keys(obj)</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;frank&quot;</span>,age=<span class=\"number\">18</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(obj)</span><br><span class=\"line\"><span class=\"comment\">// [name,age]</span></span><br></pre></td></tr></table></figure>\n<p><code>Object.keys(obj)</code>可以读出，对象里面的所有键名。</p>\n<p><strong>Object.values(obj)</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj =&#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;frank&quot;</span>,<span class=\"attr\">age</span>:<span class=\"number\">18</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.values(obj)</span><br><span class=\"line\"><span class=\"comment\">// [&quot;frank&quot;,18]</span></span><br></pre></td></tr></table></figure>\n<p><code>Object.values(obj)</code>可以读出对象的所有键值</p>\n<p><strong>console.dir(obj)</strong><br>可以打印出obj自身属性+隐藏属性</p>\n<h3 id=\"删除属性\"><a href=\"#删除属性\" class=\"headerlink\" title=\"删除属性\"></a><strong>删除属性</strong></h3><p><strong>delete命令</strong><br>用于删除对象的属性，删除成功后返回<code>true</code>，delete命令删除没有的属性，返回值也是<code>true</code>，所以不能根据delete命令的返回值来判断，对象里面是否有该属性。<br>删除属性有两种写法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj=&#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;frank&quot;</span>,<span class=\"attr\">age</span>:<span class=\"number\">18</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">delete</span> obj.name </span><br><span class=\"line\"><span class=\"keyword\">delete</span> obj[<span class=\"string\">&quot;name&quot;</span>]</span><br></pre></td></tr></table></figure>\n<p><code>delete</code>即删除了对象的属性名也删除了属性值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj.name = <span class=\"literal\">undefined</span></span><br></pre></td></tr></table></figure>\n<p>以上代码只是把对象的属性值改成了<code>undefined</code>而属性名还在。所以我不能通过<code>obj.name === undefined</code>来判断<code>name</code>是不是obj的属性。</p>\n<h3 id=\"修改和增加属性\"><a href=\"#修改和增加属性\" class=\"headerlink\" title=\"修改和增加属性\"></a><strong>修改和增加属性</strong></h3><p><strong>直接赋值</strong><br>如果对象里面有该属性，就修改了属性，如果没有就新增了该属性<br><strong>批量赋值</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(obj,&#123;<span class=\"attr\">age</span>:<span class=\"number\">18</span>,<span class=\"attr\">gender</span>:<span class=\"string\">&quot;man&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>修改隐藏属性</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;</span><br><span class=\"line\">obj.__proto__ = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n<p>以上代码会把obj的隐藏属性，删除了，但是不推荐这样的写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> xyz =&#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;小明&quot;</span>，age:<span class=\"number\">20</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"built_in\">Object</span>.creat(xyz)</span><br></pre></td></tr></table></figure>\n<p>以上代码意思是，在创建obj这个对象的时候，就把xyz当做它的原型传给obj。</p>\n<h3 id=\"属性是否存在-in运算符\"><a href=\"#属性是否存在-in运算符\" class=\"headerlink\" title=\"属性是否存在:in运算符\"></a><strong>属性是否存在:in运算符</strong></h3><p><code>in</code>运算符用于检查对象是否包含某个属性，包含就返回<code>true</code>,不包含就返回<code>flase</code>.他的坐标是一个字符串，表示属性名，右边是一个对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;frank&quot;</span>,<span class=\"attr\">age</span>:<span class=\"number\">18</span>&#125;</span><br><span class=\"line\"><span class=\"string\">&quot;name&quot;</span> <span class=\"keyword\">in</span> obj <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">&quot;toString&quot;</span> <span class=\"keyword\">in</span> obj <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><code>in</code>运算符的问题是，它是不能识别哪些属性是自身的，哪些属性是从原型那边继承过来的。<br>如果要判自身是否包含某个属性，可以使用<code>hasOwnproterty</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;frank&quot;</span>,<span class=\"attr\">age</span>:<span class=\"number\">18</span>&#125;</span><br><span class=\"line\">obj.hasOwnproperty(<span class=\"string\">&quot;toString&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p><code>in</code>和<code>hasOwnproperty</code>的区别就是，<code>in</code>无法识别某个属性是自身的还是从原型那里继承的，而<code>hasOwnproterty</code>可以识别属性是否是自身的。</p>\n<h3 id=\"属性的遍历：for…in循环\"><a href=\"#属性的遍历：for…in循环\" class=\"headerlink\" title=\"属性的遍历：for…in循环\"></a><strong>属性的遍历：for…in循环</strong></h3><p>用来遍历对象里面的所有属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj = &#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;frank&quot;</span>,<span class=\"attr\">age</span>:<span class=\"number\">18</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> obj)&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i+<span class=\"string\">&quot;:&quot;</span>+obj[key])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//name:frank</span></span><br><span class=\"line\">  age:<span class=\"number\">18</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>(完)</strong></p>\n<p>资料参考：<br>饥人谷<br>阮一峰网道javascript教程</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a><strong>对象</strong></h2><p>对象就是一组“键值对”的集合，是一种无序的符合数据集合。是JS里唯一一种复杂类型</p>","more":"<h2 id=\"写法\"><a href=\"#写法\" class=\"headerlink\" title=\"写法\"></a><strong>写法</strong></h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一种写法</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;frank&quot;</span>,<span class=\"string\">&quot;age&quot;</span>:<span class=\"number\">18</span>&#125;</span><br><span class=\"line\">第二种写法</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>(&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;frank&quot;</span>,<span class=\"string\">&quot;age&quot;</span>:<span class=\"number\">18</span>&#125;)</span><br></pre></td></tr></table></figure>\n<p>上面的代码，大括号就定义了一个对象，它被赋值给变量<code>obj</code>,该对象内部包含了两个键值对，第一个键值对是<code>&quot;name&quot;:&quot;frank&quot;</code>,第二个键值对是<code>&quot;age&quot;:18</code>,两个键值对用<code>,</code>隔开。<code>name</code>叫键名，也叫属性，<code>frank</code>叫键值。键名都是是字符串。键值可以是任何数据类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"attr\">foo</span>:<span class=\"number\">123</span>&#125;</span><br><span class=\"line\"><span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码，出现了歧义，它即像一个对象里面包含了属性名为<code>foo</code>,键值为<code>123</code>。又像一个代码块里面包含了标签<code>foo</code>指向一个值为<code>123</code>,当JS解析到这样的代码时候，一律认为是代码块。以上代码输出为<code>123</code><br>如果要让上面的代码，被认为是一个对象，要用()括起来</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(&#123;<span class=\"attr\">foo</span>:<span class=\"number\">123</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// Object&#123;foo:123&#125;</span></span><br></pre></td></tr></table></figure>\n<p>如果一个属性的值为函数，通常把这个属性成为方法，它可以像函数一样被调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\"><span class=\"string\">&quot;p&quot;</span>:funciton()&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//obj.p 2</span></span><br></pre></td></tr></table></figure>\n<div class = \"ff6666\">细节:</div>\n\n<ol>\n<li>键名都是字符串，不是标识符，可以包含任意字符。</li>\n<li>引号可以省略，省略之后就必须写标识符。</li>\n<li>就算省略了引号，键名也还是字符串。</li>\n</ol>\n<h3 id=\"变量作属性名\"><a href=\"#变量作属性名\" class=\"headerlink\" title=\"变量作属性名\"></a><strong>变量作属性名</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"string\">&quot;name&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">p1</span>:<span class=\"string\">&quot;frank&quot;</span>&#125; </span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;[p1]:<span class=\"string\">&quot;frank&quot;</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码，<code>p1</code>什么都不加的时候，自动转成字符串，键名就是<code>p1</code>,如果加了<code>[]</code>变成了<code>[p1]</code>就变成了一个变量，属性名就变成了<code>&quot;name&quot;</code><br>总结:不加<code>[]</code>的属性名会自动转变成字符串，加了<code>[]</code>就会被当做变量求值。</p>\n<h2 id=\"对象的隐藏属性\"><a href=\"#对象的隐藏属性\" class=\"headerlink\" title=\"对象的隐藏属性\"></a><strong>对象的隐藏属性</strong></h2><ol>\n<li>JS中每一个对象都有一个隐藏属性</li>\n<li>这个隐藏属性存储着其共有属性组成的对象地址</li>\n<li>这个共有属性组成的对象叫做原型</li>\n<li>也就是说，隐藏属性储存着原型的地址</li>\n</ol>\n<div align=\"center\"><img src = ./img/img1.png></div>\n\n<p>如上图，<code>obj</code>包含了两个自身的属性<code>age</code> <code>name</code>,也有一个对象的隐藏属性<code>__proto__</code>,这个隐藏属性里面存着对象的共有属性，这些共有属性组成的对象叫原型。</p>\n<h2 id=\"对象的增删改查\"><a href=\"#对象的增删改查\" class=\"headerlink\" title=\"对象的增删改查\"></a><strong>对象的增删改查</strong></h2><h3 id=\"读取属性\"><a href=\"#读取属性\" class=\"headerlink\" title=\"读取属性\"></a><strong>读取属性</strong></h3><p>读取对象的属性，有两种方法，一种是使用<code>点运算符</code>，还有一种是使用<code>方括号运算符</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;frank&quot;</span>,age=<span class=\"number\">18</span>&#125;</span><br><span class=\"line\">obj.name <span class=\"comment\">//&quot;frank&quot;</span></span><br><span class=\"line\">obj[<span class=\"string\">&quot;age&quot;</span>] <span class=\"comment\">// 18</span></span><br></pre></td></tr></table></figure>\n<div class=\"ff6666\">注意</div>\n\n<ol>\n<li>使用<code>方括号运算符</code>读取对象属性，键名必须放在引号里面，否则会被当做变量处理。</li>\n<li>方括号内可以使用表达式<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj[<span class=\"string\">&quot;na&quot;</span>+<span class=\"string\">&quot;me&quot;</span>]</span><br><span class=\"line\"><span class=\"comment\">// &quot;frank&quot;</span></span><br></pre></td></tr></table></figure></li>\n<li>数字键名在方括号里面可以不用加引号，因为会自动转成字符串。数字键名不能使用<code>点运算符</code>因为会被当做是小数点处理。</li>\n</ol>\n<p><strong>Object.keys(obj)</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;frank&quot;</span>,age=<span class=\"number\">18</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(obj)</span><br><span class=\"line\"><span class=\"comment\">// [name,age]</span></span><br></pre></td></tr></table></figure>\n<p><code>Object.keys(obj)</code>可以读出，对象里面的所有键名。</p>\n<p><strong>Object.values(obj)</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj =&#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;frank&quot;</span>,<span class=\"attr\">age</span>:<span class=\"number\">18</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.values(obj)</span><br><span class=\"line\"><span class=\"comment\">// [&quot;frank&quot;,18]</span></span><br></pre></td></tr></table></figure>\n<p><code>Object.values(obj)</code>可以读出对象的所有键值</p>\n<p><strong>console.dir(obj)</strong><br>可以打印出obj自身属性+隐藏属性</p>\n<h3 id=\"删除属性\"><a href=\"#删除属性\" class=\"headerlink\" title=\"删除属性\"></a><strong>删除属性</strong></h3><p><strong>delete命令</strong><br>用于删除对象的属性，删除成功后返回<code>true</code>，delete命令删除没有的属性，返回值也是<code>true</code>，所以不能根据delete命令的返回值来判断，对象里面是否有该属性。<br>删除属性有两种写法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj=&#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;frank&quot;</span>,<span class=\"attr\">age</span>:<span class=\"number\">18</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">delete</span> obj.name </span><br><span class=\"line\"><span class=\"keyword\">delete</span> obj[<span class=\"string\">&quot;name&quot;</span>]</span><br></pre></td></tr></table></figure>\n<p><code>delete</code>即删除了对象的属性名也删除了属性值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj.name = <span class=\"literal\">undefined</span></span><br></pre></td></tr></table></figure>\n<p>以上代码只是把对象的属性值改成了<code>undefined</code>而属性名还在。所以我不能通过<code>obj.name === undefined</code>来判断<code>name</code>是不是obj的属性。</p>\n<h3 id=\"修改和增加属性\"><a href=\"#修改和增加属性\" class=\"headerlink\" title=\"修改和增加属性\"></a><strong>修改和增加属性</strong></h3><p><strong>直接赋值</strong><br>如果对象里面有该属性，就修改了属性，如果没有就新增了该属性<br><strong>批量赋值</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(obj,&#123;<span class=\"attr\">age</span>:<span class=\"number\">18</span>,<span class=\"attr\">gender</span>:<span class=\"string\">&quot;man&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>修改隐藏属性</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;</span><br><span class=\"line\">obj.__proto__ = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n<p>以上代码会把obj的隐藏属性，删除了，但是不推荐这样的写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> xyz =&#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;小明&quot;</span>，age:<span class=\"number\">20</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"built_in\">Object</span>.creat(xyz)</span><br></pre></td></tr></table></figure>\n<p>以上代码意思是，在创建obj这个对象的时候，就把xyz当做它的原型传给obj。</p>\n<h3 id=\"属性是否存在-in运算符\"><a href=\"#属性是否存在-in运算符\" class=\"headerlink\" title=\"属性是否存在:in运算符\"></a><strong>属性是否存在:in运算符</strong></h3><p><code>in</code>运算符用于检查对象是否包含某个属性，包含就返回<code>true</code>,不包含就返回<code>flase</code>.他的坐标是一个字符串，表示属性名，右边是一个对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;frank&quot;</span>,<span class=\"attr\">age</span>:<span class=\"number\">18</span>&#125;</span><br><span class=\"line\"><span class=\"string\">&quot;name&quot;</span> <span class=\"keyword\">in</span> obj <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">&quot;toString&quot;</span> <span class=\"keyword\">in</span> obj <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p><code>in</code>运算符的问题是，它是不能识别哪些属性是自身的，哪些属性是从原型那边继承过来的。<br>如果要判自身是否包含某个属性，可以使用<code>hasOwnproterty</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;frank&quot;</span>,<span class=\"attr\">age</span>:<span class=\"number\">18</span>&#125;</span><br><span class=\"line\">obj.hasOwnproperty(<span class=\"string\">&quot;toString&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p><code>in</code>和<code>hasOwnproperty</code>的区别就是，<code>in</code>无法识别某个属性是自身的还是从原型那里继承的，而<code>hasOwnproterty</code>可以识别属性是否是自身的。</p>\n<h3 id=\"属性的遍历：for…in循环\"><a href=\"#属性的遍历：for…in循环\" class=\"headerlink\" title=\"属性的遍历：for…in循环\"></a><strong>属性的遍历：for…in循环</strong></h3><p>用来遍历对象里面的所有属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj = &#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;frank&quot;</span>,<span class=\"attr\">age</span>:<span class=\"number\">18</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> obj)&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i+<span class=\"string\">&quot;:&quot;</span>+obj[key])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//name:frank</span></span><br><span class=\"line\">  age:<span class=\"number\">18</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>(完)</strong></p>\n<p>资料参考：<br>饥人谷<br>阮一峰网道javascript教程</p>"},{"title":"JS对象分类","date":"2020-11-06T04:09:19.000Z","toc":true,"cover":"./img/JS3.jpg","_content":"### __构建函数__\n```javascript\nfunction Person(name,age){\nthis.name = name\nthis.age = age\n}\nPerson.prototype.shcool = \"第二小学\"\nlet person = new Person(\"leeho\",10)\n```\n<!--more-->\n现在我们要把第二小学里的每个学生都定义成一个对象，每个学生对象要包含`name` `age` `shcool` ,一个学校里面有很多个学生，每个学生对象的私有属性是`name`和`age`,共有属性是`school`都来自第二小学，我们就可以通过构建函数的方式，来创建每个学生的对象。\n我们先定义一个构建函数`Person`，它接受两个参数`name`和`age`。`Person`的原型`prototype`里面包含着，要创建的每个对象的共有属性`shcool=第二小学`\n然后通过`new`关键字，就可以创建出一个新对象，新对象的`name` `age`是我们Person传入的的参数，新对象的`__proto__`里面有就有了`Person`的`prototype`里的`shcool = \"第二小学\"`这个共有属性\n\n### __new关键字__\n`new`关键字,做了什么：\n1. 创建了一个空对象。\n2. 为空对象关联原型，原型地址指定为构建函数的`protoytpe`\n3. 将空对象赋值给`this`关键字\n\n`new`作用是执行构造函数，并且返回一个实例对象\n\n### __this关键字__\n```javascript\nlet obj = {\nname:\"leeho\",\nsayHi:funcition{console.log(\"大家好，我叫\"+this.name)}\n}\n```\n作为对象属性的函数，叫做这个对象的`方法`。对象里面的`方法`，需要调用这个对象的里面属性的时候，就会使用的到`this`,以上代码，sayHi被调用的时候，里面的`this`就是obj\n#### __this的值到底值什么__\n要理解`this`必须记住以下两点\n1. `this`永远指向一个对象。\n2. `this`的值是什么，完全取决于函数调用的位置。\n\n```javascript\nfuncition sayHi(){\nconsole.log(this.name)\n}\nvar obj ={\n\tname:\"leeho\",\n\tsayHi:sayHi\n}\nvar name = \"frank\"\n\nobj.sayHi() // \"leeho\"\nsayHi() // \"frank\"\n```\n要理解以上代码，必须知道`var`声明的变量会自己动绑定到`window`上，会变成`window`的一个属性。\n当我们`obj.sayHi()`这样调用`sayHi()`的时候，`sayHi()`运行的环境是在`obj`这里对象里面，所以里面的`this`是指向`obj`的，自然就会`obj`里面的属性`name`，打印出来就是`leeho`\n当我们`sayHi()`这样调用的时候，`sayHi`的运行环境是在`window`上，因为我们用`var`声明了`name`,`name`变成了`window`上面的属性，所以打印出来就是`frank`,其实当我们`sayHi()`这样调用函数的时候，其实是这样的`window.sayHi()`\n通过以上代码，我们就可以知道，`this`到底是什么值，取决于是谁在调用`this`。\n\n```javascript\nvar obj = {\n\tname:\"leeho\",\n\tsayHi:funcition(){\n\t\tconsole.log(this.name)\n\t}\n}\n\nvar obj1 = obj.sayHi\n\nobj.sayHi()  // \"leeho\"\nobj1() // undefined\n```\n以上代码，`obj.sayHi()`打印出`leeho`，很好理解，但是`obj1()`为什么会打印出`undefined`呢？那是因为`obj1 =obj.sayHi` ，这个操作只是把函数`sayHi`的内存地址传给`obj1`，当我们`obj1()`的时候，其实`sayHi()`的运行环境还是在`window`上，所以打印出了`undefined`\n\n#### __call()和apple()__\n函数作为对象提供了`call()` `apply()`方法，他们也可以用来调用函数，这两个方法都接受一个对象作为参数，用来指定本次调用时函数中this的指向；\n__call()__\n> call()的语法规则\n函数名.call(对象,参数1,参数2...)\n接受一个对象，和函数的参数\n\n```javascript\nobj1 = {name:\"leeho\"}\nobj2 = {name:\"frank\"}\nfuncition sayHi(age){\nconsole.log(\"大家好，我叫\"+this.name+\"我今年\"+age+\"岁\")\n}\nsayHi.call(obj2,33)  //大家好，我叫leeho，我今年33岁\nsayHi.call(obj2,18)  //大家好，我叫frank，我今年18岁\n```\n以上代码可以看出，call可以指定一个函数在被调用时，函数中的this指向。\n\n__apple()__\n> apple()的语法规则\n函数名.call(对象,[参数1,参数2,参数3...])\n其实apple跟call的功能是一样的,只是他接受参数，是以数组方式的。\n\n### __类型和类__\n* 类型指的是JS的7种数据类型，`数字` `字符串` `undefined` `null` `布尔值` `Symbol` `对象`\n* 类指的是JS里对象的分类，有无数种，常见的有`数组` `函数` `Date` `RegExp`等等\n\n### __class语法__\nES6引入了class语法，可以定义一个类，我的理解，class是构造函数的语法糖，原理基本一样，只是更方便理解。\n重写定义学生的类\n```javascript\nclass Person{\n\tconstructor(name,age){\n\t\tthis.name = name,\n\t\tthis.age = age\n\t}\n\tsayHi(){console.log(\"大家好，我的名字叫\"+this.name)}\n}\nPerson.prototype.shcool = \"第二小学\"\n\nlet person = new Person(\"leeho\",19)\n```\n跟构造函数很类似，我们把`私有属性`写到`constructor`里面，把要加到原型`prototype`上的方法，写到`contructor`外面,这里要注意`class`的语法，`constructor`外面只能写方法，才会被加到原型里面，如果写`键值对`就会被加到`私有属性`里面,如果我们想要在原型里面加键值对的话,还是要写成`Person.prototype.schoole = \"第二小学\"`，从以上看class语法只是更直观的声明了类，但是原理还是构造函数那一套。\n\n（完）\n参考资料：\n1.饥人谷\n2.[彻底搞懂JavaScript中的this指向问题](https://zhuanlan.zhihu.com/p/42145138)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/JS对象分类.md","raw":"---\ntitle: JS对象分类\ndate: 2020-11-06 04:09:19\ntags: javascript\ntoc: true \ncover: ./img/JS3.jpg\n---\n### __构建函数__\n```javascript\nfunction Person(name,age){\nthis.name = name\nthis.age = age\n}\nPerson.prototype.shcool = \"第二小学\"\nlet person = new Person(\"leeho\",10)\n```\n<!--more-->\n现在我们要把第二小学里的每个学生都定义成一个对象，每个学生对象要包含`name` `age` `shcool` ,一个学校里面有很多个学生，每个学生对象的私有属性是`name`和`age`,共有属性是`school`都来自第二小学，我们就可以通过构建函数的方式，来创建每个学生的对象。\n我们先定义一个构建函数`Person`，它接受两个参数`name`和`age`。`Person`的原型`prototype`里面包含着，要创建的每个对象的共有属性`shcool=第二小学`\n然后通过`new`关键字，就可以创建出一个新对象，新对象的`name` `age`是我们Person传入的的参数，新对象的`__proto__`里面有就有了`Person`的`prototype`里的`shcool = \"第二小学\"`这个共有属性\n\n### __new关键字__\n`new`关键字,做了什么：\n1. 创建了一个空对象。\n2. 为空对象关联原型，原型地址指定为构建函数的`protoytpe`\n3. 将空对象赋值给`this`关键字\n\n`new`作用是执行构造函数，并且返回一个实例对象\n\n### __this关键字__\n```javascript\nlet obj = {\nname:\"leeho\",\nsayHi:funcition{console.log(\"大家好，我叫\"+this.name)}\n}\n```\n作为对象属性的函数，叫做这个对象的`方法`。对象里面的`方法`，需要调用这个对象的里面属性的时候，就会使用的到`this`,以上代码，sayHi被调用的时候，里面的`this`就是obj\n#### __this的值到底值什么__\n要理解`this`必须记住以下两点\n1. `this`永远指向一个对象。\n2. `this`的值是什么，完全取决于函数调用的位置。\n\n```javascript\nfuncition sayHi(){\nconsole.log(this.name)\n}\nvar obj ={\n\tname:\"leeho\",\n\tsayHi:sayHi\n}\nvar name = \"frank\"\n\nobj.sayHi() // \"leeho\"\nsayHi() // \"frank\"\n```\n要理解以上代码，必须知道`var`声明的变量会自己动绑定到`window`上，会变成`window`的一个属性。\n当我们`obj.sayHi()`这样调用`sayHi()`的时候，`sayHi()`运行的环境是在`obj`这里对象里面，所以里面的`this`是指向`obj`的，自然就会`obj`里面的属性`name`，打印出来就是`leeho`\n当我们`sayHi()`这样调用的时候，`sayHi`的运行环境是在`window`上，因为我们用`var`声明了`name`,`name`变成了`window`上面的属性，所以打印出来就是`frank`,其实当我们`sayHi()`这样调用函数的时候，其实是这样的`window.sayHi()`\n通过以上代码，我们就可以知道，`this`到底是什么值，取决于是谁在调用`this`。\n\n```javascript\nvar obj = {\n\tname:\"leeho\",\n\tsayHi:funcition(){\n\t\tconsole.log(this.name)\n\t}\n}\n\nvar obj1 = obj.sayHi\n\nobj.sayHi()  // \"leeho\"\nobj1() // undefined\n```\n以上代码，`obj.sayHi()`打印出`leeho`，很好理解，但是`obj1()`为什么会打印出`undefined`呢？那是因为`obj1 =obj.sayHi` ，这个操作只是把函数`sayHi`的内存地址传给`obj1`，当我们`obj1()`的时候，其实`sayHi()`的运行环境还是在`window`上，所以打印出了`undefined`\n\n#### __call()和apple()__\n函数作为对象提供了`call()` `apply()`方法，他们也可以用来调用函数，这两个方法都接受一个对象作为参数，用来指定本次调用时函数中this的指向；\n__call()__\n> call()的语法规则\n函数名.call(对象,参数1,参数2...)\n接受一个对象，和函数的参数\n\n```javascript\nobj1 = {name:\"leeho\"}\nobj2 = {name:\"frank\"}\nfuncition sayHi(age){\nconsole.log(\"大家好，我叫\"+this.name+\"我今年\"+age+\"岁\")\n}\nsayHi.call(obj2,33)  //大家好，我叫leeho，我今年33岁\nsayHi.call(obj2,18)  //大家好，我叫frank，我今年18岁\n```\n以上代码可以看出，call可以指定一个函数在被调用时，函数中的this指向。\n\n__apple()__\n> apple()的语法规则\n函数名.call(对象,[参数1,参数2,参数3...])\n其实apple跟call的功能是一样的,只是他接受参数，是以数组方式的。\n\n### __类型和类__\n* 类型指的是JS的7种数据类型，`数字` `字符串` `undefined` `null` `布尔值` `Symbol` `对象`\n* 类指的是JS里对象的分类，有无数种，常见的有`数组` `函数` `Date` `RegExp`等等\n\n### __class语法__\nES6引入了class语法，可以定义一个类，我的理解，class是构造函数的语法糖，原理基本一样，只是更方便理解。\n重写定义学生的类\n```javascript\nclass Person{\n\tconstructor(name,age){\n\t\tthis.name = name,\n\t\tthis.age = age\n\t}\n\tsayHi(){console.log(\"大家好，我的名字叫\"+this.name)}\n}\nPerson.prototype.shcool = \"第二小学\"\n\nlet person = new Person(\"leeho\",19)\n```\n跟构造函数很类似，我们把`私有属性`写到`constructor`里面，把要加到原型`prototype`上的方法，写到`contructor`外面,这里要注意`class`的语法，`constructor`外面只能写方法，才会被加到原型里面，如果写`键值对`就会被加到`私有属性`里面,如果我们想要在原型里面加键值对的话,还是要写成`Person.prototype.schoole = \"第二小学\"`，从以上看class语法只是更直观的声明了类，但是原理还是构造函数那一套。\n\n（完）\n参考资料：\n1.饥人谷\n2.[彻底搞懂JavaScript中的this指向问题](https://zhuanlan.zhihu.com/p/42145138)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"JS对象分类","published":1,"updated":"2020-11-08T07:58:22.421Z","_id":"ckh5qrabj00003nfqd7z89hvc","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"构建函数\"><a href=\"#构建函数\" class=\"headerlink\" title=\"构建函数\"></a><strong>构建函数</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">this</span>.name = name</span><br><span class=\"line\"><span class=\"built_in\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.shcool = <span class=\"string\">&quot;第二小学&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;leeho&quot;</span>,<span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>现在我们要把第二小学里的每个学生都定义成一个对象，每个学生对象要包含<code>name</code> <code>age</code> <code>shcool</code> ,一个学校里面有很多个学生，每个学生对象的私有属性是<code>name</code>和<code>age</code>,共有属性是<code>school</code>都来自第二小学，我们就可以通过构建函数的方式，来创建每个学生的对象。<br>我们先定义一个构建函数<code>Person</code>，它接受两个参数<code>name</code>和<code>age</code>。<code>Person</code>的原型<code>prototype</code>里面包含着，要创建的每个对象的共有属性<code>shcool=第二小学</code><br>然后通过<code>new</code>关键字，就可以创建出一个新对象，新对象的<code>name</code> <code>age</code>是我们Person传入的的参数，新对象的<code>__proto__</code>里面有就有了<code>Person</code>的<code>prototype</code>里的<code>shcool = &quot;第二小学&quot;</code>这个共有属性</p>\n<h3 id=\"new关键字\"><a href=\"#new关键字\" class=\"headerlink\" title=\"new关键字\"></a><strong>new关键字</strong></h3><p><code>new</code>关键字,做了什么：</p>\n<ol>\n<li>创建了一个空对象。</li>\n<li>为空对象关联原型，原型地址指定为构建函数的<code>protoytpe</code></li>\n<li>将空对象赋值给<code>this</code>关键字</li>\n</ol>\n<p><code>new</code>作用是执行构造函数，并且返回一个实例对象</p>\n<h3 id=\"this关键字\"><a href=\"#this关键字\" class=\"headerlink\" title=\"this关键字\"></a><strong>this关键字</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">name:<span class=\"string\">&quot;leeho&quot;</span>,</span><br><span class=\"line\">sayHi:funcition&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;大家好，我叫&quot;</span>+<span class=\"built_in\">this</span>.name)&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>作为对象属性的函数，叫做这个对象的<code>方法</code>。对象里面的<code>方法</code>，需要调用这个对象的里面属性的时候，就会使用的到<code>this</code>,以上代码，sayHi被调用的时候，里面的<code>this</code>就是obj</p>\n<h4 id=\"this的值到底值什么\"><a href=\"#this的值到底值什么\" class=\"headerlink\" title=\"this的值到底值什么\"></a><strong>this的值到底值什么</strong></h4><p>要理解<code>this</code>必须记住以下两点</p>\n<ol>\n<li><code>this</code>永远指向一个对象。</li>\n<li><code>this</code>的值是什么，完全取决于函数调用的位置。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">funcition sayHi()&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj =&#123;</span><br><span class=\"line\">\tname:<span class=\"string\">&quot;leeho&quot;</span>,</span><br><span class=\"line\">\tsayHi:sayHi</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">&quot;frank&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.sayHi() <span class=\"comment\">// &quot;leeho&quot;</span></span><br><span class=\"line\">sayHi() <span class=\"comment\">// &quot;frank&quot;</span></span><br></pre></td></tr></table></figure>\n<p>要理解以上代码，必须知道<code>var</code>声明的变量会自己动绑定到<code>window</code>上，会变成<code>window</code>的一个属性。<br>当我们<code>obj.sayHi()</code>这样调用<code>sayHi()</code>的时候，<code>sayHi()</code>运行的环境是在<code>obj</code>这里对象里面，所以里面的<code>this</code>是指向<code>obj</code>的，自然就会<code>obj</code>里面的属性<code>name</code>，打印出来就是<code>leeho</code><br>当我们<code>sayHi()</code>这样调用的时候，<code>sayHi</code>的运行环境是在<code>window</code>上，因为我们用<code>var</code>声明了<code>name</code>,<code>name</code>变成了<code>window</code>上面的属性，所以打印出来就是<code>frank</code>,其实当我们<code>sayHi()</code>这样调用函数的时候，其实是这样的<code>window.sayHi()</code><br>通过以上代码，我们就可以知道，<code>this</code>到底是什么值，取决于是谁在调用<code>this</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">\tname:<span class=\"string\">&quot;leeho&quot;</span>,</span><br><span class=\"line\">\tsayHi:funcition()&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = obj.sayHi</span><br><span class=\"line\"></span><br><span class=\"line\">obj.sayHi()  <span class=\"comment\">// &quot;leeho&quot;</span></span><br><span class=\"line\">obj1() <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>以上代码，<code>obj.sayHi()</code>打印出<code>leeho</code>，很好理解，但是<code>obj1()</code>为什么会打印出<code>undefined</code>呢？那是因为<code>obj1 =obj.sayHi</code> ，这个操作只是把函数<code>sayHi</code>的内存地址传给<code>obj1</code>，当我们<code>obj1()</code>的时候，其实<code>sayHi()</code>的运行环境还是在<code>window</code>上，所以打印出了<code>undefined</code></p>\n<h4 id=\"call-和apple\"><a href=\"#call-和apple\" class=\"headerlink\" title=\"call()和apple()\"></a><strong>call()和apple()</strong></h4><p>函数作为对象提供了<code>call()</code> <code>apply()</code>方法，他们也可以用来调用函数，这两个方法都接受一个对象作为参数，用来指定本次调用时函数中this的指向；<br><strong>call()</strong></p>\n<blockquote>\n<p>call()的语法规则<br>函数名.call(对象,参数1,参数2…)<br>接受一个对象，和函数的参数</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj1 = &#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;leeho&quot;</span>&#125;</span><br><span class=\"line\">obj2 = &#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;frank&quot;</span>&#125;</span><br><span class=\"line\">funcition sayHi(age)&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;大家好，我叫&quot;</span>+<span class=\"built_in\">this</span>.name+<span class=\"string\">&quot;我今年&quot;</span>+age+<span class=\"string\">&quot;岁&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayHi.call(obj2,<span class=\"number\">33</span>)  <span class=\"comment\">//大家好，我叫leeho，我今年33岁</span></span><br><span class=\"line\">sayHi.call(obj2,<span class=\"number\">18</span>)  <span class=\"comment\">//大家好，我叫frank，我今年18岁</span></span><br></pre></td></tr></table></figure>\n<p>以上代码可以看出，call可以指定一个函数在被调用时，函数中的this指向。</p>\n<p><strong>apple()</strong></p>\n<blockquote>\n<p>apple()的语法规则<br>函数名.call(对象,[参数1,参数2,参数3…])<br>其实apple跟call的功能是一样的,只是他接受参数，是以数组方式的。</p>\n</blockquote>\n<h3 id=\"类型和类\"><a href=\"#类型和类\" class=\"headerlink\" title=\"类型和类\"></a><strong>类型和类</strong></h3><ul>\n<li>类型指的是JS的7种数据类型，<code>数字</code> <code>字符串</code> <code>undefined</code> <code>null</code> <code>布尔值</code> <code>Symbol</code> <code>对象</code></li>\n<li>类指的是JS里对象的分类，有无数种，常见的有<code>数组</code> <code>函数</code> <code>Date</code> <code>RegExp</code>等等</li>\n</ul>\n<h3 id=\"class语法\"><a href=\"#class语法\" class=\"headerlink\" title=\"class语法\"></a><strong>class语法</strong></h3><p>ES6引入了class语法，可以定义一个类，我的理解，class是构造函数的语法糖，原理基本一样，只是更方便理解。<br>重写定义学生的类</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">constructor</span>(name,age)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.name = name,</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.age = age</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsayHi()&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;大家好，我的名字叫&quot;</span>+<span class=\"built_in\">this</span>.name)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.shcool = <span class=\"string\">&quot;第二小学&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;leeho&quot;</span>,<span class=\"number\">19</span>)</span><br></pre></td></tr></table></figure>\n<p>跟构造函数很类似，我们把<code>私有属性</code>写到<code>constructor</code>里面，把要加到原型<code>prototype</code>上的方法，写到<code>contructor</code>外面,这里要注意<code>class</code>的语法，<code>constructor</code>外面只能写方法，才会被加到原型里面，如果写<code>键值对</code>就会被加到<code>私有属性</code>里面,如果我们想要在原型里面加键值对的话,还是要写成<code>Person.prototype.schoole = &quot;第二小学&quot;</code>，从以上看class语法只是更直观的声明了类，但是原理还是构造函数那一套。</p>\n<p>（完）<br>参考资料：<br>1.饥人谷<br>2.<a href=\"https://zhuanlan.zhihu.com/p/42145138\">彻底搞懂JavaScript中的this指向问题</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"构建函数\"><a href=\"#构建函数\" class=\"headerlink\" title=\"构建函数\"></a><strong>构建函数</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">this</span>.name = name</span><br><span class=\"line\"><span class=\"built_in\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.shcool = <span class=\"string\">&quot;第二小学&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;leeho&quot;</span>,<span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>","more":"<p>现在我们要把第二小学里的每个学生都定义成一个对象，每个学生对象要包含<code>name</code> <code>age</code> <code>shcool</code> ,一个学校里面有很多个学生，每个学生对象的私有属性是<code>name</code>和<code>age</code>,共有属性是<code>school</code>都来自第二小学，我们就可以通过构建函数的方式，来创建每个学生的对象。<br>我们先定义一个构建函数<code>Person</code>，它接受两个参数<code>name</code>和<code>age</code>。<code>Person</code>的原型<code>prototype</code>里面包含着，要创建的每个对象的共有属性<code>shcool=第二小学</code><br>然后通过<code>new</code>关键字，就可以创建出一个新对象，新对象的<code>name</code> <code>age</code>是我们Person传入的的参数，新对象的<code>__proto__</code>里面有就有了<code>Person</code>的<code>prototype</code>里的<code>shcool = &quot;第二小学&quot;</code>这个共有属性</p>\n<h3 id=\"new关键字\"><a href=\"#new关键字\" class=\"headerlink\" title=\"new关键字\"></a><strong>new关键字</strong></h3><p><code>new</code>关键字,做了什么：</p>\n<ol>\n<li>创建了一个空对象。</li>\n<li>为空对象关联原型，原型地址指定为构建函数的<code>protoytpe</code></li>\n<li>将空对象赋值给<code>this</code>关键字</li>\n</ol>\n<p><code>new</code>作用是执行构造函数，并且返回一个实例对象</p>\n<h3 id=\"this关键字\"><a href=\"#this关键字\" class=\"headerlink\" title=\"this关键字\"></a><strong>this关键字</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">name:<span class=\"string\">&quot;leeho&quot;</span>,</span><br><span class=\"line\">sayHi:funcition&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;大家好，我叫&quot;</span>+<span class=\"built_in\">this</span>.name)&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>作为对象属性的函数，叫做这个对象的<code>方法</code>。对象里面的<code>方法</code>，需要调用这个对象的里面属性的时候，就会使用的到<code>this</code>,以上代码，sayHi被调用的时候，里面的<code>this</code>就是obj</p>\n<h4 id=\"this的值到底值什么\"><a href=\"#this的值到底值什么\" class=\"headerlink\" title=\"this的值到底值什么\"></a><strong>this的值到底值什么</strong></h4><p>要理解<code>this</code>必须记住以下两点</p>\n<ol>\n<li><code>this</code>永远指向一个对象。</li>\n<li><code>this</code>的值是什么，完全取决于函数调用的位置。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">funcition sayHi()&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj =&#123;</span><br><span class=\"line\">\tname:<span class=\"string\">&quot;leeho&quot;</span>,</span><br><span class=\"line\">\tsayHi:sayHi</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">&quot;frank&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.sayHi() <span class=\"comment\">// &quot;leeho&quot;</span></span><br><span class=\"line\">sayHi() <span class=\"comment\">// &quot;frank&quot;</span></span><br></pre></td></tr></table></figure>\n<p>要理解以上代码，必须知道<code>var</code>声明的变量会自己动绑定到<code>window</code>上，会变成<code>window</code>的一个属性。<br>当我们<code>obj.sayHi()</code>这样调用<code>sayHi()</code>的时候，<code>sayHi()</code>运行的环境是在<code>obj</code>这里对象里面，所以里面的<code>this</code>是指向<code>obj</code>的，自然就会<code>obj</code>里面的属性<code>name</code>，打印出来就是<code>leeho</code><br>当我们<code>sayHi()</code>这样调用的时候，<code>sayHi</code>的运行环境是在<code>window</code>上，因为我们用<code>var</code>声明了<code>name</code>,<code>name</code>变成了<code>window</code>上面的属性，所以打印出来就是<code>frank</code>,其实当我们<code>sayHi()</code>这样调用函数的时候，其实是这样的<code>window.sayHi()</code><br>通过以上代码，我们就可以知道，<code>this</code>到底是什么值，取决于是谁在调用<code>this</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">\tname:<span class=\"string\">&quot;leeho&quot;</span>,</span><br><span class=\"line\">\tsayHi:funcition()&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = obj.sayHi</span><br><span class=\"line\"></span><br><span class=\"line\">obj.sayHi()  <span class=\"comment\">// &quot;leeho&quot;</span></span><br><span class=\"line\">obj1() <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>以上代码，<code>obj.sayHi()</code>打印出<code>leeho</code>，很好理解，但是<code>obj1()</code>为什么会打印出<code>undefined</code>呢？那是因为<code>obj1 =obj.sayHi</code> ，这个操作只是把函数<code>sayHi</code>的内存地址传给<code>obj1</code>，当我们<code>obj1()</code>的时候，其实<code>sayHi()</code>的运行环境还是在<code>window</code>上，所以打印出了<code>undefined</code></p>\n<h4 id=\"call-和apple\"><a href=\"#call-和apple\" class=\"headerlink\" title=\"call()和apple()\"></a><strong>call()和apple()</strong></h4><p>函数作为对象提供了<code>call()</code> <code>apply()</code>方法，他们也可以用来调用函数，这两个方法都接受一个对象作为参数，用来指定本次调用时函数中this的指向；<br><strong>call()</strong></p>\n<blockquote>\n<p>call()的语法规则<br>函数名.call(对象,参数1,参数2…)<br>接受一个对象，和函数的参数</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj1 = &#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;leeho&quot;</span>&#125;</span><br><span class=\"line\">obj2 = &#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;frank&quot;</span>&#125;</span><br><span class=\"line\">funcition sayHi(age)&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;大家好，我叫&quot;</span>+<span class=\"built_in\">this</span>.name+<span class=\"string\">&quot;我今年&quot;</span>+age+<span class=\"string\">&quot;岁&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayHi.call(obj2,<span class=\"number\">33</span>)  <span class=\"comment\">//大家好，我叫leeho，我今年33岁</span></span><br><span class=\"line\">sayHi.call(obj2,<span class=\"number\">18</span>)  <span class=\"comment\">//大家好，我叫frank，我今年18岁</span></span><br></pre></td></tr></table></figure>\n<p>以上代码可以看出，call可以指定一个函数在被调用时，函数中的this指向。</p>\n<p><strong>apple()</strong></p>\n<blockquote>\n<p>apple()的语法规则<br>函数名.call(对象,[参数1,参数2,参数3…])<br>其实apple跟call的功能是一样的,只是他接受参数，是以数组方式的。</p>\n</blockquote>\n<h3 id=\"类型和类\"><a href=\"#类型和类\" class=\"headerlink\" title=\"类型和类\"></a><strong>类型和类</strong></h3><ul>\n<li>类型指的是JS的7种数据类型，<code>数字</code> <code>字符串</code> <code>undefined</code> <code>null</code> <code>布尔值</code> <code>Symbol</code> <code>对象</code></li>\n<li>类指的是JS里对象的分类，有无数种，常见的有<code>数组</code> <code>函数</code> <code>Date</code> <code>RegExp</code>等等</li>\n</ul>\n<h3 id=\"class语法\"><a href=\"#class语法\" class=\"headerlink\" title=\"class语法\"></a><strong>class语法</strong></h3><p>ES6引入了class语法，可以定义一个类，我的理解，class是构造函数的语法糖，原理基本一样，只是更方便理解。<br>重写定义学生的类</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">constructor</span>(name,age)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.name = name,</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.age = age</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsayHi()&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;大家好，我的名字叫&quot;</span>+<span class=\"built_in\">this</span>.name)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.shcool = <span class=\"string\">&quot;第二小学&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;leeho&quot;</span>,<span class=\"number\">19</span>)</span><br></pre></td></tr></table></figure>\n<p>跟构造函数很类似，我们把<code>私有属性</code>写到<code>constructor</code>里面，把要加到原型<code>prototype</code>上的方法，写到<code>contructor</code>外面,这里要注意<code>class</code>的语法，<code>constructor</code>外面只能写方法，才会被加到原型里面，如果写<code>键值对</code>就会被加到<code>私有属性</code>里面,如果我们想要在原型里面加键值对的话,还是要写成<code>Person.prototype.schoole = &quot;第二小学&quot;</code>，从以上看class语法只是更直观的声明了类，但是原理还是构造函数那一套。</p>\n<p>（完）<br>参考资料：<br>1.饥人谷<br>2.<a href=\"https://zhuanlan.zhihu.com/p/42145138\">彻底搞懂JavaScript中的this指向问题</a></p>"},{"title":"JS数组","date":"2020-11-08T08:18:44.000Z","toc":true,"cover":"./img/JS2.jpg","_content":"> Javascript里面并没有真正的数组，只是用对象模拟的数组。\n\n### __创建一个数组__\n```javascript\n1. let arr = [1,2,3,4,5,6]\n2. let arr1 = new Array(1,2,3,4,5,6)\n```\n<!--more-->\n上面两种方法都可以创建一个数组，第一种是简写模式，第二种是规范模式，要注意的是第二种创建的方式，如果`Array()`里面只有一个参数的时候，是定义这个数组`length`。\n\n### __数组的转化__\n1. __字符串转数组__\n\n```javascript\nlet str = \"123456\"\nlet arr = str.split('')\nconsole.log(arr)\n//[1,2,3,4,5,6]\n```\n`split`可以将字符串转换为数组，里面接受两个参数，第一个参数表示以什么做为分隔符分隔字符串，第二个参数指定返回数组的长度。\n\n```javascript\nlet str = \"123\"\nlet arr = Array.from(str)\n```\n`Array.from`可以将一个有length属性的对象，转换成一个数组。接受3个参数，第一个参数是要转换为数组的对象，第二个参数是数组中每个参数要调用的函数，映射函数中this的对象\n\n```javascript\nlet arr = [1,2,3,4]\nlet str = arr.join()\n```\n`join`可以将数组里所有元素连接起来，变成一个字符串。接受一个参数，指定数组里面的每个元素用什么方式相连。\n\n```javascript\nlet arr = [1,2,3]\nlet arr1 = [4,5,6]\nlet arr3 = arr.concat(arr1)\n```\n`concat`可以连接两个数组，不会改变原来的数组，会返回一个连接后的新数组。\n\n```javascript\nlet arr = [1,2,3,4,5]\nlet arr1 = arr.slice(0,3)\n```\n`slice`可以截取数组，接受两个参数，第一个参数表示从哪里开始截取，第二个参数表示截取到哪里结束。第二个参数如果省略，就会从开始的位置一直到数组最后。如果是0的话，就可以截取整个数组，这样就相当于复制的这个数组。\n\n### __数组的增删改查__\n__删除数组里的元素__\n修改`length`这样也可以删除元素。但是不建议这样删除数组里面的元素\n```javascript\nlet arr = [1,2,3,4,5,6,7]\narr.shift()\n```\n`shift()`可以删除数组里的第一个元素，并且返回该元素\n```javascript\nlet arr = [1,2,3,4,5,6,7]\narr.pop()\n```\n`pop()`可以删除数组里的最后一个元素，并且返回该元素\n```javascript\nlet arr = [1,2,3,4,5,6,7]\narr.splice(1,1,3)\n```\n`splice()`方法接受三个参数，第一个是数组元素的位置，第二是要删除几个，第三个就是要在删除的位置上增加的元素\n\n__查看数组里的元素__\n因为数组也是一种对象，所以可以用`Object.keys`和`Object.values`来查看数组里面元素的属性名和属性值。因为数组里面所谓的属性名都是用数字作为属性名，如果通过`Object.keys`来查看的话，会连不是数字的属性名也一并查出来,所以查看数组，我们一般是用`for`循环来遍历一个数组\n```javascript\nlet arr = [1,2,3,4,5,6]\nfor(let i=0;i<arr.length;i++){\n\tconsole.log(`${i}:${arr[i]}`)\n}\n```\n以上代码就是用`for`循环遍历一个数组\n\n还可以用`forEach()`来遍历一个数组\n```javascript\nlet arr = [1,2,3,4,5,6,7]\narr.forEach(function(x,y,z){\n\tconsole.log(`${y}:$[x];${z}`)\n})\n```\n`forEach()`方法接受一个函数，函数里面接受3个参数，第一个参数是数组的索引，第二参数是数组的元素，第三个参数是数组本身。\n为了更好的理解`forEach`，我们可以手写一个`forEach`函数\n```javascript\nfunction Foreach(fn){\n\tfor(let i = 0;i<this.length;i++){\n\t\tfn(i,this[i],this)\n\t}\n}\n```\n以上代码就是`forEach`的原理，接受一个函数，然后`for`循环，每次`for`循环就调用一次传入的函数，并且把`i`,`this[i]`,`this`,传回给函数。\n\n查看数组里面的单个元素\n```javascript\nlet arr = [1,2,3,4,5,6,7]\narr[0] //查看第一个元素\narr[1] //查看第二个元素\n```\n\n查看数组里面是否有否个元素\n```javascript\nlet arr = [1,2,3,4,5]\narr.indexOf(item)\n```\n如果存在元素，就返回该元素对应的索引，如果不存就返回-1\n\n使用条件查找元素\n```javascript\nlet arr = [1,2,3,4,5,6,7,8]\narr.find(item=>item%2===0)\n```\n找到第一个偶数\n\n__增加数组里的元素__\n`push()`从尾部加入N个元素，返回数组的新长度。\n\n`unshift()`从头部加入N个，返回数组新长度。\n\n`splice()` \n```javascript\nlet arr = [1,2,3,4,5,6,7]\narr.splice(1,0,1,2,3,4)\n```\n以上代码表示，从索引为1的位置，删除0个元素，然后插入1,2,3,4\n\n`reverse()` 可以改变数组的排列顺序\n\n`sort()` 让数组进行排序\n```javascript\nlet arr = [20,32,3,41,53]\narr.sort()\n```\n理解不了，默认情况是按从小到大的排序。如果要按从大到小排序，需要进行下面操作\n```javascript\nlet arr = [20,32,3,41,53]\narr.sort(function(a,b){\n\treturn a - b //升序\n\treturn b - a //降序\n})\n```\n原理现在的知识，实在是搞不懂，只能死记硬背。。\n\n### __数组变化__\n有三个方法\n1. `map()` 加工一下原有数组，然后返回。 n变n\n2. `filter()` 在数组里面找到符合条件的元素 n变少\n3. `reduce()` n变1 \n三个方法可以通过下图理解\n<div align=\"center\"><img src=\"./img/img1.png\"></div>\n\n`map()`和`fliter()`都很好理解\n最难理解的是`reduce()`\n`reduce()`里面接受两个参数，第一个参数为一个函数，第二个参数是原始值\n1. 第一个值(fn),里面有可以接受4个值\n* 累记器\n* 数组中正在处理的元素\n* 数组中正在处理元素的索引\n* 数组本身\n2. 原始值\n\n下面是两个例子\n```javascript\nlet arr = [1,2,3,4,5,6]\narr.reduce(function(sum,item){\n\treturn sum = sum + item\n},0)\n```\n数组arr里面所有元素相加。\n\n```javascript\nlet arr = [1,2,3,4,5,6,7]\narr.reduce(function(a,b,c){\n\tif(b>3){\n\t\treturn a = a.concat(c)\n\t}else{\n\t\treturn a\n\t}\n},[])\n```\n上面的代码是，把arr数组里面，所有大于3的元素的索引，记录在一个数组里面\n\n<完>\n\n参考资料\n饥人谷\n","source":"_posts/JS数组.md","raw":"---\ntitle: JS数组\ndate: 2020-11-08 08:18:44\ntags: javascript\ntoc: true\ncover: ./img/JS2.jpg\n---\n> Javascript里面并没有真正的数组，只是用对象模拟的数组。\n\n### __创建一个数组__\n```javascript\n1. let arr = [1,2,3,4,5,6]\n2. let arr1 = new Array(1,2,3,4,5,6)\n```\n<!--more-->\n上面两种方法都可以创建一个数组，第一种是简写模式，第二种是规范模式，要注意的是第二种创建的方式，如果`Array()`里面只有一个参数的时候，是定义这个数组`length`。\n\n### __数组的转化__\n1. __字符串转数组__\n\n```javascript\nlet str = \"123456\"\nlet arr = str.split('')\nconsole.log(arr)\n//[1,2,3,4,5,6]\n```\n`split`可以将字符串转换为数组，里面接受两个参数，第一个参数表示以什么做为分隔符分隔字符串，第二个参数指定返回数组的长度。\n\n```javascript\nlet str = \"123\"\nlet arr = Array.from(str)\n```\n`Array.from`可以将一个有length属性的对象，转换成一个数组。接受3个参数，第一个参数是要转换为数组的对象，第二个参数是数组中每个参数要调用的函数，映射函数中this的对象\n\n```javascript\nlet arr = [1,2,3,4]\nlet str = arr.join()\n```\n`join`可以将数组里所有元素连接起来，变成一个字符串。接受一个参数，指定数组里面的每个元素用什么方式相连。\n\n```javascript\nlet arr = [1,2,3]\nlet arr1 = [4,5,6]\nlet arr3 = arr.concat(arr1)\n```\n`concat`可以连接两个数组，不会改变原来的数组，会返回一个连接后的新数组。\n\n```javascript\nlet arr = [1,2,3,4,5]\nlet arr1 = arr.slice(0,3)\n```\n`slice`可以截取数组，接受两个参数，第一个参数表示从哪里开始截取，第二个参数表示截取到哪里结束。第二个参数如果省略，就会从开始的位置一直到数组最后。如果是0的话，就可以截取整个数组，这样就相当于复制的这个数组。\n\n### __数组的增删改查__\n__删除数组里的元素__\n修改`length`这样也可以删除元素。但是不建议这样删除数组里面的元素\n```javascript\nlet arr = [1,2,3,4,5,6,7]\narr.shift()\n```\n`shift()`可以删除数组里的第一个元素，并且返回该元素\n```javascript\nlet arr = [1,2,3,4,5,6,7]\narr.pop()\n```\n`pop()`可以删除数组里的最后一个元素，并且返回该元素\n```javascript\nlet arr = [1,2,3,4,5,6,7]\narr.splice(1,1,3)\n```\n`splice()`方法接受三个参数，第一个是数组元素的位置，第二是要删除几个，第三个就是要在删除的位置上增加的元素\n\n__查看数组里的元素__\n因为数组也是一种对象，所以可以用`Object.keys`和`Object.values`来查看数组里面元素的属性名和属性值。因为数组里面所谓的属性名都是用数字作为属性名，如果通过`Object.keys`来查看的话，会连不是数字的属性名也一并查出来,所以查看数组，我们一般是用`for`循环来遍历一个数组\n```javascript\nlet arr = [1,2,3,4,5,6]\nfor(let i=0;i<arr.length;i++){\n\tconsole.log(`${i}:${arr[i]}`)\n}\n```\n以上代码就是用`for`循环遍历一个数组\n\n还可以用`forEach()`来遍历一个数组\n```javascript\nlet arr = [1,2,3,4,5,6,7]\narr.forEach(function(x,y,z){\n\tconsole.log(`${y}:$[x];${z}`)\n})\n```\n`forEach()`方法接受一个函数，函数里面接受3个参数，第一个参数是数组的索引，第二参数是数组的元素，第三个参数是数组本身。\n为了更好的理解`forEach`，我们可以手写一个`forEach`函数\n```javascript\nfunction Foreach(fn){\n\tfor(let i = 0;i<this.length;i++){\n\t\tfn(i,this[i],this)\n\t}\n}\n```\n以上代码就是`forEach`的原理，接受一个函数，然后`for`循环，每次`for`循环就调用一次传入的函数，并且把`i`,`this[i]`,`this`,传回给函数。\n\n查看数组里面的单个元素\n```javascript\nlet arr = [1,2,3,4,5,6,7]\narr[0] //查看第一个元素\narr[1] //查看第二个元素\n```\n\n查看数组里面是否有否个元素\n```javascript\nlet arr = [1,2,3,4,5]\narr.indexOf(item)\n```\n如果存在元素，就返回该元素对应的索引，如果不存就返回-1\n\n使用条件查找元素\n```javascript\nlet arr = [1,2,3,4,5,6,7,8]\narr.find(item=>item%2===0)\n```\n找到第一个偶数\n\n__增加数组里的元素__\n`push()`从尾部加入N个元素，返回数组的新长度。\n\n`unshift()`从头部加入N个，返回数组新长度。\n\n`splice()` \n```javascript\nlet arr = [1,2,3,4,5,6,7]\narr.splice(1,0,1,2,3,4)\n```\n以上代码表示，从索引为1的位置，删除0个元素，然后插入1,2,3,4\n\n`reverse()` 可以改变数组的排列顺序\n\n`sort()` 让数组进行排序\n```javascript\nlet arr = [20,32,3,41,53]\narr.sort()\n```\n理解不了，默认情况是按从小到大的排序。如果要按从大到小排序，需要进行下面操作\n```javascript\nlet arr = [20,32,3,41,53]\narr.sort(function(a,b){\n\treturn a - b //升序\n\treturn b - a //降序\n})\n```\n原理现在的知识，实在是搞不懂，只能死记硬背。。\n\n### __数组变化__\n有三个方法\n1. `map()` 加工一下原有数组，然后返回。 n变n\n2. `filter()` 在数组里面找到符合条件的元素 n变少\n3. `reduce()` n变1 \n三个方法可以通过下图理解\n<div align=\"center\"><img src=\"./img/img1.png\"></div>\n\n`map()`和`fliter()`都很好理解\n最难理解的是`reduce()`\n`reduce()`里面接受两个参数，第一个参数为一个函数，第二个参数是原始值\n1. 第一个值(fn),里面有可以接受4个值\n* 累记器\n* 数组中正在处理的元素\n* 数组中正在处理元素的索引\n* 数组本身\n2. 原始值\n\n下面是两个例子\n```javascript\nlet arr = [1,2,3,4,5,6]\narr.reduce(function(sum,item){\n\treturn sum = sum + item\n},0)\n```\n数组arr里面所有元素相加。\n\n```javascript\nlet arr = [1,2,3,4,5,6,7]\narr.reduce(function(a,b,c){\n\tif(b>3){\n\t\treturn a = a.concat(c)\n\t}else{\n\t\treturn a\n\t}\n},[])\n```\n上面的代码是，把arr数组里面，所有大于3的元素的索引，记录在一个数组里面\n\n<完>\n\n参考资料\n饥人谷\n","slug":"JS数组","published":1,"updated":"2020-11-11T06:38:41.692Z","_id":"ckh8uitab00006ffq84rg4y11","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>Javascript里面并没有真正的数组，只是用对象模拟的数组。</p>\n</blockquote>\n<h3 id=\"创建一个数组\"><a href=\"#创建一个数组\" class=\"headerlink\" title=\"创建一个数组\"></a><strong>创建一个数组</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> arr1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>)</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>上面两种方法都可以创建一个数组，第一种是简写模式，第二种是规范模式，要注意的是第二种创建的方式，如果<code>Array()</code>里面只有一个参数的时候，是定义这个数组<code>length</code>。</p>\n<h3 id=\"数组的转化\"><a href=\"#数组的转化\" class=\"headerlink\" title=\"数组的转化\"></a><strong>数组的转化</strong></h3><ol>\n<li><strong>字符串转数组</strong></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&quot;123456&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = str.split(<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr)</span><br><span class=\"line\"><span class=\"comment\">//[1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>\n<p><code>split</code>可以将字符串转换为数组，里面接受两个参数，第一个参数表示以什么做为分隔符分隔字符串，第二个参数指定返回数组的长度。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&quot;123&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = <span class=\"built_in\">Array</span>.from(str)</span><br></pre></td></tr></table></figure>\n<p><code>Array.from</code>可以将一个有length属性的对象，转换成一个数组。接受3个参数，第一个参数是要转换为数组的对象，第二个参数是数组中每个参数要调用的函数，映射函数中this的对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> str = arr.join()</span><br></pre></td></tr></table></figure>\n<p><code>join</code>可以将数组里所有元素连接起来，变成一个字符串。接受一个参数，指定数组里面的每个元素用什么方式相连。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr3 = arr.concat(arr1)</span><br></pre></td></tr></table></figure>\n<p><code>concat</code>可以连接两个数组，不会改变原来的数组，会返回一个连接后的新数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr1 = arr.slice(<span class=\"number\">0</span>,<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p><code>slice</code>可以截取数组，接受两个参数，第一个参数表示从哪里开始截取，第二个参数表示截取到哪里结束。第二个参数如果省略，就会从开始的位置一直到数组最后。如果是0的话，就可以截取整个数组，这样就相当于复制的这个数组。</p>\n<h3 id=\"数组的增删改查\"><a href=\"#数组的增删改查\" class=\"headerlink\" title=\"数组的增删改查\"></a><strong>数组的增删改查</strong></h3><p><strong>删除数组里的元素</strong><br>修改<code>length</code>这样也可以删除元素。但是不建议这样删除数组里面的元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">arr.shift()</span><br></pre></td></tr></table></figure>\n<p><code>shift()</code>可以删除数组里的第一个元素，并且返回该元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">arr.pop()</span><br></pre></td></tr></table></figure>\n<p><code>pop()</code>可以删除数组里的最后一个元素，并且返回该元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">arr.splice(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p><code>splice()</code>方法接受三个参数，第一个是数组元素的位置，第二是要删除几个，第三个就是要在删除的位置上增加的元素</p>\n<p><strong>查看数组里的元素</strong><br>因为数组也是一种对象，所以可以用<code>Object.keys</code>和<code>Object.values</code>来查看数组里面元素的属性名和属性值。因为数组里面所谓的属性名都是用数字作为属性名，如果通过<code>Object.keys</code>来查看的话，会连不是数字的属性名也一并查出来,所以查看数组，我们一般是用<code>for</code>循环来遍历一个数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;i&#125;</span>:<span class=\"subst\">$&#123;arr[i]&#125;</span>`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码就是用<code>for</code>循环遍历一个数组</p>\n<p>还可以用<code>forEach()</code>来遍历一个数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y,z</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;y&#125;</span>:$[x];<span class=\"subst\">$&#123;z&#125;</span>`</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><code>forEach()</code>方法接受一个函数，函数里面接受3个参数，第一个参数是数组的索引，第二参数是数组的元素，第三个参数是数组本身。<br>为了更好的理解<code>forEach</code>，我们可以手写一个<code>forEach</code>函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foreach</span>(<span class=\"params\">fn</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"built_in\">this</span>.length;i++)&#123;</span><br><span class=\"line\">\t\tfn(i,<span class=\"built_in\">this</span>[i],<span class=\"built_in\">this</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码就是<code>forEach</code>的原理，接受一个函数，然后<code>for</code>循环，每次<code>for</code>循环就调用一次传入的函数，并且把<code>i</code>,<code>this[i]</code>,<code>this</code>,传回给函数。</p>\n<p>查看数组里面的单个元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">arr[<span class=\"number\">0</span>] <span class=\"comment\">//查看第一个元素</span></span><br><span class=\"line\">arr[<span class=\"number\">1</span>] <span class=\"comment\">//查看第二个元素</span></span><br></pre></td></tr></table></figure>\n\n<p>查看数组里面是否有否个元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]</span><br><span class=\"line\">arr.indexOf(item)</span><br></pre></td></tr></table></figure>\n<p>如果存在元素，就返回该元素对应的索引，如果不存就返回-1</p>\n<p>使用条件查找元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>]</span><br><span class=\"line\">arr.find(<span class=\"function\"><span class=\"params\">item</span>=&gt;</span>item%<span class=\"number\">2</span>===<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<p>找到第一个偶数</p>\n<p><strong>增加数组里的元素</strong><br><code>push()</code>从尾部加入N个元素，返回数组的新长度。</p>\n<p><code>unshift()</code>从头部加入N个，返回数组新长度。</p>\n<p><code>splice()</code> </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">arr.splice(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n<p>以上代码表示，从索引为1的位置，删除0个元素，然后插入1,2,3,4</p>\n<p><code>reverse()</code> 可以改变数组的排列顺序</p>\n<p><code>sort()</code> 让数组进行排序</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">20</span>,<span class=\"number\">32</span>,<span class=\"number\">3</span>,<span class=\"number\">41</span>,<span class=\"number\">53</span>]</span><br><span class=\"line\">arr.sort()</span><br></pre></td></tr></table></figure>\n<p>理解不了，默认情况是按从小到大的排序。如果要按从大到小排序，需要进行下面操作</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">20</span>,<span class=\"number\">32</span>,<span class=\"number\">3</span>,<span class=\"number\">41</span>,<span class=\"number\">53</span>]</span><br><span class=\"line\">arr.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a - b <span class=\"comment\">//升序</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b - a <span class=\"comment\">//降序</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>原理现在的知识，实在是搞不懂，只能死记硬背。。</p>\n<h3 id=\"数组变化\"><a href=\"#数组变化\" class=\"headerlink\" title=\"数组变化\"></a><strong>数组变化</strong></h3><p>有三个方法</p>\n<ol>\n<li><code>map()</code> 加工一下原有数组，然后返回。 n变n</li>\n<li><code>filter()</code> 在数组里面找到符合条件的元素 n变少</li>\n<li><code>reduce()</code> n变1<br>三个方法可以通过下图理解<div align=\"center\"><img src=\"./img/img1.png\"></div>\n\n</li>\n</ol>\n<p><code>map()</code>和<code>fliter()</code>都很好理解<br>最难理解的是<code>reduce()</code><br><code>reduce()</code>里面接受两个参数，第一个参数为一个函数，第二个参数是原始值</p>\n<ol>\n<li>第一个值(fn),里面有可以接受4个值</li>\n</ol>\n<ul>\n<li>累记器</li>\n<li>数组中正在处理的元素</li>\n<li>数组中正在处理元素的索引</li>\n<li>数组本身</li>\n</ul>\n<ol start=\"2\">\n<li>原始值</li>\n</ol>\n<p>下面是两个例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\">arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">sum,item</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum = sum + item</span><br><span class=\"line\">&#125;,<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<p>数组arr里面所有元素相加。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b,c</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(b&gt;<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a = a.concat(c)</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;,[])</span><br></pre></td></tr></table></figure>\n<p>上面的代码是，把arr数组里面，所有大于3的元素的索引，记录在一个数组里面</p>\n<p>&lt;完&gt;</p>\n<p>参考资料<br>饥人谷</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Javascript里面并没有真正的数组，只是用对象模拟的数组。</p>\n</blockquote>\n<h3 id=\"创建一个数组\"><a href=\"#创建一个数组\" class=\"headerlink\" title=\"创建一个数组\"></a><strong>创建一个数组</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">let</span> arr1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>)</span><br></pre></td></tr></table></figure>","more":"<p>上面两种方法都可以创建一个数组，第一种是简写模式，第二种是规范模式，要注意的是第二种创建的方式，如果<code>Array()</code>里面只有一个参数的时候，是定义这个数组<code>length</code>。</p>\n<h3 id=\"数组的转化\"><a href=\"#数组的转化\" class=\"headerlink\" title=\"数组的转化\"></a><strong>数组的转化</strong></h3><ol>\n<li><strong>字符串转数组</strong></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&quot;123456&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = str.split(<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr)</span><br><span class=\"line\"><span class=\"comment\">//[1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>\n<p><code>split</code>可以将字符串转换为数组，里面接受两个参数，第一个参数表示以什么做为分隔符分隔字符串，第二个参数指定返回数组的长度。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&quot;123&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = <span class=\"built_in\">Array</span>.from(str)</span><br></pre></td></tr></table></figure>\n<p><code>Array.from</code>可以将一个有length属性的对象，转换成一个数组。接受3个参数，第一个参数是要转换为数组的对象，第二个参数是数组中每个参数要调用的函数，映射函数中this的对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> str = arr.join()</span><br></pre></td></tr></table></figure>\n<p><code>join</code>可以将数组里所有元素连接起来，变成一个字符串。接受一个参数，指定数组里面的每个元素用什么方式相连。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr3 = arr.concat(arr1)</span><br></pre></td></tr></table></figure>\n<p><code>concat</code>可以连接两个数组，不会改变原来的数组，会返回一个连接后的新数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr1 = arr.slice(<span class=\"number\">0</span>,<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p><code>slice</code>可以截取数组，接受两个参数，第一个参数表示从哪里开始截取，第二个参数表示截取到哪里结束。第二个参数如果省略，就会从开始的位置一直到数组最后。如果是0的话，就可以截取整个数组，这样就相当于复制的这个数组。</p>\n<h3 id=\"数组的增删改查\"><a href=\"#数组的增删改查\" class=\"headerlink\" title=\"数组的增删改查\"></a><strong>数组的增删改查</strong></h3><p><strong>删除数组里的元素</strong><br>修改<code>length</code>这样也可以删除元素。但是不建议这样删除数组里面的元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">arr.shift()</span><br></pre></td></tr></table></figure>\n<p><code>shift()</code>可以删除数组里的第一个元素，并且返回该元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">arr.pop()</span><br></pre></td></tr></table></figure>\n<p><code>pop()</code>可以删除数组里的最后一个元素，并且返回该元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">arr.splice(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p><code>splice()</code>方法接受三个参数，第一个是数组元素的位置，第二是要删除几个，第三个就是要在删除的位置上增加的元素</p>\n<p><strong>查看数组里的元素</strong><br>因为数组也是一种对象，所以可以用<code>Object.keys</code>和<code>Object.values</code>来查看数组里面元素的属性名和属性值。因为数组里面所谓的属性名都是用数字作为属性名，如果通过<code>Object.keys</code>来查看的话，会连不是数字的属性名也一并查出来,所以查看数组，我们一般是用<code>for</code>循环来遍历一个数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;i&#125;</span>:<span class=\"subst\">$&#123;arr[i]&#125;</span>`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码就是用<code>for</code>循环遍历一个数组</p>\n<p>还可以用<code>forEach()</code>来遍历一个数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y,z</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;y&#125;</span>:$[x];<span class=\"subst\">$&#123;z&#125;</span>`</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><code>forEach()</code>方法接受一个函数，函数里面接受3个参数，第一个参数是数组的索引，第二参数是数组的元素，第三个参数是数组本身。<br>为了更好的理解<code>forEach</code>，我们可以手写一个<code>forEach</code>函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foreach</span>(<span class=\"params\">fn</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"built_in\">this</span>.length;i++)&#123;</span><br><span class=\"line\">\t\tfn(i,<span class=\"built_in\">this</span>[i],<span class=\"built_in\">this</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码就是<code>forEach</code>的原理，接受一个函数，然后<code>for</code>循环，每次<code>for</code>循环就调用一次传入的函数，并且把<code>i</code>,<code>this[i]</code>,<code>this</code>,传回给函数。</p>\n<p>查看数组里面的单个元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">arr[<span class=\"number\">0</span>] <span class=\"comment\">//查看第一个元素</span></span><br><span class=\"line\">arr[<span class=\"number\">1</span>] <span class=\"comment\">//查看第二个元素</span></span><br></pre></td></tr></table></figure>\n\n<p>查看数组里面是否有否个元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]</span><br><span class=\"line\">arr.indexOf(item)</span><br></pre></td></tr></table></figure>\n<p>如果存在元素，就返回该元素对应的索引，如果不存就返回-1</p>\n<p>使用条件查找元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>]</span><br><span class=\"line\">arr.find(<span class=\"function\"><span class=\"params\">item</span>=&gt;</span>item%<span class=\"number\">2</span>===<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<p>找到第一个偶数</p>\n<p><strong>增加数组里的元素</strong><br><code>push()</code>从尾部加入N个元素，返回数组的新长度。</p>\n<p><code>unshift()</code>从头部加入N个，返回数组新长度。</p>\n<p><code>splice()</code> </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">arr.splice(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n<p>以上代码表示，从索引为1的位置，删除0个元素，然后插入1,2,3,4</p>\n<p><code>reverse()</code> 可以改变数组的排列顺序</p>\n<p><code>sort()</code> 让数组进行排序</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">20</span>,<span class=\"number\">32</span>,<span class=\"number\">3</span>,<span class=\"number\">41</span>,<span class=\"number\">53</span>]</span><br><span class=\"line\">arr.sort()</span><br></pre></td></tr></table></figure>\n<p>理解不了，默认情况是按从小到大的排序。如果要按从大到小排序，需要进行下面操作</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">20</span>,<span class=\"number\">32</span>,<span class=\"number\">3</span>,<span class=\"number\">41</span>,<span class=\"number\">53</span>]</span><br><span class=\"line\">arr.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a - b <span class=\"comment\">//升序</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b - a <span class=\"comment\">//降序</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>原理现在的知识，实在是搞不懂，只能死记硬背。。</p>\n<h3 id=\"数组变化\"><a href=\"#数组变化\" class=\"headerlink\" title=\"数组变化\"></a><strong>数组变化</strong></h3><p>有三个方法</p>\n<ol>\n<li><code>map()</code> 加工一下原有数组，然后返回。 n变n</li>\n<li><code>filter()</code> 在数组里面找到符合条件的元素 n变少</li>\n<li><code>reduce()</code> n变1<br>三个方法可以通过下图理解<div align=\"center\"><img src=\"./img/img1.png\"></div>\n\n</li>\n</ol>\n<p><code>map()</code>和<code>fliter()</code>都很好理解<br>最难理解的是<code>reduce()</code><br><code>reduce()</code>里面接受两个参数，第一个参数为一个函数，第二个参数是原始值</p>\n<ol>\n<li>第一个值(fn),里面有可以接受4个值</li>\n</ol>\n<ul>\n<li>累记器</li>\n<li>数组中正在处理的元素</li>\n<li>数组中正在处理元素的索引</li>\n<li>数组本身</li>\n</ul>\n<ol start=\"2\">\n<li>原始值</li>\n</ol>\n<p>下面是两个例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\">arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">sum,item</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum = sum + item</span><br><span class=\"line\">&#125;,<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<p>数组arr里面所有元素相加。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b,c</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(b&gt;<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a = a.concat(c)</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;,[])</span><br></pre></td></tr></table></figure>\n<p>上面的代码是，把arr数组里面，所有大于3的元素的索引，记录在一个数组里面</p>\n<p>&lt;完&gt;</p>\n<p>参考资料<br>饥人谷</p>"},{"title":"JS函数","date":"2020-11-11T12:25:05.000Z","toc":true,"cover":"./img/JS1.jpg","_content":"> 函数也是一种对象，虽然看着很不像，但函数真的是一个对象，请接受这个结论，因为解释起来太抽象了。\n\n<!--more-->\n\n### __定义一个函数__\n```javascript\n// 具名函数\nfunction 函数名(参数1,参数2,...){\n\t语句\n\treturn 返回值\n}\n\n//匿名函数\nlet fn = function(参数1,参数2..){\n\t语句\n\treturn 返回值\n}\n\n//箭头函数\nlet fn = (参数1,参数2..)=>{\n\t语句\n\treturn 返回值\n}\n```\n箭头函数如果只有一个参数可以省略`()`,函数内只有一个一个语句的话，也可以省略`{}`和`retrurn`\n\n```javascript\nlet fn = (x,y) => {name:x,age:y}\n// 会报错，因为JS不知道这是对象还是代码块。如果想要返回一个对象，要写成下面这样的代码\nlet fn = (x,y) => ({name:x,age:y})\n// 用圆括号包起来，JS就知道要返回的是一个对象\n```\n```javascript\nlet fn1 = function fn2(){\n\tconsole.log(\"fn2\")\n} \n```\n以上代码，是把一个具名函数内存的地址，传给`fn1`。这里要注意`fn2`在全局环境是找不到的，`fn2`的作用域只在`=`右边这个表达式。\n\n### __函数调用__\n```javascript\nlet fn = function(){\n\tconsole.log(\"Hello World\")\n}\n```\n`fn`表示函数本身，`fn()`表示调用这个函数\n\n### __函数作用域__\nJS采用的是词法作用域，也叫静态作用域。是指在词法分析阶段就已经确定了，不会随着函数的调用或是程序运行而改变。\n以下是个例子\n```javascript\nlet value = 1\nfunction foo(){\n\tconsole.log(value)\n}\nfunction bar(){\n\tlet value = 2\n\tfoo()\n}\nbar() //1\n```\n函数`foo()` `bar()`和变量`value`是一级链，函数`bar()`调用进入了二级链，二级链里面又个`foo()`,此时进入`foo()`的作用域，`foo()`在最外层，所有就找到了`value=1`\n\n```javascript\nlet a = 1\nlet fn1 = function(){\n\tlet a = 2\n\tfunction fn2(){\n\t\tconsole.log(a)\n\t}\n}\nfn1() // 2\n```\n从以上两个例子可以得出结论：\n1. 先确定函数所在的层级\n2. 就近原则\n\n### __函数的形式参数__\n> 顾名思义，形式参数并不是实际参入的参数，只是表示这个函数接受这几个参数。\n\n```javascript\nlet fn = function(x,y){\n\treturn x*y\n}\nfn(1,2)\n```\n上面代码的`x`和`y`，并不是实际要传入函数的参数，只是我们在声明的时候，说明这个函数接受两个参数，在我们调用的时候`fn(1,2)`，这时`1`和`2`才是实际传入的参数。调用的时候`1`和`2`，会被赋值给`x`和`y`\n```javascript\nlet fn = function(){\n\tvar x = arguments[0]\n\tvar y = arguments[2]\n\treturn x*y\n}\n```\n这个代码和上面的代码是等价的。\n\n### __函数返回值__\n只有函数有返回值，函数的返回值是`return`后面的东西。如果没有写`return`，函数的返回值就是`undefined`\n\n<div align=\"center\"><img src=\"./img/img1.jpg\"></div>\n\n上图所示，没有写`return`的时候，当我们调用`fn()`的时候，返回值就是`undefined`，需要注意的是，这里的`3`并不是函数`fn()`的返回值，而是`console.log()`打印出来的东西。\n\n<div align=\"center\"><img src=\"./img/img2.jpg\"></div>\n\n上图所示，写了`return`的时候，在调用`fn()`的时候，就没有了`undefined`\n\n### __调用栈__\n简单的说：JS引擎里面，在调用一个函数的时候，需要把函数的环境push到一个数组里面，这个数组就叫调用栈，调用栈有一个特点`先进后出`。等执行完又把环境pop出来。层层递进。\n[什么是调用栈](https://blog.poetries.top/browser-working-principle/guide/part2/lesson08.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8)\n\n利用递归的方法，可以查看出每个浏览器调用栈的大小。\n```javascript\nfunction fn(n){\n\treturn n !== 1 ? n+f(n-1) : 1\n}\n```\n以上代码，会不断的调用`fn()`直到`n=1`的时候。你停的调用，就会实现，调用栈一直处于压栈的状态，这样就可以测试出不同浏览器，调用栈的大小。\n\n### __函数提升__\n在申明具名函数的时候，不管写在那里，函数都会跑到第一行，跟`var`有点像。这里要注意只有具名函数会提升，匿名函数是不会被提升的。\n```javascript\nlet fn1 = function(){\n\tconsole.log(\"hi\")\n}\n```\n以上代码只是把一个匿名函数，赋值给了`fn1`。`fn1`不会被提升。\n\n### __箭头函数__\n箭头函数里面没有`this`和`arguments`。\n\n### __立即执行函数__\n```javascript\n! function fn(){\n\tconsole.log(\"立即执行\")\n}()\n```\n以上代码，不需要我们`fn()`了，他会立即被调用。\n\n完\n资料来源：\n饥人谷\n[浏览器工作原理和实践](https://blog.poetries.top/browser-working-principle/)\n","source":"_posts/JS函数.md","raw":"---\ntitle: JS函数\ndate: 2020-11-11 12:25:05\ntags: javascript\ntoc: true\ncover: ./img/JS1.jpg\n---\n> 函数也是一种对象，虽然看着很不像，但函数真的是一个对象，请接受这个结论，因为解释起来太抽象了。\n\n<!--more-->\n\n### __定义一个函数__\n```javascript\n// 具名函数\nfunction 函数名(参数1,参数2,...){\n\t语句\n\treturn 返回值\n}\n\n//匿名函数\nlet fn = function(参数1,参数2..){\n\t语句\n\treturn 返回值\n}\n\n//箭头函数\nlet fn = (参数1,参数2..)=>{\n\t语句\n\treturn 返回值\n}\n```\n箭头函数如果只有一个参数可以省略`()`,函数内只有一个一个语句的话，也可以省略`{}`和`retrurn`\n\n```javascript\nlet fn = (x,y) => {name:x,age:y}\n// 会报错，因为JS不知道这是对象还是代码块。如果想要返回一个对象，要写成下面这样的代码\nlet fn = (x,y) => ({name:x,age:y})\n// 用圆括号包起来，JS就知道要返回的是一个对象\n```\n```javascript\nlet fn1 = function fn2(){\n\tconsole.log(\"fn2\")\n} \n```\n以上代码，是把一个具名函数内存的地址，传给`fn1`。这里要注意`fn2`在全局环境是找不到的，`fn2`的作用域只在`=`右边这个表达式。\n\n### __函数调用__\n```javascript\nlet fn = function(){\n\tconsole.log(\"Hello World\")\n}\n```\n`fn`表示函数本身，`fn()`表示调用这个函数\n\n### __函数作用域__\nJS采用的是词法作用域，也叫静态作用域。是指在词法分析阶段就已经确定了，不会随着函数的调用或是程序运行而改变。\n以下是个例子\n```javascript\nlet value = 1\nfunction foo(){\n\tconsole.log(value)\n}\nfunction bar(){\n\tlet value = 2\n\tfoo()\n}\nbar() //1\n```\n函数`foo()` `bar()`和变量`value`是一级链，函数`bar()`调用进入了二级链，二级链里面又个`foo()`,此时进入`foo()`的作用域，`foo()`在最外层，所有就找到了`value=1`\n\n```javascript\nlet a = 1\nlet fn1 = function(){\n\tlet a = 2\n\tfunction fn2(){\n\t\tconsole.log(a)\n\t}\n}\nfn1() // 2\n```\n从以上两个例子可以得出结论：\n1. 先确定函数所在的层级\n2. 就近原则\n\n### __函数的形式参数__\n> 顾名思义，形式参数并不是实际参入的参数，只是表示这个函数接受这几个参数。\n\n```javascript\nlet fn = function(x,y){\n\treturn x*y\n}\nfn(1,2)\n```\n上面代码的`x`和`y`，并不是实际要传入函数的参数，只是我们在声明的时候，说明这个函数接受两个参数，在我们调用的时候`fn(1,2)`，这时`1`和`2`才是实际传入的参数。调用的时候`1`和`2`，会被赋值给`x`和`y`\n```javascript\nlet fn = function(){\n\tvar x = arguments[0]\n\tvar y = arguments[2]\n\treturn x*y\n}\n```\n这个代码和上面的代码是等价的。\n\n### __函数返回值__\n只有函数有返回值，函数的返回值是`return`后面的东西。如果没有写`return`，函数的返回值就是`undefined`\n\n<div align=\"center\"><img src=\"./img/img1.jpg\"></div>\n\n上图所示，没有写`return`的时候，当我们调用`fn()`的时候，返回值就是`undefined`，需要注意的是，这里的`3`并不是函数`fn()`的返回值，而是`console.log()`打印出来的东西。\n\n<div align=\"center\"><img src=\"./img/img2.jpg\"></div>\n\n上图所示，写了`return`的时候，在调用`fn()`的时候，就没有了`undefined`\n\n### __调用栈__\n简单的说：JS引擎里面，在调用一个函数的时候，需要把函数的环境push到一个数组里面，这个数组就叫调用栈，调用栈有一个特点`先进后出`。等执行完又把环境pop出来。层层递进。\n[什么是调用栈](https://blog.poetries.top/browser-working-principle/guide/part2/lesson08.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8)\n\n利用递归的方法，可以查看出每个浏览器调用栈的大小。\n```javascript\nfunction fn(n){\n\treturn n !== 1 ? n+f(n-1) : 1\n}\n```\n以上代码，会不断的调用`fn()`直到`n=1`的时候。你停的调用，就会实现，调用栈一直处于压栈的状态，这样就可以测试出不同浏览器，调用栈的大小。\n\n### __函数提升__\n在申明具名函数的时候，不管写在那里，函数都会跑到第一行，跟`var`有点像。这里要注意只有具名函数会提升，匿名函数是不会被提升的。\n```javascript\nlet fn1 = function(){\n\tconsole.log(\"hi\")\n}\n```\n以上代码只是把一个匿名函数，赋值给了`fn1`。`fn1`不会被提升。\n\n### __箭头函数__\n箭头函数里面没有`this`和`arguments`。\n\n### __立即执行函数__\n```javascript\n! function fn(){\n\tconsole.log(\"立即执行\")\n}()\n```\n以上代码，不需要我们`fn()`了，他会立即被调用。\n\n完\n资料来源：\n饥人谷\n[浏览器工作原理和实践](https://blog.poetries.top/browser-working-principle/)\n","slug":"JS函数","published":1,"updated":"2020-11-11T15:50:43.446Z","_id":"ckhddn8bt0000m5fqhgslfxz9","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>函数也是一种对象，虽然看着很不像，但函数真的是一个对象，请接受这个结论，因为解释起来太抽象了。</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h3 id=\"定义一个函数\"><a href=\"#定义一个函数\" class=\"headerlink\" title=\"定义一个函数\"></a><strong>定义一个函数</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 具名函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> 函数名(<span class=\"params\">参数<span class=\"number\">1</span>,参数<span class=\"number\">2</span>,...</span>)</span>&#123;</span><br><span class=\"line\">\t语句</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> 返回值</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//匿名函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">参数<span class=\"number\">1</span>,参数<span class=\"number\">2.</span>.</span>)</span>&#123;</span><br><span class=\"line\">\t语句</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> 返回值</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//箭头函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fn = <span class=\"function\">(<span class=\"params\">参数<span class=\"number\">1</span>,参数<span class=\"number\">2.</span>.</span>)=&gt;</span>&#123;</span><br><span class=\"line\">\t语句</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> 返回值</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>箭头函数如果只有一个参数可以省略<code>()</code>,函数内只有一个一个语句的话，也可以省略<code>&#123;&#125;</code>和<code>retrurn</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fn = <span class=\"function\">(<span class=\"params\">x,y</span>) =&gt;</span> &#123;<span class=\"attr\">name</span>:x,<span class=\"attr\">age</span>:y&#125;</span><br><span class=\"line\"><span class=\"comment\">// 会报错，因为JS不知道这是对象还是代码块。如果想要返回一个对象，要写成下面这样的代码</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fn = <span class=\"function\">(<span class=\"params\">x,y</span>) =&gt;</span> (&#123;<span class=\"attr\">name</span>:x,<span class=\"attr\">age</span>:y&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 用圆括号包起来，JS就知道要返回的是一个对象</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fn1 = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;fn2&quot;</span>)</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>以上代码，是把一个具名函数内存的地址，传给<code>fn1</code>。这里要注意<code>fn2</code>在全局环境是找不到的，<code>fn2</code>的作用域只在<code>=</code>右边这个表达式。</p>\n<h3 id=\"函数调用\"><a href=\"#函数调用\" class=\"headerlink\" title=\"函数调用\"></a><strong>函数调用</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Hello World&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>fn</code>表示函数本身，<code>fn()</code>表示调用这个函数</p>\n<h3 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a><strong>函数作用域</strong></h3><p>JS采用的是词法作用域，也叫静态作用域。是指在词法分析阶段就已经确定了，不会随着函数的调用或是程序运行而改变。<br>以下是个例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> value = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> value = <span class=\"number\">2</span></span><br><span class=\"line\">\tfoo()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar() <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n<p>函数<code>foo()</code> <code>bar()</code>和变量<code>value</code>是一级链，函数<code>bar()</code>调用进入了二级链，二级链里面又个<code>foo()</code>,此时进入<code>foo()</code>的作用域，<code>foo()</code>在最外层，所有就找到了<code>value=1</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fn1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> a = <span class=\"number\">2</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(a)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn1() <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>从以上两个例子可以得出结论：</p>\n<ol>\n<li>先确定函数所在的层级</li>\n<li>就近原则</li>\n</ol>\n<h3 id=\"函数的形式参数\"><a href=\"#函数的形式参数\" class=\"headerlink\" title=\"函数的形式参数\"></a><strong>函数的形式参数</strong></h3><blockquote>\n<p>顾名思义，形式参数并不是实际参入的参数，只是表示这个函数接受这几个参数。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x*y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>上面代码的<code>x</code>和<code>y</code>，并不是实际要传入函数的参数，只是我们在声明的时候，说明这个函数接受两个参数，在我们调用的时候<code>fn(1,2)</code>，这时<code>1</code>和<code>2</code>才是实际传入的参数。调用的时候<code>1</code>和<code>2</code>，会被赋值给<code>x</code>和<code>y</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> x = <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> y = <span class=\"built_in\">arguments</span>[<span class=\"number\">2</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x*y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个代码和上面的代码是等价的。</p>\n<h3 id=\"函数返回值\"><a href=\"#函数返回值\" class=\"headerlink\" title=\"函数返回值\"></a><strong>函数返回值</strong></h3><p>只有函数有返回值，函数的返回值是<code>return</code>后面的东西。如果没有写<code>return</code>，函数的返回值就是<code>undefined</code></p>\n<div align=\"center\"><img src=\"./img/img1.jpg\"></div>\n\n<p>上图所示，没有写<code>return</code>的时候，当我们调用<code>fn()</code>的时候，返回值就是<code>undefined</code>，需要注意的是，这里的<code>3</code>并不是函数<code>fn()</code>的返回值，而是<code>console.log()</code>打印出来的东西。</p>\n<div align=\"center\"><img src=\"./img/img2.jpg\"></div>\n\n<p>上图所示，写了<code>return</code>的时候，在调用<code>fn()</code>的时候，就没有了<code>undefined</code></p>\n<h3 id=\"调用栈\"><a href=\"#调用栈\" class=\"headerlink\" title=\"调用栈\"></a><strong>调用栈</strong></h3><p>简单的说：JS引擎里面，在调用一个函数的时候，需要把函数的环境push到一个数组里面，这个数组就叫调用栈，调用栈有一个特点<code>先进后出</code>。等执行完又把环境pop出来。层层递进。<br><a href=\"https://blog.poetries.top/browser-working-principle/guide/part2/lesson08.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8\">什么是调用栈</a></p>\n<p>利用递归的方法，可以查看出每个浏览器调用栈的大小。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n !== <span class=\"number\">1</span> ? n+f(n<span class=\"number\">-1</span>) : <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码，会不断的调用<code>fn()</code>直到<code>n=1</code>的时候。你停的调用，就会实现，调用栈一直处于压栈的状态，这样就可以测试出不同浏览器，调用栈的大小。</p>\n<h3 id=\"函数提升\"><a href=\"#函数提升\" class=\"headerlink\" title=\"函数提升\"></a><strong>函数提升</strong></h3><p>在申明具名函数的时候，不管写在那里，函数都会跑到第一行，跟<code>var</code>有点像。这里要注意只有具名函数会提升，匿名函数是不会被提升的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fn1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;hi&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码只是把一个匿名函数，赋值给了<code>fn1</code>。<code>fn1</code>不会被提升。</p>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a><strong>箭头函数</strong></h3><p>箭头函数里面没有<code>this</code>和<code>arguments</code>。</p>\n<h3 id=\"立即执行函数\"><a href=\"#立即执行函数\" class=\"headerlink\" title=\"立即执行函数\"></a><strong>立即执行函数</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;立即执行&quot;</span>)</span><br><span class=\"line\">&#125;()</span><br></pre></td></tr></table></figure>\n<p>以上代码，不需要我们<code>fn()</code>了，他会立即被调用。</p>\n<p>完<br>资料来源：<br>饥人谷<br><a href=\"https://blog.poetries.top/browser-working-principle/\">浏览器工作原理和实践</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>函数也是一种对象，虽然看着很不像，但函数真的是一个对象，请接受这个结论，因为解释起来太抽象了。</p>\n</blockquote>","more":"<h3 id=\"定义一个函数\"><a href=\"#定义一个函数\" class=\"headerlink\" title=\"定义一个函数\"></a><strong>定义一个函数</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 具名函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> 函数名(<span class=\"params\">参数<span class=\"number\">1</span>,参数<span class=\"number\">2</span>,...</span>)</span>&#123;</span><br><span class=\"line\">\t语句</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> 返回值</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//匿名函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">参数<span class=\"number\">1</span>,参数<span class=\"number\">2.</span>.</span>)</span>&#123;</span><br><span class=\"line\">\t语句</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> 返回值</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//箭头函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fn = <span class=\"function\">(<span class=\"params\">参数<span class=\"number\">1</span>,参数<span class=\"number\">2.</span>.</span>)=&gt;</span>&#123;</span><br><span class=\"line\">\t语句</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> 返回值</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>箭头函数如果只有一个参数可以省略<code>()</code>,函数内只有一个一个语句的话，也可以省略<code>&#123;&#125;</code>和<code>retrurn</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fn = <span class=\"function\">(<span class=\"params\">x,y</span>) =&gt;</span> &#123;<span class=\"attr\">name</span>:x,<span class=\"attr\">age</span>:y&#125;</span><br><span class=\"line\"><span class=\"comment\">// 会报错，因为JS不知道这是对象还是代码块。如果想要返回一个对象，要写成下面这样的代码</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fn = <span class=\"function\">(<span class=\"params\">x,y</span>) =&gt;</span> (&#123;<span class=\"attr\">name</span>:x,<span class=\"attr\">age</span>:y&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 用圆括号包起来，JS就知道要返回的是一个对象</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fn1 = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;fn2&quot;</span>)</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>以上代码，是把一个具名函数内存的地址，传给<code>fn1</code>。这里要注意<code>fn2</code>在全局环境是找不到的，<code>fn2</code>的作用域只在<code>=</code>右边这个表达式。</p>\n<h3 id=\"函数调用\"><a href=\"#函数调用\" class=\"headerlink\" title=\"函数调用\"></a><strong>函数调用</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Hello World&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>fn</code>表示函数本身，<code>fn()</code>表示调用这个函数</p>\n<h3 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a><strong>函数作用域</strong></h3><p>JS采用的是词法作用域，也叫静态作用域。是指在词法分析阶段就已经确定了，不会随着函数的调用或是程序运行而改变。<br>以下是个例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> value = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> value = <span class=\"number\">2</span></span><br><span class=\"line\">\tfoo()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar() <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n<p>函数<code>foo()</code> <code>bar()</code>和变量<code>value</code>是一级链，函数<code>bar()</code>调用进入了二级链，二级链里面又个<code>foo()</code>,此时进入<code>foo()</code>的作用域，<code>foo()</code>在最外层，所有就找到了<code>value=1</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fn1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> a = <span class=\"number\">2</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(a)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn1() <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>从以上两个例子可以得出结论：</p>\n<ol>\n<li>先确定函数所在的层级</li>\n<li>就近原则</li>\n</ol>\n<h3 id=\"函数的形式参数\"><a href=\"#函数的形式参数\" class=\"headerlink\" title=\"函数的形式参数\"></a><strong>函数的形式参数</strong></h3><blockquote>\n<p>顾名思义，形式参数并不是实际参入的参数，只是表示这个函数接受这几个参数。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x*y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>上面代码的<code>x</code>和<code>y</code>，并不是实际要传入函数的参数，只是我们在声明的时候，说明这个函数接受两个参数，在我们调用的时候<code>fn(1,2)</code>，这时<code>1</code>和<code>2</code>才是实际传入的参数。调用的时候<code>1</code>和<code>2</code>，会被赋值给<code>x</code>和<code>y</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> x = <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> y = <span class=\"built_in\">arguments</span>[<span class=\"number\">2</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x*y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个代码和上面的代码是等价的。</p>\n<h3 id=\"函数返回值\"><a href=\"#函数返回值\" class=\"headerlink\" title=\"函数返回值\"></a><strong>函数返回值</strong></h3><p>只有函数有返回值，函数的返回值是<code>return</code>后面的东西。如果没有写<code>return</code>，函数的返回值就是<code>undefined</code></p>\n<div align=\"center\"><img src=\"./img/img1.jpg\"></div>\n\n<p>上图所示，没有写<code>return</code>的时候，当我们调用<code>fn()</code>的时候，返回值就是<code>undefined</code>，需要注意的是，这里的<code>3</code>并不是函数<code>fn()</code>的返回值，而是<code>console.log()</code>打印出来的东西。</p>\n<div align=\"center\"><img src=\"./img/img2.jpg\"></div>\n\n<p>上图所示，写了<code>return</code>的时候，在调用<code>fn()</code>的时候，就没有了<code>undefined</code></p>\n<h3 id=\"调用栈\"><a href=\"#调用栈\" class=\"headerlink\" title=\"调用栈\"></a><strong>调用栈</strong></h3><p>简单的说：JS引擎里面，在调用一个函数的时候，需要把函数的环境push到一个数组里面，这个数组就叫调用栈，调用栈有一个特点<code>先进后出</code>。等执行完又把环境pop出来。层层递进。<br><a href=\"https://blog.poetries.top/browser-working-principle/guide/part2/lesson08.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8\">什么是调用栈</a></p>\n<p>利用递归的方法，可以查看出每个浏览器调用栈的大小。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n !== <span class=\"number\">1</span> ? n+f(n<span class=\"number\">-1</span>) : <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码，会不断的调用<code>fn()</code>直到<code>n=1</code>的时候。你停的调用，就会实现，调用栈一直处于压栈的状态，这样就可以测试出不同浏览器，调用栈的大小。</p>\n<h3 id=\"函数提升\"><a href=\"#函数提升\" class=\"headerlink\" title=\"函数提升\"></a><strong>函数提升</strong></h3><p>在申明具名函数的时候，不管写在那里，函数都会跑到第一行，跟<code>var</code>有点像。这里要注意只有具名函数会提升，匿名函数是不会被提升的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fn1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;hi&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码只是把一个匿名函数，赋值给了<code>fn1</code>。<code>fn1</code>不会被提升。</p>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a><strong>箭头函数</strong></h3><p>箭头函数里面没有<code>this</code>和<code>arguments</code>。</p>\n<h3 id=\"立即执行函数\"><a href=\"#立即执行函数\" class=\"headerlink\" title=\"立即执行函数\"></a><strong>立即执行函数</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">! <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;立即执行&quot;</span>)</span><br><span class=\"line\">&#125;()</span><br></pre></td></tr></table></figure>\n<p>以上代码，不需要我们<code>fn()</code>了，他会立即被调用。</p>\n<p>完<br>资料来源：<br>饥人谷<br><a href=\"https://blog.poetries.top/browser-working-principle/\">浏览器工作原理和实践</a></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckfbf0u0c0000kgfq1s28en8u","tag_id":"ckfbf4mpl0000kufqhdp8e9cw","_id":"ckfbf4mpo0001kufq86js34xg"},{"post_id":"ckfc7es4u0000b8fqhom1azv7","tag_id":"ckfc7es510001b8fqcogla15y","_id":"ckfc7es530002b8fqfa1i4c6g"},{"post_id":"ckfcri0au0000dsfqflgnfhsq","tag_id":"ckfcri0b40001dsfqb17ihzgq","_id":"ckfcri0b70002dsfq4g6z6w8g"},{"post_id":"ckfct8ks5000009fq7x1u683h","tag_id":"ckfct8ksc000109fqdwjcha8k","_id":"ckfct8ksi000209fqfnlhc2j6"},{"post_id":"ckfe81by60000zvfqdnm557m2","tag_id":"ckfcri0b40001dsfqb17ihzgq","_id":"ckfe81byd0001zvfq69l8ff42"},{"post_id":"ckfgkinwi000016fq84s42i8z","tag_id":"ckfcri0b40001dsfqb17ihzgq","_id":"ckfgkinwo000116fqfss07p9t"},{"post_id":"ckfjuh4ut0000tufqh4v86j2y","tag_id":"ckfjvzsij00001jfq3r6kd612","_id":"ckfjvzsin00011jfq9hpj914v"},{"post_id":"ckfo7o8j40000xrfq2424dj55","tag_id":"ckfo7o8ja0001xrfq4gt8blgs","_id":"ckfo7o8ji0002xrfqevnzct4x"},{"post_id":"ckfoav38z00007yfqbht7hr7v","tag_id":"ckfo7o8ja0001xrfq4gt8blgs","_id":"ckfoav39600017yfq6flfd1xc"},{"post_id":"ckfrodsoe0000aufqc2pt3043","tag_id":"ckfo7o8ja0001xrfq4gt8blgs","_id":"ckfrodson0001aufq1irxau5h"},{"post_id":"ckfrw4q2r00001ofq4gtp5uqz","tag_id":"ckfo7o8ja0001xrfq4gt8blgs","_id":"ckfrw4q2y00011ofq28sxa81j"},{"post_id":"ckftmkspu0000j5fq443aht62","tag_id":"ckfo7o8ja0001xrfq4gt8blgs","_id":"ckftmksq10001j5fq1e1p6izz"},{"post_id":"ckg0orjxz0000cgfq5p671hbc","tag_id":"ckfo7o8ja0001xrfq4gt8blgs","_id":"ckg0t9i7500001hfq4lbpgc2x"},{"post_id":"ckg9f85f30000ejfqedzdd7ix","tag_id":"ckg9f85fa0001ejfqh4lefs5z","_id":"ckg9f85fg0002ejfqbq0rfjnz"},{"post_id":"ckgjfjrtt000066fqh9z8611q","tag_id":"ckgjfjru0000166fq8tp0e9v6","_id":"ckgjfjru7000266fqd2cg4ewz"},{"post_id":"ckgqko9qw0000mrfq16vf07u2","tag_id":"ckgjfjru0000166fq8tp0e9v6","_id":"ckgqko9r30001mrfq5p8ee6q5"},{"post_id":"ckgwfeojw0000snfqf8fohy1c","tag_id":"ckgjfjru0000166fq8tp0e9v6","_id":"ckgwfeok20001snfqfkio9139"},{"post_id":"ckgxs10780000mkfqcse85wte","tag_id":"ckgjfjru0000166fq8tp0e9v6","_id":"ckgxs107e0001mkfqfyhe345v"},{"post_id":"ckh5qrabj00003nfqd7z89hvc","tag_id":"ckgjfjru0000166fq8tp0e9v6","_id":"ckh5qrabq00013nfq5pfk8qtj"},{"post_id":"ckh8uitab00006ffq84rg4y11","tag_id":"ckgjfjru0000166fq8tp0e9v6","_id":"ckh8uitah00016ffq28qn45y6"},{"post_id":"ckhddn8bt0000m5fqhgslfxz9","tag_id":"ckgjfjru0000166fq8tp0e9v6","_id":"ckhddn8c00001m5fq4gq1bl8d"}],"Tag":[{"name":"命令行","_id":"ckfbf4mpl0000kufqhdp8e9cw"},{"name":"git","_id":"ckfc7es510001b8fqcogla15y"},{"name":"HTML","_id":"ckfcri0b40001dsfqb17ihzgq"},{"name":"markdown","_id":"ckfct8ksc000109fqdwjcha8k"},{"name":"ubuntu 网络","_id":"ckfjuh4uz0001tufq6zrb5gmo"},{"name":"ubuntu , 网络","_id":"ckfjuihcv0000eafq22p32qid"},{"name":"ubuntu ;  网络","_id":"ckfjuj0b60000m6fq608zbhu6"},{"name":"ubuntu网络","_id":"ckfjvzsij00001jfq3r6kd612"},{"name":"CSS","_id":"ckfo7o8ja0001xrfq4gt8blgs"},{"name":"css","_id":"ckg0orjy50001cgfq6rqma714"},{"name":"HTTP","_id":"ckg9f85fa0001ejfqh4lefs5z"},{"name":"javascript","_id":"ckgjfjru0000166fq8tp0e9v6"}]}}